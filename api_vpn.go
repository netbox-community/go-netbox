/*
NetBox REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 4.2.2 (4.2)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netbox

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


type VpnAPI interface {

	/*
	VpnIkePoliciesBulkDestroy Method for VpnIkePoliciesBulkDestroy

	Delete a list of IKE policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIkePoliciesBulkDestroyRequest
	*/
	VpnIkePoliciesBulkDestroy(ctx context.Context) ApiVpnIkePoliciesBulkDestroyRequest

	// VpnIkePoliciesBulkDestroyExecute executes the request
	VpnIkePoliciesBulkDestroyExecute(r ApiVpnIkePoliciesBulkDestroyRequest) (*http.Response, error)

	/*
	VpnIkePoliciesBulkPartialUpdate Method for VpnIkePoliciesBulkPartialUpdate

	Patch a list of IKE policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIkePoliciesBulkPartialUpdateRequest
	*/
	VpnIkePoliciesBulkPartialUpdate(ctx context.Context) ApiVpnIkePoliciesBulkPartialUpdateRequest

	// VpnIkePoliciesBulkPartialUpdateExecute executes the request
	//  @return []IKEPolicy
	VpnIkePoliciesBulkPartialUpdateExecute(r ApiVpnIkePoliciesBulkPartialUpdateRequest) ([]IKEPolicy, *http.Response, error)

	/*
	VpnIkePoliciesBulkUpdate Method for VpnIkePoliciesBulkUpdate

	Put a list of IKE policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIkePoliciesBulkUpdateRequest
	*/
	VpnIkePoliciesBulkUpdate(ctx context.Context) ApiVpnIkePoliciesBulkUpdateRequest

	// VpnIkePoliciesBulkUpdateExecute executes the request
	//  @return []IKEPolicy
	VpnIkePoliciesBulkUpdateExecute(r ApiVpnIkePoliciesBulkUpdateRequest) ([]IKEPolicy, *http.Response, error)

	/*
	VpnIkePoliciesCreate Method for VpnIkePoliciesCreate

	Post a list of IKE policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIkePoliciesCreateRequest
	*/
	VpnIkePoliciesCreate(ctx context.Context) ApiVpnIkePoliciesCreateRequest

	// VpnIkePoliciesCreateExecute executes the request
	//  @return IKEPolicy
	VpnIkePoliciesCreateExecute(r ApiVpnIkePoliciesCreateRequest) (*IKEPolicy, *http.Response, error)

	/*
	VpnIkePoliciesDestroy Method for VpnIkePoliciesDestroy

	Delete a IKE policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IKE policy.
	@return ApiVpnIkePoliciesDestroyRequest
	*/
	VpnIkePoliciesDestroy(ctx context.Context, id int32) ApiVpnIkePoliciesDestroyRequest

	// VpnIkePoliciesDestroyExecute executes the request
	VpnIkePoliciesDestroyExecute(r ApiVpnIkePoliciesDestroyRequest) (*http.Response, error)

	/*
	VpnIkePoliciesList Method for VpnIkePoliciesList

	Get a list of IKE policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIkePoliciesListRequest
	*/
	VpnIkePoliciesList(ctx context.Context) ApiVpnIkePoliciesListRequest

	// VpnIkePoliciesListExecute executes the request
	//  @return PaginatedIKEPolicyList
	VpnIkePoliciesListExecute(r ApiVpnIkePoliciesListRequest) (*PaginatedIKEPolicyList, *http.Response, error)

	/*
	VpnIkePoliciesPartialUpdate Method for VpnIkePoliciesPartialUpdate

	Patch a IKE policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IKE policy.
	@return ApiVpnIkePoliciesPartialUpdateRequest
	*/
	VpnIkePoliciesPartialUpdate(ctx context.Context, id int32) ApiVpnIkePoliciesPartialUpdateRequest

	// VpnIkePoliciesPartialUpdateExecute executes the request
	//  @return IKEPolicy
	VpnIkePoliciesPartialUpdateExecute(r ApiVpnIkePoliciesPartialUpdateRequest) (*IKEPolicy, *http.Response, error)

	/*
	VpnIkePoliciesRetrieve Method for VpnIkePoliciesRetrieve

	Get a IKE policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IKE policy.
	@return ApiVpnIkePoliciesRetrieveRequest
	*/
	VpnIkePoliciesRetrieve(ctx context.Context, id int32) ApiVpnIkePoliciesRetrieveRequest

	// VpnIkePoliciesRetrieveExecute executes the request
	//  @return IKEPolicy
	VpnIkePoliciesRetrieveExecute(r ApiVpnIkePoliciesRetrieveRequest) (*IKEPolicy, *http.Response, error)

	/*
	VpnIkePoliciesUpdate Method for VpnIkePoliciesUpdate

	Put a IKE policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IKE policy.
	@return ApiVpnIkePoliciesUpdateRequest
	*/
	VpnIkePoliciesUpdate(ctx context.Context, id int32) ApiVpnIkePoliciesUpdateRequest

	// VpnIkePoliciesUpdateExecute executes the request
	//  @return IKEPolicy
	VpnIkePoliciesUpdateExecute(r ApiVpnIkePoliciesUpdateRequest) (*IKEPolicy, *http.Response, error)

	/*
	VpnIkeProposalsBulkDestroy Method for VpnIkeProposalsBulkDestroy

	Delete a list of IKE proposal objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIkeProposalsBulkDestroyRequest
	*/
	VpnIkeProposalsBulkDestroy(ctx context.Context) ApiVpnIkeProposalsBulkDestroyRequest

	// VpnIkeProposalsBulkDestroyExecute executes the request
	VpnIkeProposalsBulkDestroyExecute(r ApiVpnIkeProposalsBulkDestroyRequest) (*http.Response, error)

	/*
	VpnIkeProposalsBulkPartialUpdate Method for VpnIkeProposalsBulkPartialUpdate

	Patch a list of IKE proposal objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIkeProposalsBulkPartialUpdateRequest
	*/
	VpnIkeProposalsBulkPartialUpdate(ctx context.Context) ApiVpnIkeProposalsBulkPartialUpdateRequest

	// VpnIkeProposalsBulkPartialUpdateExecute executes the request
	//  @return []IKEProposal
	VpnIkeProposalsBulkPartialUpdateExecute(r ApiVpnIkeProposalsBulkPartialUpdateRequest) ([]IKEProposal, *http.Response, error)

	/*
	VpnIkeProposalsBulkUpdate Method for VpnIkeProposalsBulkUpdate

	Put a list of IKE proposal objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIkeProposalsBulkUpdateRequest
	*/
	VpnIkeProposalsBulkUpdate(ctx context.Context) ApiVpnIkeProposalsBulkUpdateRequest

	// VpnIkeProposalsBulkUpdateExecute executes the request
	//  @return []IKEProposal
	VpnIkeProposalsBulkUpdateExecute(r ApiVpnIkeProposalsBulkUpdateRequest) ([]IKEProposal, *http.Response, error)

	/*
	VpnIkeProposalsCreate Method for VpnIkeProposalsCreate

	Post a list of IKE proposal objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIkeProposalsCreateRequest
	*/
	VpnIkeProposalsCreate(ctx context.Context) ApiVpnIkeProposalsCreateRequest

	// VpnIkeProposalsCreateExecute executes the request
	//  @return IKEProposal
	VpnIkeProposalsCreateExecute(r ApiVpnIkeProposalsCreateRequest) (*IKEProposal, *http.Response, error)

	/*
	VpnIkeProposalsDestroy Method for VpnIkeProposalsDestroy

	Delete a IKE proposal object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IKE proposal.
	@return ApiVpnIkeProposalsDestroyRequest
	*/
	VpnIkeProposalsDestroy(ctx context.Context, id int32) ApiVpnIkeProposalsDestroyRequest

	// VpnIkeProposalsDestroyExecute executes the request
	VpnIkeProposalsDestroyExecute(r ApiVpnIkeProposalsDestroyRequest) (*http.Response, error)

	/*
	VpnIkeProposalsList Method for VpnIkeProposalsList

	Get a list of IKE proposal objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIkeProposalsListRequest
	*/
	VpnIkeProposalsList(ctx context.Context) ApiVpnIkeProposalsListRequest

	// VpnIkeProposalsListExecute executes the request
	//  @return PaginatedIKEProposalList
	VpnIkeProposalsListExecute(r ApiVpnIkeProposalsListRequest) (*PaginatedIKEProposalList, *http.Response, error)

	/*
	VpnIkeProposalsPartialUpdate Method for VpnIkeProposalsPartialUpdate

	Patch a IKE proposal object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IKE proposal.
	@return ApiVpnIkeProposalsPartialUpdateRequest
	*/
	VpnIkeProposalsPartialUpdate(ctx context.Context, id int32) ApiVpnIkeProposalsPartialUpdateRequest

	// VpnIkeProposalsPartialUpdateExecute executes the request
	//  @return IKEProposal
	VpnIkeProposalsPartialUpdateExecute(r ApiVpnIkeProposalsPartialUpdateRequest) (*IKEProposal, *http.Response, error)

	/*
	VpnIkeProposalsRetrieve Method for VpnIkeProposalsRetrieve

	Get a IKE proposal object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IKE proposal.
	@return ApiVpnIkeProposalsRetrieveRequest
	*/
	VpnIkeProposalsRetrieve(ctx context.Context, id int32) ApiVpnIkeProposalsRetrieveRequest

	// VpnIkeProposalsRetrieveExecute executes the request
	//  @return IKEProposal
	VpnIkeProposalsRetrieveExecute(r ApiVpnIkeProposalsRetrieveRequest) (*IKEProposal, *http.Response, error)

	/*
	VpnIkeProposalsUpdate Method for VpnIkeProposalsUpdate

	Put a IKE proposal object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IKE proposal.
	@return ApiVpnIkeProposalsUpdateRequest
	*/
	VpnIkeProposalsUpdate(ctx context.Context, id int32) ApiVpnIkeProposalsUpdateRequest

	// VpnIkeProposalsUpdateExecute executes the request
	//  @return IKEProposal
	VpnIkeProposalsUpdateExecute(r ApiVpnIkeProposalsUpdateRequest) (*IKEProposal, *http.Response, error)

	/*
	VpnIpsecPoliciesBulkDestroy Method for VpnIpsecPoliciesBulkDestroy

	Delete a list of IPSec policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecPoliciesBulkDestroyRequest
	*/
	VpnIpsecPoliciesBulkDestroy(ctx context.Context) ApiVpnIpsecPoliciesBulkDestroyRequest

	// VpnIpsecPoliciesBulkDestroyExecute executes the request
	VpnIpsecPoliciesBulkDestroyExecute(r ApiVpnIpsecPoliciesBulkDestroyRequest) (*http.Response, error)

	/*
	VpnIpsecPoliciesBulkPartialUpdate Method for VpnIpsecPoliciesBulkPartialUpdate

	Patch a list of IPSec policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecPoliciesBulkPartialUpdateRequest
	*/
	VpnIpsecPoliciesBulkPartialUpdate(ctx context.Context) ApiVpnIpsecPoliciesBulkPartialUpdateRequest

	// VpnIpsecPoliciesBulkPartialUpdateExecute executes the request
	//  @return []IPSecPolicy
	VpnIpsecPoliciesBulkPartialUpdateExecute(r ApiVpnIpsecPoliciesBulkPartialUpdateRequest) ([]IPSecPolicy, *http.Response, error)

	/*
	VpnIpsecPoliciesBulkUpdate Method for VpnIpsecPoliciesBulkUpdate

	Put a list of IPSec policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecPoliciesBulkUpdateRequest
	*/
	VpnIpsecPoliciesBulkUpdate(ctx context.Context) ApiVpnIpsecPoliciesBulkUpdateRequest

	// VpnIpsecPoliciesBulkUpdateExecute executes the request
	//  @return []IPSecPolicy
	VpnIpsecPoliciesBulkUpdateExecute(r ApiVpnIpsecPoliciesBulkUpdateRequest) ([]IPSecPolicy, *http.Response, error)

	/*
	VpnIpsecPoliciesCreate Method for VpnIpsecPoliciesCreate

	Post a list of IPSec policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecPoliciesCreateRequest
	*/
	VpnIpsecPoliciesCreate(ctx context.Context) ApiVpnIpsecPoliciesCreateRequest

	// VpnIpsecPoliciesCreateExecute executes the request
	//  @return IPSecPolicy
	VpnIpsecPoliciesCreateExecute(r ApiVpnIpsecPoliciesCreateRequest) (*IPSecPolicy, *http.Response, error)

	/*
	VpnIpsecPoliciesDestroy Method for VpnIpsecPoliciesDestroy

	Delete a IPSec policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec policy.
	@return ApiVpnIpsecPoliciesDestroyRequest
	*/
	VpnIpsecPoliciesDestroy(ctx context.Context, id int32) ApiVpnIpsecPoliciesDestroyRequest

	// VpnIpsecPoliciesDestroyExecute executes the request
	VpnIpsecPoliciesDestroyExecute(r ApiVpnIpsecPoliciesDestroyRequest) (*http.Response, error)

	/*
	VpnIpsecPoliciesList Method for VpnIpsecPoliciesList

	Get a list of IPSec policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecPoliciesListRequest
	*/
	VpnIpsecPoliciesList(ctx context.Context) ApiVpnIpsecPoliciesListRequest

	// VpnIpsecPoliciesListExecute executes the request
	//  @return PaginatedIPSecPolicyList
	VpnIpsecPoliciesListExecute(r ApiVpnIpsecPoliciesListRequest) (*PaginatedIPSecPolicyList, *http.Response, error)

	/*
	VpnIpsecPoliciesPartialUpdate Method for VpnIpsecPoliciesPartialUpdate

	Patch a IPSec policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec policy.
	@return ApiVpnIpsecPoliciesPartialUpdateRequest
	*/
	VpnIpsecPoliciesPartialUpdate(ctx context.Context, id int32) ApiVpnIpsecPoliciesPartialUpdateRequest

	// VpnIpsecPoliciesPartialUpdateExecute executes the request
	//  @return IPSecPolicy
	VpnIpsecPoliciesPartialUpdateExecute(r ApiVpnIpsecPoliciesPartialUpdateRequest) (*IPSecPolicy, *http.Response, error)

	/*
	VpnIpsecPoliciesRetrieve Method for VpnIpsecPoliciesRetrieve

	Get a IPSec policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec policy.
	@return ApiVpnIpsecPoliciesRetrieveRequest
	*/
	VpnIpsecPoliciesRetrieve(ctx context.Context, id int32) ApiVpnIpsecPoliciesRetrieveRequest

	// VpnIpsecPoliciesRetrieveExecute executes the request
	//  @return IPSecPolicy
	VpnIpsecPoliciesRetrieveExecute(r ApiVpnIpsecPoliciesRetrieveRequest) (*IPSecPolicy, *http.Response, error)

	/*
	VpnIpsecPoliciesUpdate Method for VpnIpsecPoliciesUpdate

	Put a IPSec policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec policy.
	@return ApiVpnIpsecPoliciesUpdateRequest
	*/
	VpnIpsecPoliciesUpdate(ctx context.Context, id int32) ApiVpnIpsecPoliciesUpdateRequest

	// VpnIpsecPoliciesUpdateExecute executes the request
	//  @return IPSecPolicy
	VpnIpsecPoliciesUpdateExecute(r ApiVpnIpsecPoliciesUpdateRequest) (*IPSecPolicy, *http.Response, error)

	/*
	VpnIpsecProfilesBulkDestroy Method for VpnIpsecProfilesBulkDestroy

	Delete a list of IPSec profile objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecProfilesBulkDestroyRequest
	*/
	VpnIpsecProfilesBulkDestroy(ctx context.Context) ApiVpnIpsecProfilesBulkDestroyRequest

	// VpnIpsecProfilesBulkDestroyExecute executes the request
	VpnIpsecProfilesBulkDestroyExecute(r ApiVpnIpsecProfilesBulkDestroyRequest) (*http.Response, error)

	/*
	VpnIpsecProfilesBulkPartialUpdate Method for VpnIpsecProfilesBulkPartialUpdate

	Patch a list of IPSec profile objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecProfilesBulkPartialUpdateRequest
	*/
	VpnIpsecProfilesBulkPartialUpdate(ctx context.Context) ApiVpnIpsecProfilesBulkPartialUpdateRequest

	// VpnIpsecProfilesBulkPartialUpdateExecute executes the request
	//  @return []IPSecProfile
	VpnIpsecProfilesBulkPartialUpdateExecute(r ApiVpnIpsecProfilesBulkPartialUpdateRequest) ([]IPSecProfile, *http.Response, error)

	/*
	VpnIpsecProfilesBulkUpdate Method for VpnIpsecProfilesBulkUpdate

	Put a list of IPSec profile objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecProfilesBulkUpdateRequest
	*/
	VpnIpsecProfilesBulkUpdate(ctx context.Context) ApiVpnIpsecProfilesBulkUpdateRequest

	// VpnIpsecProfilesBulkUpdateExecute executes the request
	//  @return []IPSecProfile
	VpnIpsecProfilesBulkUpdateExecute(r ApiVpnIpsecProfilesBulkUpdateRequest) ([]IPSecProfile, *http.Response, error)

	/*
	VpnIpsecProfilesCreate Method for VpnIpsecProfilesCreate

	Post a list of IPSec profile objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecProfilesCreateRequest
	*/
	VpnIpsecProfilesCreate(ctx context.Context) ApiVpnIpsecProfilesCreateRequest

	// VpnIpsecProfilesCreateExecute executes the request
	//  @return IPSecProfile
	VpnIpsecProfilesCreateExecute(r ApiVpnIpsecProfilesCreateRequest) (*IPSecProfile, *http.Response, error)

	/*
	VpnIpsecProfilesDestroy Method for VpnIpsecProfilesDestroy

	Delete a IPSec profile object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec profile.
	@return ApiVpnIpsecProfilesDestroyRequest
	*/
	VpnIpsecProfilesDestroy(ctx context.Context, id int32) ApiVpnIpsecProfilesDestroyRequest

	// VpnIpsecProfilesDestroyExecute executes the request
	VpnIpsecProfilesDestroyExecute(r ApiVpnIpsecProfilesDestroyRequest) (*http.Response, error)

	/*
	VpnIpsecProfilesList Method for VpnIpsecProfilesList

	Get a list of IPSec profile objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecProfilesListRequest
	*/
	VpnIpsecProfilesList(ctx context.Context) ApiVpnIpsecProfilesListRequest

	// VpnIpsecProfilesListExecute executes the request
	//  @return PaginatedIPSecProfileList
	VpnIpsecProfilesListExecute(r ApiVpnIpsecProfilesListRequest) (*PaginatedIPSecProfileList, *http.Response, error)

	/*
	VpnIpsecProfilesPartialUpdate Method for VpnIpsecProfilesPartialUpdate

	Patch a IPSec profile object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec profile.
	@return ApiVpnIpsecProfilesPartialUpdateRequest
	*/
	VpnIpsecProfilesPartialUpdate(ctx context.Context, id int32) ApiVpnIpsecProfilesPartialUpdateRequest

	// VpnIpsecProfilesPartialUpdateExecute executes the request
	//  @return IPSecProfile
	VpnIpsecProfilesPartialUpdateExecute(r ApiVpnIpsecProfilesPartialUpdateRequest) (*IPSecProfile, *http.Response, error)

	/*
	VpnIpsecProfilesRetrieve Method for VpnIpsecProfilesRetrieve

	Get a IPSec profile object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec profile.
	@return ApiVpnIpsecProfilesRetrieveRequest
	*/
	VpnIpsecProfilesRetrieve(ctx context.Context, id int32) ApiVpnIpsecProfilesRetrieveRequest

	// VpnIpsecProfilesRetrieveExecute executes the request
	//  @return IPSecProfile
	VpnIpsecProfilesRetrieveExecute(r ApiVpnIpsecProfilesRetrieveRequest) (*IPSecProfile, *http.Response, error)

	/*
	VpnIpsecProfilesUpdate Method for VpnIpsecProfilesUpdate

	Put a IPSec profile object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec profile.
	@return ApiVpnIpsecProfilesUpdateRequest
	*/
	VpnIpsecProfilesUpdate(ctx context.Context, id int32) ApiVpnIpsecProfilesUpdateRequest

	// VpnIpsecProfilesUpdateExecute executes the request
	//  @return IPSecProfile
	VpnIpsecProfilesUpdateExecute(r ApiVpnIpsecProfilesUpdateRequest) (*IPSecProfile, *http.Response, error)

	/*
	VpnIpsecProposalsBulkDestroy Method for VpnIpsecProposalsBulkDestroy

	Delete a list of IPSec proposal objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecProposalsBulkDestroyRequest
	*/
	VpnIpsecProposalsBulkDestroy(ctx context.Context) ApiVpnIpsecProposalsBulkDestroyRequest

	// VpnIpsecProposalsBulkDestroyExecute executes the request
	VpnIpsecProposalsBulkDestroyExecute(r ApiVpnIpsecProposalsBulkDestroyRequest) (*http.Response, error)

	/*
	VpnIpsecProposalsBulkPartialUpdate Method for VpnIpsecProposalsBulkPartialUpdate

	Patch a list of IPSec proposal objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecProposalsBulkPartialUpdateRequest
	*/
	VpnIpsecProposalsBulkPartialUpdate(ctx context.Context) ApiVpnIpsecProposalsBulkPartialUpdateRequest

	// VpnIpsecProposalsBulkPartialUpdateExecute executes the request
	//  @return []IPSecProposal
	VpnIpsecProposalsBulkPartialUpdateExecute(r ApiVpnIpsecProposalsBulkPartialUpdateRequest) ([]IPSecProposal, *http.Response, error)

	/*
	VpnIpsecProposalsBulkUpdate Method for VpnIpsecProposalsBulkUpdate

	Put a list of IPSec proposal objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecProposalsBulkUpdateRequest
	*/
	VpnIpsecProposalsBulkUpdate(ctx context.Context) ApiVpnIpsecProposalsBulkUpdateRequest

	// VpnIpsecProposalsBulkUpdateExecute executes the request
	//  @return []IPSecProposal
	VpnIpsecProposalsBulkUpdateExecute(r ApiVpnIpsecProposalsBulkUpdateRequest) ([]IPSecProposal, *http.Response, error)

	/*
	VpnIpsecProposalsCreate Method for VpnIpsecProposalsCreate

	Post a list of IPSec proposal objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecProposalsCreateRequest
	*/
	VpnIpsecProposalsCreate(ctx context.Context) ApiVpnIpsecProposalsCreateRequest

	// VpnIpsecProposalsCreateExecute executes the request
	//  @return IPSecProposal
	VpnIpsecProposalsCreateExecute(r ApiVpnIpsecProposalsCreateRequest) (*IPSecProposal, *http.Response, error)

	/*
	VpnIpsecProposalsDestroy Method for VpnIpsecProposalsDestroy

	Delete a IPSec proposal object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec proposal.
	@return ApiVpnIpsecProposalsDestroyRequest
	*/
	VpnIpsecProposalsDestroy(ctx context.Context, id int32) ApiVpnIpsecProposalsDestroyRequest

	// VpnIpsecProposalsDestroyExecute executes the request
	VpnIpsecProposalsDestroyExecute(r ApiVpnIpsecProposalsDestroyRequest) (*http.Response, error)

	/*
	VpnIpsecProposalsList Method for VpnIpsecProposalsList

	Get a list of IPSec proposal objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnIpsecProposalsListRequest
	*/
	VpnIpsecProposalsList(ctx context.Context) ApiVpnIpsecProposalsListRequest

	// VpnIpsecProposalsListExecute executes the request
	//  @return PaginatedIPSecProposalList
	VpnIpsecProposalsListExecute(r ApiVpnIpsecProposalsListRequest) (*PaginatedIPSecProposalList, *http.Response, error)

	/*
	VpnIpsecProposalsPartialUpdate Method for VpnIpsecProposalsPartialUpdate

	Patch a IPSec proposal object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec proposal.
	@return ApiVpnIpsecProposalsPartialUpdateRequest
	*/
	VpnIpsecProposalsPartialUpdate(ctx context.Context, id int32) ApiVpnIpsecProposalsPartialUpdateRequest

	// VpnIpsecProposalsPartialUpdateExecute executes the request
	//  @return IPSecProposal
	VpnIpsecProposalsPartialUpdateExecute(r ApiVpnIpsecProposalsPartialUpdateRequest) (*IPSecProposal, *http.Response, error)

	/*
	VpnIpsecProposalsRetrieve Method for VpnIpsecProposalsRetrieve

	Get a IPSec proposal object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec proposal.
	@return ApiVpnIpsecProposalsRetrieveRequest
	*/
	VpnIpsecProposalsRetrieve(ctx context.Context, id int32) ApiVpnIpsecProposalsRetrieveRequest

	// VpnIpsecProposalsRetrieveExecute executes the request
	//  @return IPSecProposal
	VpnIpsecProposalsRetrieveExecute(r ApiVpnIpsecProposalsRetrieveRequest) (*IPSecProposal, *http.Response, error)

	/*
	VpnIpsecProposalsUpdate Method for VpnIpsecProposalsUpdate

	Put a IPSec proposal object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IPSec proposal.
	@return ApiVpnIpsecProposalsUpdateRequest
	*/
	VpnIpsecProposalsUpdate(ctx context.Context, id int32) ApiVpnIpsecProposalsUpdateRequest

	// VpnIpsecProposalsUpdateExecute executes the request
	//  @return IPSecProposal
	VpnIpsecProposalsUpdateExecute(r ApiVpnIpsecProposalsUpdateRequest) (*IPSecProposal, *http.Response, error)

	/*
	VpnL2vpnTerminationsBulkDestroy Method for VpnL2vpnTerminationsBulkDestroy

	Delete a list of L2VPN termination objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnL2vpnTerminationsBulkDestroyRequest
	*/
	VpnL2vpnTerminationsBulkDestroy(ctx context.Context) ApiVpnL2vpnTerminationsBulkDestroyRequest

	// VpnL2vpnTerminationsBulkDestroyExecute executes the request
	VpnL2vpnTerminationsBulkDestroyExecute(r ApiVpnL2vpnTerminationsBulkDestroyRequest) (*http.Response, error)

	/*
	VpnL2vpnTerminationsBulkPartialUpdate Method for VpnL2vpnTerminationsBulkPartialUpdate

	Patch a list of L2VPN termination objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnL2vpnTerminationsBulkPartialUpdateRequest
	*/
	VpnL2vpnTerminationsBulkPartialUpdate(ctx context.Context) ApiVpnL2vpnTerminationsBulkPartialUpdateRequest

	// VpnL2vpnTerminationsBulkPartialUpdateExecute executes the request
	//  @return []L2VPNTermination
	VpnL2vpnTerminationsBulkPartialUpdateExecute(r ApiVpnL2vpnTerminationsBulkPartialUpdateRequest) ([]L2VPNTermination, *http.Response, error)

	/*
	VpnL2vpnTerminationsBulkUpdate Method for VpnL2vpnTerminationsBulkUpdate

	Put a list of L2VPN termination objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnL2vpnTerminationsBulkUpdateRequest
	*/
	VpnL2vpnTerminationsBulkUpdate(ctx context.Context) ApiVpnL2vpnTerminationsBulkUpdateRequest

	// VpnL2vpnTerminationsBulkUpdateExecute executes the request
	//  @return []L2VPNTermination
	VpnL2vpnTerminationsBulkUpdateExecute(r ApiVpnL2vpnTerminationsBulkUpdateRequest) ([]L2VPNTermination, *http.Response, error)

	/*
	VpnL2vpnTerminationsCreate Method for VpnL2vpnTerminationsCreate

	Post a list of L2VPN termination objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnL2vpnTerminationsCreateRequest
	*/
	VpnL2vpnTerminationsCreate(ctx context.Context) ApiVpnL2vpnTerminationsCreateRequest

	// VpnL2vpnTerminationsCreateExecute executes the request
	//  @return L2VPNTermination
	VpnL2vpnTerminationsCreateExecute(r ApiVpnL2vpnTerminationsCreateRequest) (*L2VPNTermination, *http.Response, error)

	/*
	VpnL2vpnTerminationsDestroy Method for VpnL2vpnTerminationsDestroy

	Delete a L2VPN termination object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this L2VPN termination.
	@return ApiVpnL2vpnTerminationsDestroyRequest
	*/
	VpnL2vpnTerminationsDestroy(ctx context.Context, id int32) ApiVpnL2vpnTerminationsDestroyRequest

	// VpnL2vpnTerminationsDestroyExecute executes the request
	VpnL2vpnTerminationsDestroyExecute(r ApiVpnL2vpnTerminationsDestroyRequest) (*http.Response, error)

	/*
	VpnL2vpnTerminationsList Method for VpnL2vpnTerminationsList

	Get a list of L2VPN termination objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnL2vpnTerminationsListRequest
	*/
	VpnL2vpnTerminationsList(ctx context.Context) ApiVpnL2vpnTerminationsListRequest

	// VpnL2vpnTerminationsListExecute executes the request
	//  @return PaginatedL2VPNTerminationList
	VpnL2vpnTerminationsListExecute(r ApiVpnL2vpnTerminationsListRequest) (*PaginatedL2VPNTerminationList, *http.Response, error)

	/*
	VpnL2vpnTerminationsPartialUpdate Method for VpnL2vpnTerminationsPartialUpdate

	Patch a L2VPN termination object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this L2VPN termination.
	@return ApiVpnL2vpnTerminationsPartialUpdateRequest
	*/
	VpnL2vpnTerminationsPartialUpdate(ctx context.Context, id int32) ApiVpnL2vpnTerminationsPartialUpdateRequest

	// VpnL2vpnTerminationsPartialUpdateExecute executes the request
	//  @return L2VPNTermination
	VpnL2vpnTerminationsPartialUpdateExecute(r ApiVpnL2vpnTerminationsPartialUpdateRequest) (*L2VPNTermination, *http.Response, error)

	/*
	VpnL2vpnTerminationsRetrieve Method for VpnL2vpnTerminationsRetrieve

	Get a L2VPN termination object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this L2VPN termination.
	@return ApiVpnL2vpnTerminationsRetrieveRequest
	*/
	VpnL2vpnTerminationsRetrieve(ctx context.Context, id int32) ApiVpnL2vpnTerminationsRetrieveRequest

	// VpnL2vpnTerminationsRetrieveExecute executes the request
	//  @return L2VPNTermination
	VpnL2vpnTerminationsRetrieveExecute(r ApiVpnL2vpnTerminationsRetrieveRequest) (*L2VPNTermination, *http.Response, error)

	/*
	VpnL2vpnTerminationsUpdate Method for VpnL2vpnTerminationsUpdate

	Put a L2VPN termination object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this L2VPN termination.
	@return ApiVpnL2vpnTerminationsUpdateRequest
	*/
	VpnL2vpnTerminationsUpdate(ctx context.Context, id int32) ApiVpnL2vpnTerminationsUpdateRequest

	// VpnL2vpnTerminationsUpdateExecute executes the request
	//  @return L2VPNTermination
	VpnL2vpnTerminationsUpdateExecute(r ApiVpnL2vpnTerminationsUpdateRequest) (*L2VPNTermination, *http.Response, error)

	/*
	VpnL2vpnsBulkDestroy Method for VpnL2vpnsBulkDestroy

	Delete a list of L2VPN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnL2vpnsBulkDestroyRequest
	*/
	VpnL2vpnsBulkDestroy(ctx context.Context) ApiVpnL2vpnsBulkDestroyRequest

	// VpnL2vpnsBulkDestroyExecute executes the request
	VpnL2vpnsBulkDestroyExecute(r ApiVpnL2vpnsBulkDestroyRequest) (*http.Response, error)

	/*
	VpnL2vpnsBulkPartialUpdate Method for VpnL2vpnsBulkPartialUpdate

	Patch a list of L2VPN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnL2vpnsBulkPartialUpdateRequest
	*/
	VpnL2vpnsBulkPartialUpdate(ctx context.Context) ApiVpnL2vpnsBulkPartialUpdateRequest

	// VpnL2vpnsBulkPartialUpdateExecute executes the request
	//  @return []L2VPN
	VpnL2vpnsBulkPartialUpdateExecute(r ApiVpnL2vpnsBulkPartialUpdateRequest) ([]L2VPN, *http.Response, error)

	/*
	VpnL2vpnsBulkUpdate Method for VpnL2vpnsBulkUpdate

	Put a list of L2VPN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnL2vpnsBulkUpdateRequest
	*/
	VpnL2vpnsBulkUpdate(ctx context.Context) ApiVpnL2vpnsBulkUpdateRequest

	// VpnL2vpnsBulkUpdateExecute executes the request
	//  @return []L2VPN
	VpnL2vpnsBulkUpdateExecute(r ApiVpnL2vpnsBulkUpdateRequest) ([]L2VPN, *http.Response, error)

	/*
	VpnL2vpnsCreate Method for VpnL2vpnsCreate

	Post a list of L2VPN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnL2vpnsCreateRequest
	*/
	VpnL2vpnsCreate(ctx context.Context) ApiVpnL2vpnsCreateRequest

	// VpnL2vpnsCreateExecute executes the request
	//  @return L2VPN
	VpnL2vpnsCreateExecute(r ApiVpnL2vpnsCreateRequest) (*L2VPN, *http.Response, error)

	/*
	VpnL2vpnsDestroy Method for VpnL2vpnsDestroy

	Delete a L2VPN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this L2VPN.
	@return ApiVpnL2vpnsDestroyRequest
	*/
	VpnL2vpnsDestroy(ctx context.Context, id int32) ApiVpnL2vpnsDestroyRequest

	// VpnL2vpnsDestroyExecute executes the request
	VpnL2vpnsDestroyExecute(r ApiVpnL2vpnsDestroyRequest) (*http.Response, error)

	/*
	VpnL2vpnsList Method for VpnL2vpnsList

	Get a list of L2VPN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnL2vpnsListRequest
	*/
	VpnL2vpnsList(ctx context.Context) ApiVpnL2vpnsListRequest

	// VpnL2vpnsListExecute executes the request
	//  @return PaginatedL2VPNList
	VpnL2vpnsListExecute(r ApiVpnL2vpnsListRequest) (*PaginatedL2VPNList, *http.Response, error)

	/*
	VpnL2vpnsPartialUpdate Method for VpnL2vpnsPartialUpdate

	Patch a L2VPN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this L2VPN.
	@return ApiVpnL2vpnsPartialUpdateRequest
	*/
	VpnL2vpnsPartialUpdate(ctx context.Context, id int32) ApiVpnL2vpnsPartialUpdateRequest

	// VpnL2vpnsPartialUpdateExecute executes the request
	//  @return L2VPN
	VpnL2vpnsPartialUpdateExecute(r ApiVpnL2vpnsPartialUpdateRequest) (*L2VPN, *http.Response, error)

	/*
	VpnL2vpnsRetrieve Method for VpnL2vpnsRetrieve

	Get a L2VPN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this L2VPN.
	@return ApiVpnL2vpnsRetrieveRequest
	*/
	VpnL2vpnsRetrieve(ctx context.Context, id int32) ApiVpnL2vpnsRetrieveRequest

	// VpnL2vpnsRetrieveExecute executes the request
	//  @return L2VPN
	VpnL2vpnsRetrieveExecute(r ApiVpnL2vpnsRetrieveRequest) (*L2VPN, *http.Response, error)

	/*
	VpnL2vpnsUpdate Method for VpnL2vpnsUpdate

	Put a L2VPN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this L2VPN.
	@return ApiVpnL2vpnsUpdateRequest
	*/
	VpnL2vpnsUpdate(ctx context.Context, id int32) ApiVpnL2vpnsUpdateRequest

	// VpnL2vpnsUpdateExecute executes the request
	//  @return L2VPN
	VpnL2vpnsUpdateExecute(r ApiVpnL2vpnsUpdateRequest) (*L2VPN, *http.Response, error)

	/*
	VpnTunnelGroupsBulkDestroy Method for VpnTunnelGroupsBulkDestroy

	Delete a list of tunnel group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelGroupsBulkDestroyRequest
	*/
	VpnTunnelGroupsBulkDestroy(ctx context.Context) ApiVpnTunnelGroupsBulkDestroyRequest

	// VpnTunnelGroupsBulkDestroyExecute executes the request
	VpnTunnelGroupsBulkDestroyExecute(r ApiVpnTunnelGroupsBulkDestroyRequest) (*http.Response, error)

	/*
	VpnTunnelGroupsBulkPartialUpdate Method for VpnTunnelGroupsBulkPartialUpdate

	Patch a list of tunnel group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelGroupsBulkPartialUpdateRequest
	*/
	VpnTunnelGroupsBulkPartialUpdate(ctx context.Context) ApiVpnTunnelGroupsBulkPartialUpdateRequest

	// VpnTunnelGroupsBulkPartialUpdateExecute executes the request
	//  @return []TunnelGroup
	VpnTunnelGroupsBulkPartialUpdateExecute(r ApiVpnTunnelGroupsBulkPartialUpdateRequest) ([]TunnelGroup, *http.Response, error)

	/*
	VpnTunnelGroupsBulkUpdate Method for VpnTunnelGroupsBulkUpdate

	Put a list of tunnel group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelGroupsBulkUpdateRequest
	*/
	VpnTunnelGroupsBulkUpdate(ctx context.Context) ApiVpnTunnelGroupsBulkUpdateRequest

	// VpnTunnelGroupsBulkUpdateExecute executes the request
	//  @return []TunnelGroup
	VpnTunnelGroupsBulkUpdateExecute(r ApiVpnTunnelGroupsBulkUpdateRequest) ([]TunnelGroup, *http.Response, error)

	/*
	VpnTunnelGroupsCreate Method for VpnTunnelGroupsCreate

	Post a list of tunnel group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelGroupsCreateRequest
	*/
	VpnTunnelGroupsCreate(ctx context.Context) ApiVpnTunnelGroupsCreateRequest

	// VpnTunnelGroupsCreateExecute executes the request
	//  @return TunnelGroup
	VpnTunnelGroupsCreateExecute(r ApiVpnTunnelGroupsCreateRequest) (*TunnelGroup, *http.Response, error)

	/*
	VpnTunnelGroupsDestroy Method for VpnTunnelGroupsDestroy

	Delete a tunnel group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel group.
	@return ApiVpnTunnelGroupsDestroyRequest
	*/
	VpnTunnelGroupsDestroy(ctx context.Context, id int32) ApiVpnTunnelGroupsDestroyRequest

	// VpnTunnelGroupsDestroyExecute executes the request
	VpnTunnelGroupsDestroyExecute(r ApiVpnTunnelGroupsDestroyRequest) (*http.Response, error)

	/*
	VpnTunnelGroupsList Method for VpnTunnelGroupsList

	Get a list of tunnel group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelGroupsListRequest
	*/
	VpnTunnelGroupsList(ctx context.Context) ApiVpnTunnelGroupsListRequest

	// VpnTunnelGroupsListExecute executes the request
	//  @return PaginatedTunnelGroupList
	VpnTunnelGroupsListExecute(r ApiVpnTunnelGroupsListRequest) (*PaginatedTunnelGroupList, *http.Response, error)

	/*
	VpnTunnelGroupsPartialUpdate Method for VpnTunnelGroupsPartialUpdate

	Patch a tunnel group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel group.
	@return ApiVpnTunnelGroupsPartialUpdateRequest
	*/
	VpnTunnelGroupsPartialUpdate(ctx context.Context, id int32) ApiVpnTunnelGroupsPartialUpdateRequest

	// VpnTunnelGroupsPartialUpdateExecute executes the request
	//  @return TunnelGroup
	VpnTunnelGroupsPartialUpdateExecute(r ApiVpnTunnelGroupsPartialUpdateRequest) (*TunnelGroup, *http.Response, error)

	/*
	VpnTunnelGroupsRetrieve Method for VpnTunnelGroupsRetrieve

	Get a tunnel group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel group.
	@return ApiVpnTunnelGroupsRetrieveRequest
	*/
	VpnTunnelGroupsRetrieve(ctx context.Context, id int32) ApiVpnTunnelGroupsRetrieveRequest

	// VpnTunnelGroupsRetrieveExecute executes the request
	//  @return TunnelGroup
	VpnTunnelGroupsRetrieveExecute(r ApiVpnTunnelGroupsRetrieveRequest) (*TunnelGroup, *http.Response, error)

	/*
	VpnTunnelGroupsUpdate Method for VpnTunnelGroupsUpdate

	Put a tunnel group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel group.
	@return ApiVpnTunnelGroupsUpdateRequest
	*/
	VpnTunnelGroupsUpdate(ctx context.Context, id int32) ApiVpnTunnelGroupsUpdateRequest

	// VpnTunnelGroupsUpdateExecute executes the request
	//  @return TunnelGroup
	VpnTunnelGroupsUpdateExecute(r ApiVpnTunnelGroupsUpdateRequest) (*TunnelGroup, *http.Response, error)

	/*
	VpnTunnelTerminationsBulkDestroy Method for VpnTunnelTerminationsBulkDestroy

	Delete a list of tunnel termination objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelTerminationsBulkDestroyRequest
	*/
	VpnTunnelTerminationsBulkDestroy(ctx context.Context) ApiVpnTunnelTerminationsBulkDestroyRequest

	// VpnTunnelTerminationsBulkDestroyExecute executes the request
	VpnTunnelTerminationsBulkDestroyExecute(r ApiVpnTunnelTerminationsBulkDestroyRequest) (*http.Response, error)

	/*
	VpnTunnelTerminationsBulkPartialUpdate Method for VpnTunnelTerminationsBulkPartialUpdate

	Patch a list of tunnel termination objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelTerminationsBulkPartialUpdateRequest
	*/
	VpnTunnelTerminationsBulkPartialUpdate(ctx context.Context) ApiVpnTunnelTerminationsBulkPartialUpdateRequest

	// VpnTunnelTerminationsBulkPartialUpdateExecute executes the request
	//  @return []TunnelTermination
	VpnTunnelTerminationsBulkPartialUpdateExecute(r ApiVpnTunnelTerminationsBulkPartialUpdateRequest) ([]TunnelTermination, *http.Response, error)

	/*
	VpnTunnelTerminationsBulkUpdate Method for VpnTunnelTerminationsBulkUpdate

	Put a list of tunnel termination objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelTerminationsBulkUpdateRequest
	*/
	VpnTunnelTerminationsBulkUpdate(ctx context.Context) ApiVpnTunnelTerminationsBulkUpdateRequest

	// VpnTunnelTerminationsBulkUpdateExecute executes the request
	//  @return []TunnelTermination
	VpnTunnelTerminationsBulkUpdateExecute(r ApiVpnTunnelTerminationsBulkUpdateRequest) ([]TunnelTermination, *http.Response, error)

	/*
	VpnTunnelTerminationsCreate Method for VpnTunnelTerminationsCreate

	Post a list of tunnel termination objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelTerminationsCreateRequest
	*/
	VpnTunnelTerminationsCreate(ctx context.Context) ApiVpnTunnelTerminationsCreateRequest

	// VpnTunnelTerminationsCreateExecute executes the request
	//  @return TunnelTermination
	VpnTunnelTerminationsCreateExecute(r ApiVpnTunnelTerminationsCreateRequest) (*TunnelTermination, *http.Response, error)

	/*
	VpnTunnelTerminationsDestroy Method for VpnTunnelTerminationsDestroy

	Delete a tunnel termination object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel termination.
	@return ApiVpnTunnelTerminationsDestroyRequest
	*/
	VpnTunnelTerminationsDestroy(ctx context.Context, id int32) ApiVpnTunnelTerminationsDestroyRequest

	// VpnTunnelTerminationsDestroyExecute executes the request
	VpnTunnelTerminationsDestroyExecute(r ApiVpnTunnelTerminationsDestroyRequest) (*http.Response, error)

	/*
	VpnTunnelTerminationsList Method for VpnTunnelTerminationsList

	Get a list of tunnel termination objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelTerminationsListRequest
	*/
	VpnTunnelTerminationsList(ctx context.Context) ApiVpnTunnelTerminationsListRequest

	// VpnTunnelTerminationsListExecute executes the request
	//  @return PaginatedTunnelTerminationList
	VpnTunnelTerminationsListExecute(r ApiVpnTunnelTerminationsListRequest) (*PaginatedTunnelTerminationList, *http.Response, error)

	/*
	VpnTunnelTerminationsPartialUpdate Method for VpnTunnelTerminationsPartialUpdate

	Patch a tunnel termination object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel termination.
	@return ApiVpnTunnelTerminationsPartialUpdateRequest
	*/
	VpnTunnelTerminationsPartialUpdate(ctx context.Context, id int32) ApiVpnTunnelTerminationsPartialUpdateRequest

	// VpnTunnelTerminationsPartialUpdateExecute executes the request
	//  @return TunnelTermination
	VpnTunnelTerminationsPartialUpdateExecute(r ApiVpnTunnelTerminationsPartialUpdateRequest) (*TunnelTermination, *http.Response, error)

	/*
	VpnTunnelTerminationsRetrieve Method for VpnTunnelTerminationsRetrieve

	Get a tunnel termination object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel termination.
	@return ApiVpnTunnelTerminationsRetrieveRequest
	*/
	VpnTunnelTerminationsRetrieve(ctx context.Context, id int32) ApiVpnTunnelTerminationsRetrieveRequest

	// VpnTunnelTerminationsRetrieveExecute executes the request
	//  @return TunnelTermination
	VpnTunnelTerminationsRetrieveExecute(r ApiVpnTunnelTerminationsRetrieveRequest) (*TunnelTermination, *http.Response, error)

	/*
	VpnTunnelTerminationsUpdate Method for VpnTunnelTerminationsUpdate

	Put a tunnel termination object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel termination.
	@return ApiVpnTunnelTerminationsUpdateRequest
	*/
	VpnTunnelTerminationsUpdate(ctx context.Context, id int32) ApiVpnTunnelTerminationsUpdateRequest

	// VpnTunnelTerminationsUpdateExecute executes the request
	//  @return TunnelTermination
	VpnTunnelTerminationsUpdateExecute(r ApiVpnTunnelTerminationsUpdateRequest) (*TunnelTermination, *http.Response, error)

	/*
	VpnTunnelsBulkDestroy Method for VpnTunnelsBulkDestroy

	Delete a list of tunnel objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelsBulkDestroyRequest
	*/
	VpnTunnelsBulkDestroy(ctx context.Context) ApiVpnTunnelsBulkDestroyRequest

	// VpnTunnelsBulkDestroyExecute executes the request
	VpnTunnelsBulkDestroyExecute(r ApiVpnTunnelsBulkDestroyRequest) (*http.Response, error)

	/*
	VpnTunnelsBulkPartialUpdate Method for VpnTunnelsBulkPartialUpdate

	Patch a list of tunnel objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelsBulkPartialUpdateRequest
	*/
	VpnTunnelsBulkPartialUpdate(ctx context.Context) ApiVpnTunnelsBulkPartialUpdateRequest

	// VpnTunnelsBulkPartialUpdateExecute executes the request
	//  @return []Tunnel
	VpnTunnelsBulkPartialUpdateExecute(r ApiVpnTunnelsBulkPartialUpdateRequest) ([]Tunnel, *http.Response, error)

	/*
	VpnTunnelsBulkUpdate Method for VpnTunnelsBulkUpdate

	Put a list of tunnel objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelsBulkUpdateRequest
	*/
	VpnTunnelsBulkUpdate(ctx context.Context) ApiVpnTunnelsBulkUpdateRequest

	// VpnTunnelsBulkUpdateExecute executes the request
	//  @return []Tunnel
	VpnTunnelsBulkUpdateExecute(r ApiVpnTunnelsBulkUpdateRequest) ([]Tunnel, *http.Response, error)

	/*
	VpnTunnelsCreate Method for VpnTunnelsCreate

	Post a list of tunnel objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelsCreateRequest
	*/
	VpnTunnelsCreate(ctx context.Context) ApiVpnTunnelsCreateRequest

	// VpnTunnelsCreateExecute executes the request
	//  @return Tunnel
	VpnTunnelsCreateExecute(r ApiVpnTunnelsCreateRequest) (*Tunnel, *http.Response, error)

	/*
	VpnTunnelsDestroy Method for VpnTunnelsDestroy

	Delete a tunnel object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel.
	@return ApiVpnTunnelsDestroyRequest
	*/
	VpnTunnelsDestroy(ctx context.Context, id int32) ApiVpnTunnelsDestroyRequest

	// VpnTunnelsDestroyExecute executes the request
	VpnTunnelsDestroyExecute(r ApiVpnTunnelsDestroyRequest) (*http.Response, error)

	/*
	VpnTunnelsList Method for VpnTunnelsList

	Get a list of tunnel objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVpnTunnelsListRequest
	*/
	VpnTunnelsList(ctx context.Context) ApiVpnTunnelsListRequest

	// VpnTunnelsListExecute executes the request
	//  @return PaginatedTunnelList
	VpnTunnelsListExecute(r ApiVpnTunnelsListRequest) (*PaginatedTunnelList, *http.Response, error)

	/*
	VpnTunnelsPartialUpdate Method for VpnTunnelsPartialUpdate

	Patch a tunnel object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel.
	@return ApiVpnTunnelsPartialUpdateRequest
	*/
	VpnTunnelsPartialUpdate(ctx context.Context, id int32) ApiVpnTunnelsPartialUpdateRequest

	// VpnTunnelsPartialUpdateExecute executes the request
	//  @return Tunnel
	VpnTunnelsPartialUpdateExecute(r ApiVpnTunnelsPartialUpdateRequest) (*Tunnel, *http.Response, error)

	/*
	VpnTunnelsRetrieve Method for VpnTunnelsRetrieve

	Get a tunnel object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel.
	@return ApiVpnTunnelsRetrieveRequest
	*/
	VpnTunnelsRetrieve(ctx context.Context, id int32) ApiVpnTunnelsRetrieveRequest

	// VpnTunnelsRetrieveExecute executes the request
	//  @return Tunnel
	VpnTunnelsRetrieveExecute(r ApiVpnTunnelsRetrieveRequest) (*Tunnel, *http.Response, error)

	/*
	VpnTunnelsUpdate Method for VpnTunnelsUpdate

	Put a tunnel object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this tunnel.
	@return ApiVpnTunnelsUpdateRequest
	*/
	VpnTunnelsUpdate(ctx context.Context, id int32) ApiVpnTunnelsUpdateRequest

	// VpnTunnelsUpdateExecute executes the request
	//  @return Tunnel
	VpnTunnelsUpdateExecute(r ApiVpnTunnelsUpdateRequest) (*Tunnel, *http.Response, error)
}

// VpnAPIService VpnAPI service
type VpnAPIService service

type ApiVpnIkePoliciesBulkDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iKEPolicyRequest *[]IKEPolicyRequest
}

func (r ApiVpnIkePoliciesBulkDestroyRequest) IKEPolicyRequest(iKEPolicyRequest []IKEPolicyRequest) ApiVpnIkePoliciesBulkDestroyRequest {
	r.iKEPolicyRequest = &iKEPolicyRequest
	return r
}

func (r ApiVpnIkePoliciesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnIkePoliciesBulkDestroyExecute(r)
}

/*
VpnIkePoliciesBulkDestroy Method for VpnIkePoliciesBulkDestroy

Delete a list of IKE policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIkePoliciesBulkDestroyRequest
*/
func (a *VpnAPIService) VpnIkePoliciesBulkDestroy(ctx context.Context) ApiVpnIkePoliciesBulkDestroyRequest {
	return ApiVpnIkePoliciesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnIkePoliciesBulkDestroyExecute(r ApiVpnIkePoliciesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkePoliciesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iKEPolicyRequest == nil {
		return nil, reportError("iKEPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iKEPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnIkePoliciesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iKEPolicyRequest *[]IKEPolicyRequest
}

func (r ApiVpnIkePoliciesBulkPartialUpdateRequest) IKEPolicyRequest(iKEPolicyRequest []IKEPolicyRequest) ApiVpnIkePoliciesBulkPartialUpdateRequest {
	r.iKEPolicyRequest = &iKEPolicyRequest
	return r
}

func (r ApiVpnIkePoliciesBulkPartialUpdateRequest) Execute() ([]IKEPolicy, *http.Response, error) {
	return r.ApiService.VpnIkePoliciesBulkPartialUpdateExecute(r)
}

/*
VpnIkePoliciesBulkPartialUpdate Method for VpnIkePoliciesBulkPartialUpdate

Patch a list of IKE policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIkePoliciesBulkPartialUpdateRequest
*/
func (a *VpnAPIService) VpnIkePoliciesBulkPartialUpdate(ctx context.Context) ApiVpnIkePoliciesBulkPartialUpdateRequest {
	return ApiVpnIkePoliciesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IKEPolicy
func (a *VpnAPIService) VpnIkePoliciesBulkPartialUpdateExecute(r ApiVpnIkePoliciesBulkPartialUpdateRequest) ([]IKEPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IKEPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkePoliciesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iKEPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("iKEPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iKEPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkePoliciesBulkUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iKEPolicyRequest *[]IKEPolicyRequest
}

func (r ApiVpnIkePoliciesBulkUpdateRequest) IKEPolicyRequest(iKEPolicyRequest []IKEPolicyRequest) ApiVpnIkePoliciesBulkUpdateRequest {
	r.iKEPolicyRequest = &iKEPolicyRequest
	return r
}

func (r ApiVpnIkePoliciesBulkUpdateRequest) Execute() ([]IKEPolicy, *http.Response, error) {
	return r.ApiService.VpnIkePoliciesBulkUpdateExecute(r)
}

/*
VpnIkePoliciesBulkUpdate Method for VpnIkePoliciesBulkUpdate

Put a list of IKE policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIkePoliciesBulkUpdateRequest
*/
func (a *VpnAPIService) VpnIkePoliciesBulkUpdate(ctx context.Context) ApiVpnIkePoliciesBulkUpdateRequest {
	return ApiVpnIkePoliciesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IKEPolicy
func (a *VpnAPIService) VpnIkePoliciesBulkUpdateExecute(r ApiVpnIkePoliciesBulkUpdateRequest) ([]IKEPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IKEPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkePoliciesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iKEPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("iKEPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iKEPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkePoliciesCreateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	writableIKEPolicyRequest *WritableIKEPolicyRequest
}

func (r ApiVpnIkePoliciesCreateRequest) WritableIKEPolicyRequest(writableIKEPolicyRequest WritableIKEPolicyRequest) ApiVpnIkePoliciesCreateRequest {
	r.writableIKEPolicyRequest = &writableIKEPolicyRequest
	return r
}

func (r ApiVpnIkePoliciesCreateRequest) Execute() (*IKEPolicy, *http.Response, error) {
	return r.ApiService.VpnIkePoliciesCreateExecute(r)
}

/*
VpnIkePoliciesCreate Method for VpnIkePoliciesCreate

Post a list of IKE policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIkePoliciesCreateRequest
*/
func (a *VpnAPIService) VpnIkePoliciesCreate(ctx context.Context) ApiVpnIkePoliciesCreateRequest {
	return ApiVpnIkePoliciesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IKEPolicy
func (a *VpnAPIService) VpnIkePoliciesCreateExecute(r ApiVpnIkePoliciesCreateRequest) (*IKEPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IKEPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkePoliciesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIKEPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("writableIKEPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIKEPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkePoliciesDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnIkePoliciesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnIkePoliciesDestroyExecute(r)
}

/*
VpnIkePoliciesDestroy Method for VpnIkePoliciesDestroy

Delete a IKE policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IKE policy.
 @return ApiVpnIkePoliciesDestroyRequest
*/
func (a *VpnAPIService) VpnIkePoliciesDestroy(ctx context.Context, id int32) ApiVpnIkePoliciesDestroyRequest {
	return ApiVpnIkePoliciesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnIkePoliciesDestroyExecute(r ApiVpnIkePoliciesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkePoliciesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnIkePoliciesListRequest struct {
	ctx context.Context
	ApiService VpnAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	ikeProposal *[]string
	ikeProposalN *[]string
	ikeProposalId *[]int32
	ikeProposalIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	mode *[]*string
	modeEmpty *bool
	modeIc *[]*string
	modeIe *[]*string
	modeIew *[]*string
	modeIsw *[]*string
	modeN *[]*string
	modeNic *[]*string
	modeNie *[]*string
	modeNiew *[]*string
	modeNisw *[]*string
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	presharedKey *string
	presharedKeyIc *string
	presharedKeyIe *string
	presharedKeyIew *string
	presharedKeyIsw *string
	presharedKeyN *string
	presharedKeyNic *string
	presharedKeyNie *string
	presharedKeyNiew *string
	presharedKeyNisw *string
	q *string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
	version *[]int32
	versionIc *[]int32
	versionIe *[]int32
	versionIew *[]int32
	versionIsw *[]int32
	versionN *[]int32
	versionNic *[]int32
	versionNie *[]int32
	versionNiew *[]int32
	versionNisw *[]int32
}

func (r ApiVpnIkePoliciesListRequest) Created(created []time.Time) ApiVpnIkePoliciesListRequest {
	r.created = &created
	return r
}

func (r ApiVpnIkePoliciesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiVpnIkePoliciesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiVpnIkePoliciesListRequest) CreatedGt(createdGt []time.Time) ApiVpnIkePoliciesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiVpnIkePoliciesListRequest) CreatedGte(createdGte []time.Time) ApiVpnIkePoliciesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVpnIkePoliciesListRequest) CreatedLt(createdLt []time.Time) ApiVpnIkePoliciesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiVpnIkePoliciesListRequest) CreatedLte(createdLte []time.Time) ApiVpnIkePoliciesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVpnIkePoliciesListRequest) CreatedN(createdN []time.Time) ApiVpnIkePoliciesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiVpnIkePoliciesListRequest) CreatedByRequest(createdByRequest string) ApiVpnIkePoliciesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiVpnIkePoliciesListRequest) Description(description []string) ApiVpnIkePoliciesListRequest {
	r.description = &description
	return r
}

func (r ApiVpnIkePoliciesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiVpnIkePoliciesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiVpnIkePoliciesListRequest) DescriptionIc(descriptionIc []string) ApiVpnIkePoliciesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiVpnIkePoliciesListRequest) DescriptionIe(descriptionIe []string) ApiVpnIkePoliciesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiVpnIkePoliciesListRequest) DescriptionIew(descriptionIew []string) ApiVpnIkePoliciesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiVpnIkePoliciesListRequest) DescriptionIsw(descriptionIsw []string) ApiVpnIkePoliciesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiVpnIkePoliciesListRequest) DescriptionN(descriptionN []string) ApiVpnIkePoliciesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiVpnIkePoliciesListRequest) DescriptionNic(descriptionNic []string) ApiVpnIkePoliciesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiVpnIkePoliciesListRequest) DescriptionNie(descriptionNie []string) ApiVpnIkePoliciesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiVpnIkePoliciesListRequest) DescriptionNiew(descriptionNiew []string) ApiVpnIkePoliciesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiVpnIkePoliciesListRequest) DescriptionNisw(descriptionNisw []string) ApiVpnIkePoliciesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiVpnIkePoliciesListRequest) Id(id []int32) ApiVpnIkePoliciesListRequest {
	r.id = &id
	return r
}

func (r ApiVpnIkePoliciesListRequest) IdEmpty(idEmpty bool) ApiVpnIkePoliciesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiVpnIkePoliciesListRequest) IdGt(idGt []int32) ApiVpnIkePoliciesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVpnIkePoliciesListRequest) IdGte(idGte []int32) ApiVpnIkePoliciesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVpnIkePoliciesListRequest) IdLt(idLt []int32) ApiVpnIkePoliciesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVpnIkePoliciesListRequest) IdLte(idLte []int32) ApiVpnIkePoliciesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVpnIkePoliciesListRequest) IdN(idN []int32) ApiVpnIkePoliciesListRequest {
	r.idN = &idN
	return r
}

func (r ApiVpnIkePoliciesListRequest) IkeProposal(ikeProposal []string) ApiVpnIkePoliciesListRequest {
	r.ikeProposal = &ikeProposal
	return r
}

func (r ApiVpnIkePoliciesListRequest) IkeProposalN(ikeProposalN []string) ApiVpnIkePoliciesListRequest {
	r.ikeProposalN = &ikeProposalN
	return r
}

func (r ApiVpnIkePoliciesListRequest) IkeProposalId(ikeProposalId []int32) ApiVpnIkePoliciesListRequest {
	r.ikeProposalId = &ikeProposalId
	return r
}

func (r ApiVpnIkePoliciesListRequest) IkeProposalIdN(ikeProposalIdN []int32) ApiVpnIkePoliciesListRequest {
	r.ikeProposalIdN = &ikeProposalIdN
	return r
}

func (r ApiVpnIkePoliciesListRequest) LastUpdated(lastUpdated []time.Time) ApiVpnIkePoliciesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVpnIkePoliciesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiVpnIkePoliciesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiVpnIkePoliciesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiVpnIkePoliciesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiVpnIkePoliciesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiVpnIkePoliciesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVpnIkePoliciesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiVpnIkePoliciesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiVpnIkePoliciesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiVpnIkePoliciesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVpnIkePoliciesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiVpnIkePoliciesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiVpnIkePoliciesListRequest) Limit(limit int32) ApiVpnIkePoliciesListRequest {
	r.limit = &limit
	return r
}

func (r ApiVpnIkePoliciesListRequest) Mode(mode []*string) ApiVpnIkePoliciesListRequest {
	r.mode = &mode
	return r
}

func (r ApiVpnIkePoliciesListRequest) ModeEmpty(modeEmpty bool) ApiVpnIkePoliciesListRequest {
	r.modeEmpty = &modeEmpty
	return r
}

func (r ApiVpnIkePoliciesListRequest) ModeIc(modeIc []*string) ApiVpnIkePoliciesListRequest {
	r.modeIc = &modeIc
	return r
}

func (r ApiVpnIkePoliciesListRequest) ModeIe(modeIe []*string) ApiVpnIkePoliciesListRequest {
	r.modeIe = &modeIe
	return r
}

func (r ApiVpnIkePoliciesListRequest) ModeIew(modeIew []*string) ApiVpnIkePoliciesListRequest {
	r.modeIew = &modeIew
	return r
}

func (r ApiVpnIkePoliciesListRequest) ModeIsw(modeIsw []*string) ApiVpnIkePoliciesListRequest {
	r.modeIsw = &modeIsw
	return r
}

func (r ApiVpnIkePoliciesListRequest) ModeN(modeN []*string) ApiVpnIkePoliciesListRequest {
	r.modeN = &modeN
	return r
}

func (r ApiVpnIkePoliciesListRequest) ModeNic(modeNic []*string) ApiVpnIkePoliciesListRequest {
	r.modeNic = &modeNic
	return r
}

func (r ApiVpnIkePoliciesListRequest) ModeNie(modeNie []*string) ApiVpnIkePoliciesListRequest {
	r.modeNie = &modeNie
	return r
}

func (r ApiVpnIkePoliciesListRequest) ModeNiew(modeNiew []*string) ApiVpnIkePoliciesListRequest {
	r.modeNiew = &modeNiew
	return r
}

func (r ApiVpnIkePoliciesListRequest) ModeNisw(modeNisw []*string) ApiVpnIkePoliciesListRequest {
	r.modeNisw = &modeNisw
	return r
}

func (r ApiVpnIkePoliciesListRequest) ModifiedByRequest(modifiedByRequest string) ApiVpnIkePoliciesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiVpnIkePoliciesListRequest) Name(name []string) ApiVpnIkePoliciesListRequest {
	r.name = &name
	return r
}

func (r ApiVpnIkePoliciesListRequest) NameEmpty(nameEmpty bool) ApiVpnIkePoliciesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVpnIkePoliciesListRequest) NameIc(nameIc []string) ApiVpnIkePoliciesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVpnIkePoliciesListRequest) NameIe(nameIe []string) ApiVpnIkePoliciesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVpnIkePoliciesListRequest) NameIew(nameIew []string) ApiVpnIkePoliciesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVpnIkePoliciesListRequest) NameIsw(nameIsw []string) ApiVpnIkePoliciesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVpnIkePoliciesListRequest) NameN(nameN []string) ApiVpnIkePoliciesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVpnIkePoliciesListRequest) NameNic(nameNic []string) ApiVpnIkePoliciesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVpnIkePoliciesListRequest) NameNie(nameNie []string) ApiVpnIkePoliciesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVpnIkePoliciesListRequest) NameNiew(nameNiew []string) ApiVpnIkePoliciesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVpnIkePoliciesListRequest) NameNisw(nameNisw []string) ApiVpnIkePoliciesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiVpnIkePoliciesListRequest) Offset(offset int32) ApiVpnIkePoliciesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiVpnIkePoliciesListRequest) Ordering(ordering string) ApiVpnIkePoliciesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiVpnIkePoliciesListRequest) PresharedKey(presharedKey string) ApiVpnIkePoliciesListRequest {
	r.presharedKey = &presharedKey
	return r
}

func (r ApiVpnIkePoliciesListRequest) PresharedKeyIc(presharedKeyIc string) ApiVpnIkePoliciesListRequest {
	r.presharedKeyIc = &presharedKeyIc
	return r
}

func (r ApiVpnIkePoliciesListRequest) PresharedKeyIe(presharedKeyIe string) ApiVpnIkePoliciesListRequest {
	r.presharedKeyIe = &presharedKeyIe
	return r
}

func (r ApiVpnIkePoliciesListRequest) PresharedKeyIew(presharedKeyIew string) ApiVpnIkePoliciesListRequest {
	r.presharedKeyIew = &presharedKeyIew
	return r
}

func (r ApiVpnIkePoliciesListRequest) PresharedKeyIsw(presharedKeyIsw string) ApiVpnIkePoliciesListRequest {
	r.presharedKeyIsw = &presharedKeyIsw
	return r
}

func (r ApiVpnIkePoliciesListRequest) PresharedKeyN(presharedKeyN string) ApiVpnIkePoliciesListRequest {
	r.presharedKeyN = &presharedKeyN
	return r
}

func (r ApiVpnIkePoliciesListRequest) PresharedKeyNic(presharedKeyNic string) ApiVpnIkePoliciesListRequest {
	r.presharedKeyNic = &presharedKeyNic
	return r
}

func (r ApiVpnIkePoliciesListRequest) PresharedKeyNie(presharedKeyNie string) ApiVpnIkePoliciesListRequest {
	r.presharedKeyNie = &presharedKeyNie
	return r
}

func (r ApiVpnIkePoliciesListRequest) PresharedKeyNiew(presharedKeyNiew string) ApiVpnIkePoliciesListRequest {
	r.presharedKeyNiew = &presharedKeyNiew
	return r
}

func (r ApiVpnIkePoliciesListRequest) PresharedKeyNisw(presharedKeyNisw string) ApiVpnIkePoliciesListRequest {
	r.presharedKeyNisw = &presharedKeyNisw
	return r
}

// Search
func (r ApiVpnIkePoliciesListRequest) Q(q string) ApiVpnIkePoliciesListRequest {
	r.q = &q
	return r
}

func (r ApiVpnIkePoliciesListRequest) Tag(tag []string) ApiVpnIkePoliciesListRequest {
	r.tag = &tag
	return r
}

func (r ApiVpnIkePoliciesListRequest) TagN(tagN []string) ApiVpnIkePoliciesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiVpnIkePoliciesListRequest) UpdatedByRequest(updatedByRequest string) ApiVpnIkePoliciesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiVpnIkePoliciesListRequest) Version(version []int32) ApiVpnIkePoliciesListRequest {
	r.version = &version
	return r
}

func (r ApiVpnIkePoliciesListRequest) VersionIc(versionIc []int32) ApiVpnIkePoliciesListRequest {
	r.versionIc = &versionIc
	return r
}

func (r ApiVpnIkePoliciesListRequest) VersionIe(versionIe []int32) ApiVpnIkePoliciesListRequest {
	r.versionIe = &versionIe
	return r
}

func (r ApiVpnIkePoliciesListRequest) VersionIew(versionIew []int32) ApiVpnIkePoliciesListRequest {
	r.versionIew = &versionIew
	return r
}

func (r ApiVpnIkePoliciesListRequest) VersionIsw(versionIsw []int32) ApiVpnIkePoliciesListRequest {
	r.versionIsw = &versionIsw
	return r
}

func (r ApiVpnIkePoliciesListRequest) VersionN(versionN []int32) ApiVpnIkePoliciesListRequest {
	r.versionN = &versionN
	return r
}

func (r ApiVpnIkePoliciesListRequest) VersionNic(versionNic []int32) ApiVpnIkePoliciesListRequest {
	r.versionNic = &versionNic
	return r
}

func (r ApiVpnIkePoliciesListRequest) VersionNie(versionNie []int32) ApiVpnIkePoliciesListRequest {
	r.versionNie = &versionNie
	return r
}

func (r ApiVpnIkePoliciesListRequest) VersionNiew(versionNiew []int32) ApiVpnIkePoliciesListRequest {
	r.versionNiew = &versionNiew
	return r
}

func (r ApiVpnIkePoliciesListRequest) VersionNisw(versionNisw []int32) ApiVpnIkePoliciesListRequest {
	r.versionNisw = &versionNisw
	return r
}

func (r ApiVpnIkePoliciesListRequest) Execute() (*PaginatedIKEPolicyList, *http.Response, error) {
	return r.ApiService.VpnIkePoliciesListExecute(r)
}

/*
VpnIkePoliciesList Method for VpnIkePoliciesList

Get a list of IKE policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIkePoliciesListRequest
*/
func (a *VpnAPIService) VpnIkePoliciesList(ctx context.Context) ApiVpnIkePoliciesListRequest {
	return ApiVpnIkePoliciesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIKEPolicyList
func (a *VpnAPIService) VpnIkePoliciesListExecute(r ApiVpnIkePoliciesListRequest) (*PaginatedIKEPolicyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIKEPolicyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkePoliciesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.ikeProposal != nil {
		t := *r.ikeProposal
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_proposal", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_proposal", t, "form", "multi")
		}
	}
	if r.ikeProposalN != nil {
		t := *r.ikeProposalN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_proposal__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_proposal__n", t, "form", "multi")
		}
	}
	if r.ikeProposalId != nil {
		t := *r.ikeProposalId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_proposal_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_proposal_id", t, "form", "multi")
		}
	}
	if r.ikeProposalIdN != nil {
		t := *r.ikeProposalIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_proposal_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_proposal_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.mode != nil {
		t := *r.mode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode", t, "form", "multi")
		}
	}
	if r.modeEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode__empty", r.modeEmpty, "form", "")
	}
	if r.modeIc != nil {
		t := *r.modeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ic", t, "form", "multi")
		}
	}
	if r.modeIe != nil {
		t := *r.modeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ie", t, "form", "multi")
		}
	}
	if r.modeIew != nil {
		t := *r.modeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__iew", t, "form", "multi")
		}
	}
	if r.modeIsw != nil {
		t := *r.modeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__isw", t, "form", "multi")
		}
	}
	if r.modeN != nil {
		t := *r.modeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__n", t, "form", "multi")
		}
	}
	if r.modeNic != nil {
		t := *r.modeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nic", t, "form", "multi")
		}
	}
	if r.modeNie != nil {
		t := *r.modeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nie", t, "form", "multi")
		}
	}
	if r.modeNiew != nil {
		t := *r.modeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__niew", t, "form", "multi")
		}
	}
	if r.modeNisw != nil {
		t := *r.modeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nisw", t, "form", "multi")
		}
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.presharedKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preshared_key", r.presharedKey, "form", "")
	}
	if r.presharedKeyIc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preshared_key__ic", r.presharedKeyIc, "form", "")
	}
	if r.presharedKeyIe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preshared_key__ie", r.presharedKeyIe, "form", "")
	}
	if r.presharedKeyIew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preshared_key__iew", r.presharedKeyIew, "form", "")
	}
	if r.presharedKeyIsw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preshared_key__isw", r.presharedKeyIsw, "form", "")
	}
	if r.presharedKeyN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preshared_key__n", r.presharedKeyN, "form", "")
	}
	if r.presharedKeyNic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preshared_key__nic", r.presharedKeyNic, "form", "")
	}
	if r.presharedKeyNie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preshared_key__nie", r.presharedKeyNie, "form", "")
	}
	if r.presharedKeyNiew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preshared_key__niew", r.presharedKeyNiew, "form", "")
	}
	if r.presharedKeyNisw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preshared_key__nisw", r.presharedKeyNisw, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	if r.version != nil {
		t := *r.version
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version", t, "form", "multi")
		}
	}
	if r.versionIc != nil {
		t := *r.versionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__ic", t, "form", "multi")
		}
	}
	if r.versionIe != nil {
		t := *r.versionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__ie", t, "form", "multi")
		}
	}
	if r.versionIew != nil {
		t := *r.versionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__iew", t, "form", "multi")
		}
	}
	if r.versionIsw != nil {
		t := *r.versionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__isw", t, "form", "multi")
		}
	}
	if r.versionN != nil {
		t := *r.versionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__n", t, "form", "multi")
		}
	}
	if r.versionNic != nil {
		t := *r.versionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__nic", t, "form", "multi")
		}
	}
	if r.versionNie != nil {
		t := *r.versionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__nie", t, "form", "multi")
		}
	}
	if r.versionNiew != nil {
		t := *r.versionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__niew", t, "form", "multi")
		}
	}
	if r.versionNisw != nil {
		t := *r.versionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "version__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "version__nisw", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkePoliciesPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	patchedWritableIKEPolicyRequest *PatchedWritableIKEPolicyRequest
}

func (r ApiVpnIkePoliciesPartialUpdateRequest) PatchedWritableIKEPolicyRequest(patchedWritableIKEPolicyRequest PatchedWritableIKEPolicyRequest) ApiVpnIkePoliciesPartialUpdateRequest {
	r.patchedWritableIKEPolicyRequest = &patchedWritableIKEPolicyRequest
	return r
}

func (r ApiVpnIkePoliciesPartialUpdateRequest) Execute() (*IKEPolicy, *http.Response, error) {
	return r.ApiService.VpnIkePoliciesPartialUpdateExecute(r)
}

/*
VpnIkePoliciesPartialUpdate Method for VpnIkePoliciesPartialUpdate

Patch a IKE policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IKE policy.
 @return ApiVpnIkePoliciesPartialUpdateRequest
*/
func (a *VpnAPIService) VpnIkePoliciesPartialUpdate(ctx context.Context, id int32) ApiVpnIkePoliciesPartialUpdateRequest {
	return ApiVpnIkePoliciesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IKEPolicy
func (a *VpnAPIService) VpnIkePoliciesPartialUpdateExecute(r ApiVpnIkePoliciesPartialUpdateRequest) (*IKEPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IKEPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkePoliciesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableIKEPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkePoliciesRetrieveRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnIkePoliciesRetrieveRequest) Execute() (*IKEPolicy, *http.Response, error) {
	return r.ApiService.VpnIkePoliciesRetrieveExecute(r)
}

/*
VpnIkePoliciesRetrieve Method for VpnIkePoliciesRetrieve

Get a IKE policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IKE policy.
 @return ApiVpnIkePoliciesRetrieveRequest
*/
func (a *VpnAPIService) VpnIkePoliciesRetrieve(ctx context.Context, id int32) ApiVpnIkePoliciesRetrieveRequest {
	return ApiVpnIkePoliciesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IKEPolicy
func (a *VpnAPIService) VpnIkePoliciesRetrieveExecute(r ApiVpnIkePoliciesRetrieveRequest) (*IKEPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IKEPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkePoliciesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkePoliciesUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	writableIKEPolicyRequest *WritableIKEPolicyRequest
}

func (r ApiVpnIkePoliciesUpdateRequest) WritableIKEPolicyRequest(writableIKEPolicyRequest WritableIKEPolicyRequest) ApiVpnIkePoliciesUpdateRequest {
	r.writableIKEPolicyRequest = &writableIKEPolicyRequest
	return r
}

func (r ApiVpnIkePoliciesUpdateRequest) Execute() (*IKEPolicy, *http.Response, error) {
	return r.ApiService.VpnIkePoliciesUpdateExecute(r)
}

/*
VpnIkePoliciesUpdate Method for VpnIkePoliciesUpdate

Put a IKE policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IKE policy.
 @return ApiVpnIkePoliciesUpdateRequest
*/
func (a *VpnAPIService) VpnIkePoliciesUpdate(ctx context.Context, id int32) ApiVpnIkePoliciesUpdateRequest {
	return ApiVpnIkePoliciesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IKEPolicy
func (a *VpnAPIService) VpnIkePoliciesUpdateExecute(r ApiVpnIkePoliciesUpdateRequest) (*IKEPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IKEPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkePoliciesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIKEPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("writableIKEPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIKEPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkeProposalsBulkDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iKEProposalRequest *[]IKEProposalRequest
}

func (r ApiVpnIkeProposalsBulkDestroyRequest) IKEProposalRequest(iKEProposalRequest []IKEProposalRequest) ApiVpnIkeProposalsBulkDestroyRequest {
	r.iKEProposalRequest = &iKEProposalRequest
	return r
}

func (r ApiVpnIkeProposalsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnIkeProposalsBulkDestroyExecute(r)
}

/*
VpnIkeProposalsBulkDestroy Method for VpnIkeProposalsBulkDestroy

Delete a list of IKE proposal objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIkeProposalsBulkDestroyRequest
*/
func (a *VpnAPIService) VpnIkeProposalsBulkDestroy(ctx context.Context) ApiVpnIkeProposalsBulkDestroyRequest {
	return ApiVpnIkeProposalsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnIkeProposalsBulkDestroyExecute(r ApiVpnIkeProposalsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkeProposalsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-proposals/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iKEProposalRequest == nil {
		return nil, reportError("iKEProposalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iKEProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnIkeProposalsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iKEProposalRequest *[]IKEProposalRequest
}

func (r ApiVpnIkeProposalsBulkPartialUpdateRequest) IKEProposalRequest(iKEProposalRequest []IKEProposalRequest) ApiVpnIkeProposalsBulkPartialUpdateRequest {
	r.iKEProposalRequest = &iKEProposalRequest
	return r
}

func (r ApiVpnIkeProposalsBulkPartialUpdateRequest) Execute() ([]IKEProposal, *http.Response, error) {
	return r.ApiService.VpnIkeProposalsBulkPartialUpdateExecute(r)
}

/*
VpnIkeProposalsBulkPartialUpdate Method for VpnIkeProposalsBulkPartialUpdate

Patch a list of IKE proposal objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIkeProposalsBulkPartialUpdateRequest
*/
func (a *VpnAPIService) VpnIkeProposalsBulkPartialUpdate(ctx context.Context) ApiVpnIkeProposalsBulkPartialUpdateRequest {
	return ApiVpnIkeProposalsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IKEProposal
func (a *VpnAPIService) VpnIkeProposalsBulkPartialUpdateExecute(r ApiVpnIkeProposalsBulkPartialUpdateRequest) ([]IKEProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IKEProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkeProposalsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-proposals/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iKEProposalRequest == nil {
		return localVarReturnValue, nil, reportError("iKEProposalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iKEProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkeProposalsBulkUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iKEProposalRequest *[]IKEProposalRequest
}

func (r ApiVpnIkeProposalsBulkUpdateRequest) IKEProposalRequest(iKEProposalRequest []IKEProposalRequest) ApiVpnIkeProposalsBulkUpdateRequest {
	r.iKEProposalRequest = &iKEProposalRequest
	return r
}

func (r ApiVpnIkeProposalsBulkUpdateRequest) Execute() ([]IKEProposal, *http.Response, error) {
	return r.ApiService.VpnIkeProposalsBulkUpdateExecute(r)
}

/*
VpnIkeProposalsBulkUpdate Method for VpnIkeProposalsBulkUpdate

Put a list of IKE proposal objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIkeProposalsBulkUpdateRequest
*/
func (a *VpnAPIService) VpnIkeProposalsBulkUpdate(ctx context.Context) ApiVpnIkeProposalsBulkUpdateRequest {
	return ApiVpnIkeProposalsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IKEProposal
func (a *VpnAPIService) VpnIkeProposalsBulkUpdateExecute(r ApiVpnIkeProposalsBulkUpdateRequest) ([]IKEProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IKEProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkeProposalsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-proposals/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iKEProposalRequest == nil {
		return localVarReturnValue, nil, reportError("iKEProposalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iKEProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkeProposalsCreateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	writableIKEProposalRequest *WritableIKEProposalRequest
}

func (r ApiVpnIkeProposalsCreateRequest) WritableIKEProposalRequest(writableIKEProposalRequest WritableIKEProposalRequest) ApiVpnIkeProposalsCreateRequest {
	r.writableIKEProposalRequest = &writableIKEProposalRequest
	return r
}

func (r ApiVpnIkeProposalsCreateRequest) Execute() (*IKEProposal, *http.Response, error) {
	return r.ApiService.VpnIkeProposalsCreateExecute(r)
}

/*
VpnIkeProposalsCreate Method for VpnIkeProposalsCreate

Post a list of IKE proposal objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIkeProposalsCreateRequest
*/
func (a *VpnAPIService) VpnIkeProposalsCreate(ctx context.Context) ApiVpnIkeProposalsCreateRequest {
	return ApiVpnIkeProposalsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IKEProposal
func (a *VpnAPIService) VpnIkeProposalsCreateExecute(r ApiVpnIkeProposalsCreateRequest) (*IKEProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IKEProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkeProposalsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-proposals/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIKEProposalRequest == nil {
		return localVarReturnValue, nil, reportError("writableIKEProposalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIKEProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkeProposalsDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnIkeProposalsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnIkeProposalsDestroyExecute(r)
}

/*
VpnIkeProposalsDestroy Method for VpnIkeProposalsDestroy

Delete a IKE proposal object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IKE proposal.
 @return ApiVpnIkeProposalsDestroyRequest
*/
func (a *VpnAPIService) VpnIkeProposalsDestroy(ctx context.Context, id int32) ApiVpnIkeProposalsDestroyRequest {
	return ApiVpnIkeProposalsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnIkeProposalsDestroyExecute(r ApiVpnIkeProposalsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkeProposalsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-proposals/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnIkeProposalsListRequest struct {
	ctx context.Context
	ApiService VpnAPI
	authenticationAlgorithm *[]*string
	authenticationAlgorithmEmpty *bool
	authenticationAlgorithmIc *[]*string
	authenticationAlgorithmIe *[]*string
	authenticationAlgorithmIew *[]*string
	authenticationAlgorithmIsw *[]*string
	authenticationAlgorithmN *[]*string
	authenticationAlgorithmNic *[]*string
	authenticationAlgorithmNie *[]*string
	authenticationAlgorithmNiew *[]*string
	authenticationAlgorithmNisw *[]*string
	authenticationMethod *[]string
	authenticationMethodEmpty *bool
	authenticationMethodIc *[]string
	authenticationMethodIe *[]string
	authenticationMethodIew *[]string
	authenticationMethodIsw *[]string
	authenticationMethodN *[]string
	authenticationMethodNic *[]string
	authenticationMethodNie *[]string
	authenticationMethodNiew *[]string
	authenticationMethodNisw *[]string
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	encryptionAlgorithm *[]string
	encryptionAlgorithmEmpty *bool
	encryptionAlgorithmIc *[]string
	encryptionAlgorithmIe *[]string
	encryptionAlgorithmIew *[]string
	encryptionAlgorithmIsw *[]string
	encryptionAlgorithmN *[]string
	encryptionAlgorithmNic *[]string
	encryptionAlgorithmNie *[]string
	encryptionAlgorithmNiew *[]string
	encryptionAlgorithmNisw *[]string
	group *[]int32
	groupIc *[]int32
	groupIe *[]int32
	groupIew *[]int32
	groupIsw *[]int32
	groupN *[]int32
	groupNic *[]int32
	groupNie *[]int32
	groupNiew *[]int32
	groupNisw *[]int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	ikePolicy *[]string
	ikePolicyN *[]string
	ikePolicyId *[]int32
	ikePolicyIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	saLifetime *[]int32
	saLifetimeEmpty *bool
	saLifetimeGt *[]int32
	saLifetimeGte *[]int32
	saLifetimeLt *[]int32
	saLifetimeLte *[]int32
	saLifetimeN *[]int32
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationAlgorithm(authenticationAlgorithm []*string) ApiVpnIkeProposalsListRequest {
	r.authenticationAlgorithm = &authenticationAlgorithm
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationAlgorithmEmpty(authenticationAlgorithmEmpty bool) ApiVpnIkeProposalsListRequest {
	r.authenticationAlgorithmEmpty = &authenticationAlgorithmEmpty
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationAlgorithmIc(authenticationAlgorithmIc []*string) ApiVpnIkeProposalsListRequest {
	r.authenticationAlgorithmIc = &authenticationAlgorithmIc
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationAlgorithmIe(authenticationAlgorithmIe []*string) ApiVpnIkeProposalsListRequest {
	r.authenticationAlgorithmIe = &authenticationAlgorithmIe
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationAlgorithmIew(authenticationAlgorithmIew []*string) ApiVpnIkeProposalsListRequest {
	r.authenticationAlgorithmIew = &authenticationAlgorithmIew
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationAlgorithmIsw(authenticationAlgorithmIsw []*string) ApiVpnIkeProposalsListRequest {
	r.authenticationAlgorithmIsw = &authenticationAlgorithmIsw
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationAlgorithmN(authenticationAlgorithmN []*string) ApiVpnIkeProposalsListRequest {
	r.authenticationAlgorithmN = &authenticationAlgorithmN
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationAlgorithmNic(authenticationAlgorithmNic []*string) ApiVpnIkeProposalsListRequest {
	r.authenticationAlgorithmNic = &authenticationAlgorithmNic
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationAlgorithmNie(authenticationAlgorithmNie []*string) ApiVpnIkeProposalsListRequest {
	r.authenticationAlgorithmNie = &authenticationAlgorithmNie
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationAlgorithmNiew(authenticationAlgorithmNiew []*string) ApiVpnIkeProposalsListRequest {
	r.authenticationAlgorithmNiew = &authenticationAlgorithmNiew
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationAlgorithmNisw(authenticationAlgorithmNisw []*string) ApiVpnIkeProposalsListRequest {
	r.authenticationAlgorithmNisw = &authenticationAlgorithmNisw
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationMethod(authenticationMethod []string) ApiVpnIkeProposalsListRequest {
	r.authenticationMethod = &authenticationMethod
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationMethodEmpty(authenticationMethodEmpty bool) ApiVpnIkeProposalsListRequest {
	r.authenticationMethodEmpty = &authenticationMethodEmpty
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationMethodIc(authenticationMethodIc []string) ApiVpnIkeProposalsListRequest {
	r.authenticationMethodIc = &authenticationMethodIc
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationMethodIe(authenticationMethodIe []string) ApiVpnIkeProposalsListRequest {
	r.authenticationMethodIe = &authenticationMethodIe
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationMethodIew(authenticationMethodIew []string) ApiVpnIkeProposalsListRequest {
	r.authenticationMethodIew = &authenticationMethodIew
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationMethodIsw(authenticationMethodIsw []string) ApiVpnIkeProposalsListRequest {
	r.authenticationMethodIsw = &authenticationMethodIsw
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationMethodN(authenticationMethodN []string) ApiVpnIkeProposalsListRequest {
	r.authenticationMethodN = &authenticationMethodN
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationMethodNic(authenticationMethodNic []string) ApiVpnIkeProposalsListRequest {
	r.authenticationMethodNic = &authenticationMethodNic
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationMethodNie(authenticationMethodNie []string) ApiVpnIkeProposalsListRequest {
	r.authenticationMethodNie = &authenticationMethodNie
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationMethodNiew(authenticationMethodNiew []string) ApiVpnIkeProposalsListRequest {
	r.authenticationMethodNiew = &authenticationMethodNiew
	return r
}

func (r ApiVpnIkeProposalsListRequest) AuthenticationMethodNisw(authenticationMethodNisw []string) ApiVpnIkeProposalsListRequest {
	r.authenticationMethodNisw = &authenticationMethodNisw
	return r
}

func (r ApiVpnIkeProposalsListRequest) Created(created []time.Time) ApiVpnIkeProposalsListRequest {
	r.created = &created
	return r
}

func (r ApiVpnIkeProposalsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiVpnIkeProposalsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiVpnIkeProposalsListRequest) CreatedGt(createdGt []time.Time) ApiVpnIkeProposalsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiVpnIkeProposalsListRequest) CreatedGte(createdGte []time.Time) ApiVpnIkeProposalsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVpnIkeProposalsListRequest) CreatedLt(createdLt []time.Time) ApiVpnIkeProposalsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiVpnIkeProposalsListRequest) CreatedLte(createdLte []time.Time) ApiVpnIkeProposalsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVpnIkeProposalsListRequest) CreatedN(createdN []time.Time) ApiVpnIkeProposalsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiVpnIkeProposalsListRequest) CreatedByRequest(createdByRequest string) ApiVpnIkeProposalsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiVpnIkeProposalsListRequest) Description(description []string) ApiVpnIkeProposalsListRequest {
	r.description = &description
	return r
}

func (r ApiVpnIkeProposalsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiVpnIkeProposalsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiVpnIkeProposalsListRequest) DescriptionIc(descriptionIc []string) ApiVpnIkeProposalsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiVpnIkeProposalsListRequest) DescriptionIe(descriptionIe []string) ApiVpnIkeProposalsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiVpnIkeProposalsListRequest) DescriptionIew(descriptionIew []string) ApiVpnIkeProposalsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiVpnIkeProposalsListRequest) DescriptionIsw(descriptionIsw []string) ApiVpnIkeProposalsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiVpnIkeProposalsListRequest) DescriptionN(descriptionN []string) ApiVpnIkeProposalsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiVpnIkeProposalsListRequest) DescriptionNic(descriptionNic []string) ApiVpnIkeProposalsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiVpnIkeProposalsListRequest) DescriptionNie(descriptionNie []string) ApiVpnIkeProposalsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiVpnIkeProposalsListRequest) DescriptionNiew(descriptionNiew []string) ApiVpnIkeProposalsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiVpnIkeProposalsListRequest) DescriptionNisw(descriptionNisw []string) ApiVpnIkeProposalsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiVpnIkeProposalsListRequest) EncryptionAlgorithm(encryptionAlgorithm []string) ApiVpnIkeProposalsListRequest {
	r.encryptionAlgorithm = &encryptionAlgorithm
	return r
}

func (r ApiVpnIkeProposalsListRequest) EncryptionAlgorithmEmpty(encryptionAlgorithmEmpty bool) ApiVpnIkeProposalsListRequest {
	r.encryptionAlgorithmEmpty = &encryptionAlgorithmEmpty
	return r
}

func (r ApiVpnIkeProposalsListRequest) EncryptionAlgorithmIc(encryptionAlgorithmIc []string) ApiVpnIkeProposalsListRequest {
	r.encryptionAlgorithmIc = &encryptionAlgorithmIc
	return r
}

func (r ApiVpnIkeProposalsListRequest) EncryptionAlgorithmIe(encryptionAlgorithmIe []string) ApiVpnIkeProposalsListRequest {
	r.encryptionAlgorithmIe = &encryptionAlgorithmIe
	return r
}

func (r ApiVpnIkeProposalsListRequest) EncryptionAlgorithmIew(encryptionAlgorithmIew []string) ApiVpnIkeProposalsListRequest {
	r.encryptionAlgorithmIew = &encryptionAlgorithmIew
	return r
}

func (r ApiVpnIkeProposalsListRequest) EncryptionAlgorithmIsw(encryptionAlgorithmIsw []string) ApiVpnIkeProposalsListRequest {
	r.encryptionAlgorithmIsw = &encryptionAlgorithmIsw
	return r
}

func (r ApiVpnIkeProposalsListRequest) EncryptionAlgorithmN(encryptionAlgorithmN []string) ApiVpnIkeProposalsListRequest {
	r.encryptionAlgorithmN = &encryptionAlgorithmN
	return r
}

func (r ApiVpnIkeProposalsListRequest) EncryptionAlgorithmNic(encryptionAlgorithmNic []string) ApiVpnIkeProposalsListRequest {
	r.encryptionAlgorithmNic = &encryptionAlgorithmNic
	return r
}

func (r ApiVpnIkeProposalsListRequest) EncryptionAlgorithmNie(encryptionAlgorithmNie []string) ApiVpnIkeProposalsListRequest {
	r.encryptionAlgorithmNie = &encryptionAlgorithmNie
	return r
}

func (r ApiVpnIkeProposalsListRequest) EncryptionAlgorithmNiew(encryptionAlgorithmNiew []string) ApiVpnIkeProposalsListRequest {
	r.encryptionAlgorithmNiew = &encryptionAlgorithmNiew
	return r
}

func (r ApiVpnIkeProposalsListRequest) EncryptionAlgorithmNisw(encryptionAlgorithmNisw []string) ApiVpnIkeProposalsListRequest {
	r.encryptionAlgorithmNisw = &encryptionAlgorithmNisw
	return r
}

// Diffie-Hellman group ID
func (r ApiVpnIkeProposalsListRequest) Group(group []int32) ApiVpnIkeProposalsListRequest {
	r.group = &group
	return r
}

// Diffie-Hellman group ID
func (r ApiVpnIkeProposalsListRequest) GroupIc(groupIc []int32) ApiVpnIkeProposalsListRequest {
	r.groupIc = &groupIc
	return r
}

// Diffie-Hellman group ID
func (r ApiVpnIkeProposalsListRequest) GroupIe(groupIe []int32) ApiVpnIkeProposalsListRequest {
	r.groupIe = &groupIe
	return r
}

// Diffie-Hellman group ID
func (r ApiVpnIkeProposalsListRequest) GroupIew(groupIew []int32) ApiVpnIkeProposalsListRequest {
	r.groupIew = &groupIew
	return r
}

// Diffie-Hellman group ID
func (r ApiVpnIkeProposalsListRequest) GroupIsw(groupIsw []int32) ApiVpnIkeProposalsListRequest {
	r.groupIsw = &groupIsw
	return r
}

// Diffie-Hellman group ID
func (r ApiVpnIkeProposalsListRequest) GroupN(groupN []int32) ApiVpnIkeProposalsListRequest {
	r.groupN = &groupN
	return r
}

// Diffie-Hellman group ID
func (r ApiVpnIkeProposalsListRequest) GroupNic(groupNic []int32) ApiVpnIkeProposalsListRequest {
	r.groupNic = &groupNic
	return r
}

// Diffie-Hellman group ID
func (r ApiVpnIkeProposalsListRequest) GroupNie(groupNie []int32) ApiVpnIkeProposalsListRequest {
	r.groupNie = &groupNie
	return r
}

// Diffie-Hellman group ID
func (r ApiVpnIkeProposalsListRequest) GroupNiew(groupNiew []int32) ApiVpnIkeProposalsListRequest {
	r.groupNiew = &groupNiew
	return r
}

// Diffie-Hellman group ID
func (r ApiVpnIkeProposalsListRequest) GroupNisw(groupNisw []int32) ApiVpnIkeProposalsListRequest {
	r.groupNisw = &groupNisw
	return r
}

func (r ApiVpnIkeProposalsListRequest) Id(id []int32) ApiVpnIkeProposalsListRequest {
	r.id = &id
	return r
}

func (r ApiVpnIkeProposalsListRequest) IdEmpty(idEmpty bool) ApiVpnIkeProposalsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiVpnIkeProposalsListRequest) IdGt(idGt []int32) ApiVpnIkeProposalsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVpnIkeProposalsListRequest) IdGte(idGte []int32) ApiVpnIkeProposalsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVpnIkeProposalsListRequest) IdLt(idLt []int32) ApiVpnIkeProposalsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVpnIkeProposalsListRequest) IdLte(idLte []int32) ApiVpnIkeProposalsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVpnIkeProposalsListRequest) IdN(idN []int32) ApiVpnIkeProposalsListRequest {
	r.idN = &idN
	return r
}

// IKE policy (name)
func (r ApiVpnIkeProposalsListRequest) IkePolicy(ikePolicy []string) ApiVpnIkeProposalsListRequest {
	r.ikePolicy = &ikePolicy
	return r
}

// IKE policy (name)
func (r ApiVpnIkeProposalsListRequest) IkePolicyN(ikePolicyN []string) ApiVpnIkeProposalsListRequest {
	r.ikePolicyN = &ikePolicyN
	return r
}

// IKE policy (ID)
func (r ApiVpnIkeProposalsListRequest) IkePolicyId(ikePolicyId []int32) ApiVpnIkeProposalsListRequest {
	r.ikePolicyId = &ikePolicyId
	return r
}

// IKE policy (ID)
func (r ApiVpnIkeProposalsListRequest) IkePolicyIdN(ikePolicyIdN []int32) ApiVpnIkeProposalsListRequest {
	r.ikePolicyIdN = &ikePolicyIdN
	return r
}

func (r ApiVpnIkeProposalsListRequest) LastUpdated(lastUpdated []time.Time) ApiVpnIkeProposalsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVpnIkeProposalsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiVpnIkeProposalsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiVpnIkeProposalsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiVpnIkeProposalsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiVpnIkeProposalsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiVpnIkeProposalsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVpnIkeProposalsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiVpnIkeProposalsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiVpnIkeProposalsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiVpnIkeProposalsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVpnIkeProposalsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiVpnIkeProposalsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiVpnIkeProposalsListRequest) Limit(limit int32) ApiVpnIkeProposalsListRequest {
	r.limit = &limit
	return r
}

func (r ApiVpnIkeProposalsListRequest) ModifiedByRequest(modifiedByRequest string) ApiVpnIkeProposalsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiVpnIkeProposalsListRequest) Name(name []string) ApiVpnIkeProposalsListRequest {
	r.name = &name
	return r
}

func (r ApiVpnIkeProposalsListRequest) NameEmpty(nameEmpty bool) ApiVpnIkeProposalsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVpnIkeProposalsListRequest) NameIc(nameIc []string) ApiVpnIkeProposalsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVpnIkeProposalsListRequest) NameIe(nameIe []string) ApiVpnIkeProposalsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVpnIkeProposalsListRequest) NameIew(nameIew []string) ApiVpnIkeProposalsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVpnIkeProposalsListRequest) NameIsw(nameIsw []string) ApiVpnIkeProposalsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVpnIkeProposalsListRequest) NameN(nameN []string) ApiVpnIkeProposalsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVpnIkeProposalsListRequest) NameNic(nameNic []string) ApiVpnIkeProposalsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVpnIkeProposalsListRequest) NameNie(nameNie []string) ApiVpnIkeProposalsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVpnIkeProposalsListRequest) NameNiew(nameNiew []string) ApiVpnIkeProposalsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVpnIkeProposalsListRequest) NameNisw(nameNisw []string) ApiVpnIkeProposalsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiVpnIkeProposalsListRequest) Offset(offset int32) ApiVpnIkeProposalsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiVpnIkeProposalsListRequest) Ordering(ordering string) ApiVpnIkeProposalsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiVpnIkeProposalsListRequest) Q(q string) ApiVpnIkeProposalsListRequest {
	r.q = &q
	return r
}

func (r ApiVpnIkeProposalsListRequest) SaLifetime(saLifetime []int32) ApiVpnIkeProposalsListRequest {
	r.saLifetime = &saLifetime
	return r
}

func (r ApiVpnIkeProposalsListRequest) SaLifetimeEmpty(saLifetimeEmpty bool) ApiVpnIkeProposalsListRequest {
	r.saLifetimeEmpty = &saLifetimeEmpty
	return r
}

func (r ApiVpnIkeProposalsListRequest) SaLifetimeGt(saLifetimeGt []int32) ApiVpnIkeProposalsListRequest {
	r.saLifetimeGt = &saLifetimeGt
	return r
}

func (r ApiVpnIkeProposalsListRequest) SaLifetimeGte(saLifetimeGte []int32) ApiVpnIkeProposalsListRequest {
	r.saLifetimeGte = &saLifetimeGte
	return r
}

func (r ApiVpnIkeProposalsListRequest) SaLifetimeLt(saLifetimeLt []int32) ApiVpnIkeProposalsListRequest {
	r.saLifetimeLt = &saLifetimeLt
	return r
}

func (r ApiVpnIkeProposalsListRequest) SaLifetimeLte(saLifetimeLte []int32) ApiVpnIkeProposalsListRequest {
	r.saLifetimeLte = &saLifetimeLte
	return r
}

func (r ApiVpnIkeProposalsListRequest) SaLifetimeN(saLifetimeN []int32) ApiVpnIkeProposalsListRequest {
	r.saLifetimeN = &saLifetimeN
	return r
}

func (r ApiVpnIkeProposalsListRequest) Tag(tag []string) ApiVpnIkeProposalsListRequest {
	r.tag = &tag
	return r
}

func (r ApiVpnIkeProposalsListRequest) TagN(tagN []string) ApiVpnIkeProposalsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiVpnIkeProposalsListRequest) UpdatedByRequest(updatedByRequest string) ApiVpnIkeProposalsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiVpnIkeProposalsListRequest) Execute() (*PaginatedIKEProposalList, *http.Response, error) {
	return r.ApiService.VpnIkeProposalsListExecute(r)
}

/*
VpnIkeProposalsList Method for VpnIkeProposalsList

Get a list of IKE proposal objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIkeProposalsListRequest
*/
func (a *VpnAPIService) VpnIkeProposalsList(ctx context.Context) ApiVpnIkeProposalsListRequest {
	return ApiVpnIkeProposalsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIKEProposalList
func (a *VpnAPIService) VpnIkeProposalsListExecute(r ApiVpnIkeProposalsListRequest) (*PaginatedIKEProposalList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIKEProposalList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkeProposalsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-proposals/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.authenticationAlgorithm != nil {
		t := *r.authenticationAlgorithm
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__empty", r.authenticationAlgorithmEmpty, "form", "")
	}
	if r.authenticationAlgorithmIc != nil {
		t := *r.authenticationAlgorithmIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__ic", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmIe != nil {
		t := *r.authenticationAlgorithmIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__ie", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmIew != nil {
		t := *r.authenticationAlgorithmIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__iew", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmIsw != nil {
		t := *r.authenticationAlgorithmIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__isw", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmN != nil {
		t := *r.authenticationAlgorithmN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__n", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmNic != nil {
		t := *r.authenticationAlgorithmNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nic", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmNie != nil {
		t := *r.authenticationAlgorithmNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nie", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmNiew != nil {
		t := *r.authenticationAlgorithmNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__niew", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmNisw != nil {
		t := *r.authenticationAlgorithmNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nisw", t, "form", "multi")
		}
	}
	if r.authenticationMethod != nil {
		t := *r.authenticationMethod
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method", t, "form", "multi")
		}
	}
	if r.authenticationMethodEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__empty", r.authenticationMethodEmpty, "form", "")
	}
	if r.authenticationMethodIc != nil {
		t := *r.authenticationMethodIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__ic", t, "form", "multi")
		}
	}
	if r.authenticationMethodIe != nil {
		t := *r.authenticationMethodIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__ie", t, "form", "multi")
		}
	}
	if r.authenticationMethodIew != nil {
		t := *r.authenticationMethodIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__iew", t, "form", "multi")
		}
	}
	if r.authenticationMethodIsw != nil {
		t := *r.authenticationMethodIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__isw", t, "form", "multi")
		}
	}
	if r.authenticationMethodN != nil {
		t := *r.authenticationMethodN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__n", t, "form", "multi")
		}
	}
	if r.authenticationMethodNic != nil {
		t := *r.authenticationMethodNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__nic", t, "form", "multi")
		}
	}
	if r.authenticationMethodNie != nil {
		t := *r.authenticationMethodNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__nie", t, "form", "multi")
		}
	}
	if r.authenticationMethodNiew != nil {
		t := *r.authenticationMethodNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__niew", t, "form", "multi")
		}
	}
	if r.authenticationMethodNisw != nil {
		t := *r.authenticationMethodNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_method__nisw", t, "form", "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithm != nil {
		t := *r.encryptionAlgorithm
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__empty", r.encryptionAlgorithmEmpty, "form", "")
	}
	if r.encryptionAlgorithmIc != nil {
		t := *r.encryptionAlgorithmIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__ic", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmIe != nil {
		t := *r.encryptionAlgorithmIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__ie", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmIew != nil {
		t := *r.encryptionAlgorithmIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__iew", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmIsw != nil {
		t := *r.encryptionAlgorithmIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__isw", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmN != nil {
		t := *r.encryptionAlgorithmN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__n", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmNic != nil {
		t := *r.encryptionAlgorithmNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nic", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmNie != nil {
		t := *r.encryptionAlgorithmNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nie", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmNiew != nil {
		t := *r.encryptionAlgorithmNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__niew", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmNisw != nil {
		t := *r.encryptionAlgorithmNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nisw", t, "form", "multi")
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group", t, "form", "multi")
		}
	}
	if r.groupIc != nil {
		t := *r.groupIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__ic", t, "form", "multi")
		}
	}
	if r.groupIe != nil {
		t := *r.groupIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__ie", t, "form", "multi")
		}
	}
	if r.groupIew != nil {
		t := *r.groupIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__iew", t, "form", "multi")
		}
	}
	if r.groupIsw != nil {
		t := *r.groupIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__isw", t, "form", "multi")
		}
	}
	if r.groupN != nil {
		t := *r.groupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", t, "form", "multi")
		}
	}
	if r.groupNic != nil {
		t := *r.groupNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__nic", t, "form", "multi")
		}
	}
	if r.groupNie != nil {
		t := *r.groupNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__nie", t, "form", "multi")
		}
	}
	if r.groupNiew != nil {
		t := *r.groupNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__niew", t, "form", "multi")
		}
	}
	if r.groupNisw != nil {
		t := *r.groupNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.ikePolicy != nil {
		t := *r.ikePolicy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy", t, "form", "multi")
		}
	}
	if r.ikePolicyN != nil {
		t := *r.ikePolicyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy__n", t, "form", "multi")
		}
	}
	if r.ikePolicyId != nil {
		t := *r.ikePolicyId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy_id", t, "form", "multi")
		}
	}
	if r.ikePolicyIdN != nil {
		t := *r.ikePolicyIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.saLifetime != nil {
		t := *r.saLifetime
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime", t, "form", "multi")
		}
	}
	if r.saLifetimeEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime__empty", r.saLifetimeEmpty, "form", "")
	}
	if r.saLifetimeGt != nil {
		t := *r.saLifetimeGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime__gt", t, "form", "multi")
		}
	}
	if r.saLifetimeGte != nil {
		t := *r.saLifetimeGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime__gte", t, "form", "multi")
		}
	}
	if r.saLifetimeLt != nil {
		t := *r.saLifetimeLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime__lt", t, "form", "multi")
		}
	}
	if r.saLifetimeLte != nil {
		t := *r.saLifetimeLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime__lte", t, "form", "multi")
		}
	}
	if r.saLifetimeN != nil {
		t := *r.saLifetimeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime__n", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkeProposalsPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	patchedWritableIKEProposalRequest *PatchedWritableIKEProposalRequest
}

func (r ApiVpnIkeProposalsPartialUpdateRequest) PatchedWritableIKEProposalRequest(patchedWritableIKEProposalRequest PatchedWritableIKEProposalRequest) ApiVpnIkeProposalsPartialUpdateRequest {
	r.patchedWritableIKEProposalRequest = &patchedWritableIKEProposalRequest
	return r
}

func (r ApiVpnIkeProposalsPartialUpdateRequest) Execute() (*IKEProposal, *http.Response, error) {
	return r.ApiService.VpnIkeProposalsPartialUpdateExecute(r)
}

/*
VpnIkeProposalsPartialUpdate Method for VpnIkeProposalsPartialUpdate

Patch a IKE proposal object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IKE proposal.
 @return ApiVpnIkeProposalsPartialUpdateRequest
*/
func (a *VpnAPIService) VpnIkeProposalsPartialUpdate(ctx context.Context, id int32) ApiVpnIkeProposalsPartialUpdateRequest {
	return ApiVpnIkeProposalsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IKEProposal
func (a *VpnAPIService) VpnIkeProposalsPartialUpdateExecute(r ApiVpnIkeProposalsPartialUpdateRequest) (*IKEProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IKEProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkeProposalsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-proposals/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableIKEProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkeProposalsRetrieveRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnIkeProposalsRetrieveRequest) Execute() (*IKEProposal, *http.Response, error) {
	return r.ApiService.VpnIkeProposalsRetrieveExecute(r)
}

/*
VpnIkeProposalsRetrieve Method for VpnIkeProposalsRetrieve

Get a IKE proposal object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IKE proposal.
 @return ApiVpnIkeProposalsRetrieveRequest
*/
func (a *VpnAPIService) VpnIkeProposalsRetrieve(ctx context.Context, id int32) ApiVpnIkeProposalsRetrieveRequest {
	return ApiVpnIkeProposalsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IKEProposal
func (a *VpnAPIService) VpnIkeProposalsRetrieveExecute(r ApiVpnIkeProposalsRetrieveRequest) (*IKEProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IKEProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkeProposalsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-proposals/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIkeProposalsUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	writableIKEProposalRequest *WritableIKEProposalRequest
}

func (r ApiVpnIkeProposalsUpdateRequest) WritableIKEProposalRequest(writableIKEProposalRequest WritableIKEProposalRequest) ApiVpnIkeProposalsUpdateRequest {
	r.writableIKEProposalRequest = &writableIKEProposalRequest
	return r
}

func (r ApiVpnIkeProposalsUpdateRequest) Execute() (*IKEProposal, *http.Response, error) {
	return r.ApiService.VpnIkeProposalsUpdateExecute(r)
}

/*
VpnIkeProposalsUpdate Method for VpnIkeProposalsUpdate

Put a IKE proposal object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IKE proposal.
 @return ApiVpnIkeProposalsUpdateRequest
*/
func (a *VpnAPIService) VpnIkeProposalsUpdate(ctx context.Context, id int32) ApiVpnIkeProposalsUpdateRequest {
	return ApiVpnIkeProposalsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IKEProposal
func (a *VpnAPIService) VpnIkeProposalsUpdateExecute(r ApiVpnIkeProposalsUpdateRequest) (*IKEProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IKEProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIkeProposalsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ike-proposals/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIKEProposalRequest == nil {
		return localVarReturnValue, nil, reportError("writableIKEProposalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIKEProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecPoliciesBulkDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iPSecPolicyRequest *[]IPSecPolicyRequest
}

func (r ApiVpnIpsecPoliciesBulkDestroyRequest) IPSecPolicyRequest(iPSecPolicyRequest []IPSecPolicyRequest) ApiVpnIpsecPoliciesBulkDestroyRequest {
	r.iPSecPolicyRequest = &iPSecPolicyRequest
	return r
}

func (r ApiVpnIpsecPoliciesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnIpsecPoliciesBulkDestroyExecute(r)
}

/*
VpnIpsecPoliciesBulkDestroy Method for VpnIpsecPoliciesBulkDestroy

Delete a list of IPSec policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecPoliciesBulkDestroyRequest
*/
func (a *VpnAPIService) VpnIpsecPoliciesBulkDestroy(ctx context.Context) ApiVpnIpsecPoliciesBulkDestroyRequest {
	return ApiVpnIpsecPoliciesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnIpsecPoliciesBulkDestroyExecute(r ApiVpnIpsecPoliciesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecPoliciesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPSecPolicyRequest == nil {
		return nil, reportError("iPSecPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPSecPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnIpsecPoliciesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iPSecPolicyRequest *[]IPSecPolicyRequest
}

func (r ApiVpnIpsecPoliciesBulkPartialUpdateRequest) IPSecPolicyRequest(iPSecPolicyRequest []IPSecPolicyRequest) ApiVpnIpsecPoliciesBulkPartialUpdateRequest {
	r.iPSecPolicyRequest = &iPSecPolicyRequest
	return r
}

func (r ApiVpnIpsecPoliciesBulkPartialUpdateRequest) Execute() ([]IPSecPolicy, *http.Response, error) {
	return r.ApiService.VpnIpsecPoliciesBulkPartialUpdateExecute(r)
}

/*
VpnIpsecPoliciesBulkPartialUpdate Method for VpnIpsecPoliciesBulkPartialUpdate

Patch a list of IPSec policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecPoliciesBulkPartialUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecPoliciesBulkPartialUpdate(ctx context.Context) ApiVpnIpsecPoliciesBulkPartialUpdateRequest {
	return ApiVpnIpsecPoliciesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPSecPolicy
func (a *VpnAPIService) VpnIpsecPoliciesBulkPartialUpdateExecute(r ApiVpnIpsecPoliciesBulkPartialUpdateRequest) ([]IPSecPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPSecPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecPoliciesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPSecPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("iPSecPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPSecPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecPoliciesBulkUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iPSecPolicyRequest *[]IPSecPolicyRequest
}

func (r ApiVpnIpsecPoliciesBulkUpdateRequest) IPSecPolicyRequest(iPSecPolicyRequest []IPSecPolicyRequest) ApiVpnIpsecPoliciesBulkUpdateRequest {
	r.iPSecPolicyRequest = &iPSecPolicyRequest
	return r
}

func (r ApiVpnIpsecPoliciesBulkUpdateRequest) Execute() ([]IPSecPolicy, *http.Response, error) {
	return r.ApiService.VpnIpsecPoliciesBulkUpdateExecute(r)
}

/*
VpnIpsecPoliciesBulkUpdate Method for VpnIpsecPoliciesBulkUpdate

Put a list of IPSec policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecPoliciesBulkUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecPoliciesBulkUpdate(ctx context.Context) ApiVpnIpsecPoliciesBulkUpdateRequest {
	return ApiVpnIpsecPoliciesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPSecPolicy
func (a *VpnAPIService) VpnIpsecPoliciesBulkUpdateExecute(r ApiVpnIpsecPoliciesBulkUpdateRequest) ([]IPSecPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPSecPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecPoliciesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPSecPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("iPSecPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPSecPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecPoliciesCreateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	writableIPSecPolicyRequest *WritableIPSecPolicyRequest
}

func (r ApiVpnIpsecPoliciesCreateRequest) WritableIPSecPolicyRequest(writableIPSecPolicyRequest WritableIPSecPolicyRequest) ApiVpnIpsecPoliciesCreateRequest {
	r.writableIPSecPolicyRequest = &writableIPSecPolicyRequest
	return r
}

func (r ApiVpnIpsecPoliciesCreateRequest) Execute() (*IPSecPolicy, *http.Response, error) {
	return r.ApiService.VpnIpsecPoliciesCreateExecute(r)
}

/*
VpnIpsecPoliciesCreate Method for VpnIpsecPoliciesCreate

Post a list of IPSec policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecPoliciesCreateRequest
*/
func (a *VpnAPIService) VpnIpsecPoliciesCreate(ctx context.Context) ApiVpnIpsecPoliciesCreateRequest {
	return ApiVpnIpsecPoliciesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPSecPolicy
func (a *VpnAPIService) VpnIpsecPoliciesCreateExecute(r ApiVpnIpsecPoliciesCreateRequest) (*IPSecPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecPoliciesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPSecPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPSecPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPSecPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecPoliciesDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnIpsecPoliciesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnIpsecPoliciesDestroyExecute(r)
}

/*
VpnIpsecPoliciesDestroy Method for VpnIpsecPoliciesDestroy

Delete a IPSec policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec policy.
 @return ApiVpnIpsecPoliciesDestroyRequest
*/
func (a *VpnAPIService) VpnIpsecPoliciesDestroy(ctx context.Context, id int32) ApiVpnIpsecPoliciesDestroyRequest {
	return ApiVpnIpsecPoliciesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnIpsecPoliciesDestroyExecute(r ApiVpnIpsecPoliciesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecPoliciesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnIpsecPoliciesListRequest struct {
	ctx context.Context
	ApiService VpnAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	ipsecProposal *[]string
	ipsecProposalN *[]string
	ipsecProposalId *[]int32
	ipsecProposalIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	pfsGroup *[]*int32
	pfsGroupIc *[]*int32
	pfsGroupIe *[]*int32
	pfsGroupIew *[]*int32
	pfsGroupIsw *[]*int32
	pfsGroupN *[]*int32
	pfsGroupNic *[]*int32
	pfsGroupNie *[]*int32
	pfsGroupNiew *[]*int32
	pfsGroupNisw *[]*int32
	q *string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiVpnIpsecPoliciesListRequest) Created(created []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.created = &created
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) CreatedGt(createdGt []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) CreatedGte(createdGte []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) CreatedLt(createdLt []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) CreatedLte(createdLte []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) CreatedN(createdN []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) CreatedByRequest(createdByRequest string) ApiVpnIpsecPoliciesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) Description(description []string) ApiVpnIpsecPoliciesListRequest {
	r.description = &description
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiVpnIpsecPoliciesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) DescriptionIc(descriptionIc []string) ApiVpnIpsecPoliciesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) DescriptionIe(descriptionIe []string) ApiVpnIpsecPoliciesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) DescriptionIew(descriptionIew []string) ApiVpnIpsecPoliciesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) DescriptionIsw(descriptionIsw []string) ApiVpnIpsecPoliciesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) DescriptionN(descriptionN []string) ApiVpnIpsecPoliciesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) DescriptionNic(descriptionNic []string) ApiVpnIpsecPoliciesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) DescriptionNie(descriptionNie []string) ApiVpnIpsecPoliciesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) DescriptionNiew(descriptionNiew []string) ApiVpnIpsecPoliciesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) DescriptionNisw(descriptionNisw []string) ApiVpnIpsecPoliciesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) Id(id []int32) ApiVpnIpsecPoliciesListRequest {
	r.id = &id
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) IdEmpty(idEmpty bool) ApiVpnIpsecPoliciesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) IdGt(idGt []int32) ApiVpnIpsecPoliciesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) IdGte(idGte []int32) ApiVpnIpsecPoliciesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) IdLt(idLt []int32) ApiVpnIpsecPoliciesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) IdLte(idLte []int32) ApiVpnIpsecPoliciesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) IdN(idN []int32) ApiVpnIpsecPoliciesListRequest {
	r.idN = &idN
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) IpsecProposal(ipsecProposal []string) ApiVpnIpsecPoliciesListRequest {
	r.ipsecProposal = &ipsecProposal
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) IpsecProposalN(ipsecProposalN []string) ApiVpnIpsecPoliciesListRequest {
	r.ipsecProposalN = &ipsecProposalN
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) IpsecProposalId(ipsecProposalId []int32) ApiVpnIpsecPoliciesListRequest {
	r.ipsecProposalId = &ipsecProposalId
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) IpsecProposalIdN(ipsecProposalIdN []int32) ApiVpnIpsecPoliciesListRequest {
	r.ipsecProposalIdN = &ipsecProposalIdN
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) LastUpdated(lastUpdated []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiVpnIpsecPoliciesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiVpnIpsecPoliciesListRequest) Limit(limit int32) ApiVpnIpsecPoliciesListRequest {
	r.limit = &limit
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) ModifiedByRequest(modifiedByRequest string) ApiVpnIpsecPoliciesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) Name(name []string) ApiVpnIpsecPoliciesListRequest {
	r.name = &name
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) NameEmpty(nameEmpty bool) ApiVpnIpsecPoliciesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) NameIc(nameIc []string) ApiVpnIpsecPoliciesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) NameIe(nameIe []string) ApiVpnIpsecPoliciesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) NameIew(nameIew []string) ApiVpnIpsecPoliciesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) NameIsw(nameIsw []string) ApiVpnIpsecPoliciesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) NameN(nameN []string) ApiVpnIpsecPoliciesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) NameNic(nameNic []string) ApiVpnIpsecPoliciesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) NameNie(nameNie []string) ApiVpnIpsecPoliciesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) NameNiew(nameNiew []string) ApiVpnIpsecPoliciesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) NameNisw(nameNisw []string) ApiVpnIpsecPoliciesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiVpnIpsecPoliciesListRequest) Offset(offset int32) ApiVpnIpsecPoliciesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiVpnIpsecPoliciesListRequest) Ordering(ordering string) ApiVpnIpsecPoliciesListRequest {
	r.ordering = &ordering
	return r
}

// Diffie-Hellman group for Perfect Forward Secrecy
func (r ApiVpnIpsecPoliciesListRequest) PfsGroup(pfsGroup []*int32) ApiVpnIpsecPoliciesListRequest {
	r.pfsGroup = &pfsGroup
	return r
}

// Diffie-Hellman group for Perfect Forward Secrecy
func (r ApiVpnIpsecPoliciesListRequest) PfsGroupIc(pfsGroupIc []*int32) ApiVpnIpsecPoliciesListRequest {
	r.pfsGroupIc = &pfsGroupIc
	return r
}

// Diffie-Hellman group for Perfect Forward Secrecy
func (r ApiVpnIpsecPoliciesListRequest) PfsGroupIe(pfsGroupIe []*int32) ApiVpnIpsecPoliciesListRequest {
	r.pfsGroupIe = &pfsGroupIe
	return r
}

// Diffie-Hellman group for Perfect Forward Secrecy
func (r ApiVpnIpsecPoliciesListRequest) PfsGroupIew(pfsGroupIew []*int32) ApiVpnIpsecPoliciesListRequest {
	r.pfsGroupIew = &pfsGroupIew
	return r
}

// Diffie-Hellman group for Perfect Forward Secrecy
func (r ApiVpnIpsecPoliciesListRequest) PfsGroupIsw(pfsGroupIsw []*int32) ApiVpnIpsecPoliciesListRequest {
	r.pfsGroupIsw = &pfsGroupIsw
	return r
}

// Diffie-Hellman group for Perfect Forward Secrecy
func (r ApiVpnIpsecPoliciesListRequest) PfsGroupN(pfsGroupN []*int32) ApiVpnIpsecPoliciesListRequest {
	r.pfsGroupN = &pfsGroupN
	return r
}

// Diffie-Hellman group for Perfect Forward Secrecy
func (r ApiVpnIpsecPoliciesListRequest) PfsGroupNic(pfsGroupNic []*int32) ApiVpnIpsecPoliciesListRequest {
	r.pfsGroupNic = &pfsGroupNic
	return r
}

// Diffie-Hellman group for Perfect Forward Secrecy
func (r ApiVpnIpsecPoliciesListRequest) PfsGroupNie(pfsGroupNie []*int32) ApiVpnIpsecPoliciesListRequest {
	r.pfsGroupNie = &pfsGroupNie
	return r
}

// Diffie-Hellman group for Perfect Forward Secrecy
func (r ApiVpnIpsecPoliciesListRequest) PfsGroupNiew(pfsGroupNiew []*int32) ApiVpnIpsecPoliciesListRequest {
	r.pfsGroupNiew = &pfsGroupNiew
	return r
}

// Diffie-Hellman group for Perfect Forward Secrecy
func (r ApiVpnIpsecPoliciesListRequest) PfsGroupNisw(pfsGroupNisw []*int32) ApiVpnIpsecPoliciesListRequest {
	r.pfsGroupNisw = &pfsGroupNisw
	return r
}

// Search
func (r ApiVpnIpsecPoliciesListRequest) Q(q string) ApiVpnIpsecPoliciesListRequest {
	r.q = &q
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) Tag(tag []string) ApiVpnIpsecPoliciesListRequest {
	r.tag = &tag
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) TagN(tagN []string) ApiVpnIpsecPoliciesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) UpdatedByRequest(updatedByRequest string) ApiVpnIpsecPoliciesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiVpnIpsecPoliciesListRequest) Execute() (*PaginatedIPSecPolicyList, *http.Response, error) {
	return r.ApiService.VpnIpsecPoliciesListExecute(r)
}

/*
VpnIpsecPoliciesList Method for VpnIpsecPoliciesList

Get a list of IPSec policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecPoliciesListRequest
*/
func (a *VpnAPIService) VpnIpsecPoliciesList(ctx context.Context) ApiVpnIpsecPoliciesListRequest {
	return ApiVpnIpsecPoliciesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIPSecPolicyList
func (a *VpnAPIService) VpnIpsecPoliciesListExecute(r ApiVpnIpsecPoliciesListRequest) (*PaginatedIPSecPolicyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIPSecPolicyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecPoliciesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.ipsecProposal != nil {
		t := *r.ipsecProposal
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_proposal", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_proposal", t, "form", "multi")
		}
	}
	if r.ipsecProposalN != nil {
		t := *r.ipsecProposalN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_proposal__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_proposal__n", t, "form", "multi")
		}
	}
	if r.ipsecProposalId != nil {
		t := *r.ipsecProposalId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_proposal_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_proposal_id", t, "form", "multi")
		}
	}
	if r.ipsecProposalIdN != nil {
		t := *r.ipsecProposalIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_proposal_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_proposal_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.pfsGroup != nil {
		t := *r.pfsGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group", t, "form", "multi")
		}
	}
	if r.pfsGroupIc != nil {
		t := *r.pfsGroupIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__ic", t, "form", "multi")
		}
	}
	if r.pfsGroupIe != nil {
		t := *r.pfsGroupIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__ie", t, "form", "multi")
		}
	}
	if r.pfsGroupIew != nil {
		t := *r.pfsGroupIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__iew", t, "form", "multi")
		}
	}
	if r.pfsGroupIsw != nil {
		t := *r.pfsGroupIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__isw", t, "form", "multi")
		}
	}
	if r.pfsGroupN != nil {
		t := *r.pfsGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__n", t, "form", "multi")
		}
	}
	if r.pfsGroupNic != nil {
		t := *r.pfsGroupNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__nic", t, "form", "multi")
		}
	}
	if r.pfsGroupNie != nil {
		t := *r.pfsGroupNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__nie", t, "form", "multi")
		}
	}
	if r.pfsGroupNiew != nil {
		t := *r.pfsGroupNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__niew", t, "form", "multi")
		}
	}
	if r.pfsGroupNisw != nil {
		t := *r.pfsGroupNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "pfs_group__nisw", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecPoliciesPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	patchedWritableIPSecPolicyRequest *PatchedWritableIPSecPolicyRequest
}

func (r ApiVpnIpsecPoliciesPartialUpdateRequest) PatchedWritableIPSecPolicyRequest(patchedWritableIPSecPolicyRequest PatchedWritableIPSecPolicyRequest) ApiVpnIpsecPoliciesPartialUpdateRequest {
	r.patchedWritableIPSecPolicyRequest = &patchedWritableIPSecPolicyRequest
	return r
}

func (r ApiVpnIpsecPoliciesPartialUpdateRequest) Execute() (*IPSecPolicy, *http.Response, error) {
	return r.ApiService.VpnIpsecPoliciesPartialUpdateExecute(r)
}

/*
VpnIpsecPoliciesPartialUpdate Method for VpnIpsecPoliciesPartialUpdate

Patch a IPSec policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec policy.
 @return ApiVpnIpsecPoliciesPartialUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecPoliciesPartialUpdate(ctx context.Context, id int32) ApiVpnIpsecPoliciesPartialUpdateRequest {
	return ApiVpnIpsecPoliciesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPSecPolicy
func (a *VpnAPIService) VpnIpsecPoliciesPartialUpdateExecute(r ApiVpnIpsecPoliciesPartialUpdateRequest) (*IPSecPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecPoliciesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableIPSecPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecPoliciesRetrieveRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnIpsecPoliciesRetrieveRequest) Execute() (*IPSecPolicy, *http.Response, error) {
	return r.ApiService.VpnIpsecPoliciesRetrieveExecute(r)
}

/*
VpnIpsecPoliciesRetrieve Method for VpnIpsecPoliciesRetrieve

Get a IPSec policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec policy.
 @return ApiVpnIpsecPoliciesRetrieveRequest
*/
func (a *VpnAPIService) VpnIpsecPoliciesRetrieve(ctx context.Context, id int32) ApiVpnIpsecPoliciesRetrieveRequest {
	return ApiVpnIpsecPoliciesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPSecPolicy
func (a *VpnAPIService) VpnIpsecPoliciesRetrieveExecute(r ApiVpnIpsecPoliciesRetrieveRequest) (*IPSecPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecPoliciesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecPoliciesUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	writableIPSecPolicyRequest *WritableIPSecPolicyRequest
}

func (r ApiVpnIpsecPoliciesUpdateRequest) WritableIPSecPolicyRequest(writableIPSecPolicyRequest WritableIPSecPolicyRequest) ApiVpnIpsecPoliciesUpdateRequest {
	r.writableIPSecPolicyRequest = &writableIPSecPolicyRequest
	return r
}

func (r ApiVpnIpsecPoliciesUpdateRequest) Execute() (*IPSecPolicy, *http.Response, error) {
	return r.ApiService.VpnIpsecPoliciesUpdateExecute(r)
}

/*
VpnIpsecPoliciesUpdate Method for VpnIpsecPoliciesUpdate

Put a IPSec policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec policy.
 @return ApiVpnIpsecPoliciesUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecPoliciesUpdate(ctx context.Context, id int32) ApiVpnIpsecPoliciesUpdateRequest {
	return ApiVpnIpsecPoliciesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPSecPolicy
func (a *VpnAPIService) VpnIpsecPoliciesUpdateExecute(r ApiVpnIpsecPoliciesUpdateRequest) (*IPSecPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecPoliciesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPSecPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPSecPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPSecPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProfilesBulkDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iPSecProfileRequest *[]IPSecProfileRequest
}

func (r ApiVpnIpsecProfilesBulkDestroyRequest) IPSecProfileRequest(iPSecProfileRequest []IPSecProfileRequest) ApiVpnIpsecProfilesBulkDestroyRequest {
	r.iPSecProfileRequest = &iPSecProfileRequest
	return r
}

func (r ApiVpnIpsecProfilesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnIpsecProfilesBulkDestroyExecute(r)
}

/*
VpnIpsecProfilesBulkDestroy Method for VpnIpsecProfilesBulkDestroy

Delete a list of IPSec profile objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecProfilesBulkDestroyRequest
*/
func (a *VpnAPIService) VpnIpsecProfilesBulkDestroy(ctx context.Context) ApiVpnIpsecProfilesBulkDestroyRequest {
	return ApiVpnIpsecProfilesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnIpsecProfilesBulkDestroyExecute(r ApiVpnIpsecProfilesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProfilesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-profiles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPSecProfileRequest == nil {
		return nil, reportError("iPSecProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPSecProfileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnIpsecProfilesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iPSecProfileRequest *[]IPSecProfileRequest
}

func (r ApiVpnIpsecProfilesBulkPartialUpdateRequest) IPSecProfileRequest(iPSecProfileRequest []IPSecProfileRequest) ApiVpnIpsecProfilesBulkPartialUpdateRequest {
	r.iPSecProfileRequest = &iPSecProfileRequest
	return r
}

func (r ApiVpnIpsecProfilesBulkPartialUpdateRequest) Execute() ([]IPSecProfile, *http.Response, error) {
	return r.ApiService.VpnIpsecProfilesBulkPartialUpdateExecute(r)
}

/*
VpnIpsecProfilesBulkPartialUpdate Method for VpnIpsecProfilesBulkPartialUpdate

Patch a list of IPSec profile objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecProfilesBulkPartialUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecProfilesBulkPartialUpdate(ctx context.Context) ApiVpnIpsecProfilesBulkPartialUpdateRequest {
	return ApiVpnIpsecProfilesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPSecProfile
func (a *VpnAPIService) VpnIpsecProfilesBulkPartialUpdateExecute(r ApiVpnIpsecProfilesBulkPartialUpdateRequest) ([]IPSecProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPSecProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProfilesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-profiles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPSecProfileRequest == nil {
		return localVarReturnValue, nil, reportError("iPSecProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPSecProfileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProfilesBulkUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iPSecProfileRequest *[]IPSecProfileRequest
}

func (r ApiVpnIpsecProfilesBulkUpdateRequest) IPSecProfileRequest(iPSecProfileRequest []IPSecProfileRequest) ApiVpnIpsecProfilesBulkUpdateRequest {
	r.iPSecProfileRequest = &iPSecProfileRequest
	return r
}

func (r ApiVpnIpsecProfilesBulkUpdateRequest) Execute() ([]IPSecProfile, *http.Response, error) {
	return r.ApiService.VpnIpsecProfilesBulkUpdateExecute(r)
}

/*
VpnIpsecProfilesBulkUpdate Method for VpnIpsecProfilesBulkUpdate

Put a list of IPSec profile objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecProfilesBulkUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecProfilesBulkUpdate(ctx context.Context) ApiVpnIpsecProfilesBulkUpdateRequest {
	return ApiVpnIpsecProfilesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPSecProfile
func (a *VpnAPIService) VpnIpsecProfilesBulkUpdateExecute(r ApiVpnIpsecProfilesBulkUpdateRequest) ([]IPSecProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPSecProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProfilesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-profiles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPSecProfileRequest == nil {
		return localVarReturnValue, nil, reportError("iPSecProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPSecProfileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProfilesCreateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	writableIPSecProfileRequest *WritableIPSecProfileRequest
}

func (r ApiVpnIpsecProfilesCreateRequest) WritableIPSecProfileRequest(writableIPSecProfileRequest WritableIPSecProfileRequest) ApiVpnIpsecProfilesCreateRequest {
	r.writableIPSecProfileRequest = &writableIPSecProfileRequest
	return r
}

func (r ApiVpnIpsecProfilesCreateRequest) Execute() (*IPSecProfile, *http.Response, error) {
	return r.ApiService.VpnIpsecProfilesCreateExecute(r)
}

/*
VpnIpsecProfilesCreate Method for VpnIpsecProfilesCreate

Post a list of IPSec profile objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecProfilesCreateRequest
*/
func (a *VpnAPIService) VpnIpsecProfilesCreate(ctx context.Context) ApiVpnIpsecProfilesCreateRequest {
	return ApiVpnIpsecProfilesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPSecProfile
func (a *VpnAPIService) VpnIpsecProfilesCreateExecute(r ApiVpnIpsecProfilesCreateRequest) (*IPSecProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProfilesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-profiles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPSecProfileRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPSecProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPSecProfileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProfilesDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnIpsecProfilesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnIpsecProfilesDestroyExecute(r)
}

/*
VpnIpsecProfilesDestroy Method for VpnIpsecProfilesDestroy

Delete a IPSec profile object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec profile.
 @return ApiVpnIpsecProfilesDestroyRequest
*/
func (a *VpnAPIService) VpnIpsecProfilesDestroy(ctx context.Context, id int32) ApiVpnIpsecProfilesDestroyRequest {
	return ApiVpnIpsecProfilesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnIpsecProfilesDestroyExecute(r ApiVpnIpsecProfilesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProfilesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-profiles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnIpsecProfilesListRequest struct {
	ctx context.Context
	ApiService VpnAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	ikePolicy *[]string
	ikePolicyN *[]string
	ikePolicyId *[]int32
	ikePolicyIdN *[]int32
	ipsecPolicy *[]string
	ipsecPolicyN *[]string
	ipsecPolicyId *[]int32
	ipsecPolicyIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	mode *[]string
	modeEmpty *bool
	modeIc *[]string
	modeIe *[]string
	modeIew *[]string
	modeIsw *[]string
	modeN *[]string
	modeNic *[]string
	modeNie *[]string
	modeNiew *[]string
	modeNisw *[]string
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiVpnIpsecProfilesListRequest) Created(created []time.Time) ApiVpnIpsecProfilesListRequest {
	r.created = &created
	return r
}

func (r ApiVpnIpsecProfilesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiVpnIpsecProfilesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiVpnIpsecProfilesListRequest) CreatedGt(createdGt []time.Time) ApiVpnIpsecProfilesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiVpnIpsecProfilesListRequest) CreatedGte(createdGte []time.Time) ApiVpnIpsecProfilesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVpnIpsecProfilesListRequest) CreatedLt(createdLt []time.Time) ApiVpnIpsecProfilesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiVpnIpsecProfilesListRequest) CreatedLte(createdLte []time.Time) ApiVpnIpsecProfilesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVpnIpsecProfilesListRequest) CreatedN(createdN []time.Time) ApiVpnIpsecProfilesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiVpnIpsecProfilesListRequest) CreatedByRequest(createdByRequest string) ApiVpnIpsecProfilesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiVpnIpsecProfilesListRequest) Description(description []string) ApiVpnIpsecProfilesListRequest {
	r.description = &description
	return r
}

func (r ApiVpnIpsecProfilesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiVpnIpsecProfilesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiVpnIpsecProfilesListRequest) DescriptionIc(descriptionIc []string) ApiVpnIpsecProfilesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiVpnIpsecProfilesListRequest) DescriptionIe(descriptionIe []string) ApiVpnIpsecProfilesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiVpnIpsecProfilesListRequest) DescriptionIew(descriptionIew []string) ApiVpnIpsecProfilesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiVpnIpsecProfilesListRequest) DescriptionIsw(descriptionIsw []string) ApiVpnIpsecProfilesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiVpnIpsecProfilesListRequest) DescriptionN(descriptionN []string) ApiVpnIpsecProfilesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiVpnIpsecProfilesListRequest) DescriptionNic(descriptionNic []string) ApiVpnIpsecProfilesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiVpnIpsecProfilesListRequest) DescriptionNie(descriptionNie []string) ApiVpnIpsecProfilesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiVpnIpsecProfilesListRequest) DescriptionNiew(descriptionNiew []string) ApiVpnIpsecProfilesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiVpnIpsecProfilesListRequest) DescriptionNisw(descriptionNisw []string) ApiVpnIpsecProfilesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiVpnIpsecProfilesListRequest) Id(id []int32) ApiVpnIpsecProfilesListRequest {
	r.id = &id
	return r
}

func (r ApiVpnIpsecProfilesListRequest) IdEmpty(idEmpty bool) ApiVpnIpsecProfilesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiVpnIpsecProfilesListRequest) IdGt(idGt []int32) ApiVpnIpsecProfilesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVpnIpsecProfilesListRequest) IdGte(idGte []int32) ApiVpnIpsecProfilesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVpnIpsecProfilesListRequest) IdLt(idLt []int32) ApiVpnIpsecProfilesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVpnIpsecProfilesListRequest) IdLte(idLte []int32) ApiVpnIpsecProfilesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVpnIpsecProfilesListRequest) IdN(idN []int32) ApiVpnIpsecProfilesListRequest {
	r.idN = &idN
	return r
}

// IKE policy (name)
func (r ApiVpnIpsecProfilesListRequest) IkePolicy(ikePolicy []string) ApiVpnIpsecProfilesListRequest {
	r.ikePolicy = &ikePolicy
	return r
}

// IKE policy (name)
func (r ApiVpnIpsecProfilesListRequest) IkePolicyN(ikePolicyN []string) ApiVpnIpsecProfilesListRequest {
	r.ikePolicyN = &ikePolicyN
	return r
}

// IKE policy (ID)
func (r ApiVpnIpsecProfilesListRequest) IkePolicyId(ikePolicyId []int32) ApiVpnIpsecProfilesListRequest {
	r.ikePolicyId = &ikePolicyId
	return r
}

// IKE policy (ID)
func (r ApiVpnIpsecProfilesListRequest) IkePolicyIdN(ikePolicyIdN []int32) ApiVpnIpsecProfilesListRequest {
	r.ikePolicyIdN = &ikePolicyIdN
	return r
}

// IPSec policy (name)
func (r ApiVpnIpsecProfilesListRequest) IpsecPolicy(ipsecPolicy []string) ApiVpnIpsecProfilesListRequest {
	r.ipsecPolicy = &ipsecPolicy
	return r
}

// IPSec policy (name)
func (r ApiVpnIpsecProfilesListRequest) IpsecPolicyN(ipsecPolicyN []string) ApiVpnIpsecProfilesListRequest {
	r.ipsecPolicyN = &ipsecPolicyN
	return r
}

// IPSec policy (ID)
func (r ApiVpnIpsecProfilesListRequest) IpsecPolicyId(ipsecPolicyId []int32) ApiVpnIpsecProfilesListRequest {
	r.ipsecPolicyId = &ipsecPolicyId
	return r
}

// IPSec policy (ID)
func (r ApiVpnIpsecProfilesListRequest) IpsecPolicyIdN(ipsecPolicyIdN []int32) ApiVpnIpsecProfilesListRequest {
	r.ipsecPolicyIdN = &ipsecPolicyIdN
	return r
}

func (r ApiVpnIpsecProfilesListRequest) LastUpdated(lastUpdated []time.Time) ApiVpnIpsecProfilesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVpnIpsecProfilesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiVpnIpsecProfilesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiVpnIpsecProfilesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiVpnIpsecProfilesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiVpnIpsecProfilesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiVpnIpsecProfilesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVpnIpsecProfilesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiVpnIpsecProfilesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiVpnIpsecProfilesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiVpnIpsecProfilesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVpnIpsecProfilesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiVpnIpsecProfilesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiVpnIpsecProfilesListRequest) Limit(limit int32) ApiVpnIpsecProfilesListRequest {
	r.limit = &limit
	return r
}

func (r ApiVpnIpsecProfilesListRequest) Mode(mode []string) ApiVpnIpsecProfilesListRequest {
	r.mode = &mode
	return r
}

func (r ApiVpnIpsecProfilesListRequest) ModeEmpty(modeEmpty bool) ApiVpnIpsecProfilesListRequest {
	r.modeEmpty = &modeEmpty
	return r
}

func (r ApiVpnIpsecProfilesListRequest) ModeIc(modeIc []string) ApiVpnIpsecProfilesListRequest {
	r.modeIc = &modeIc
	return r
}

func (r ApiVpnIpsecProfilesListRequest) ModeIe(modeIe []string) ApiVpnIpsecProfilesListRequest {
	r.modeIe = &modeIe
	return r
}

func (r ApiVpnIpsecProfilesListRequest) ModeIew(modeIew []string) ApiVpnIpsecProfilesListRequest {
	r.modeIew = &modeIew
	return r
}

func (r ApiVpnIpsecProfilesListRequest) ModeIsw(modeIsw []string) ApiVpnIpsecProfilesListRequest {
	r.modeIsw = &modeIsw
	return r
}

func (r ApiVpnIpsecProfilesListRequest) ModeN(modeN []string) ApiVpnIpsecProfilesListRequest {
	r.modeN = &modeN
	return r
}

func (r ApiVpnIpsecProfilesListRequest) ModeNic(modeNic []string) ApiVpnIpsecProfilesListRequest {
	r.modeNic = &modeNic
	return r
}

func (r ApiVpnIpsecProfilesListRequest) ModeNie(modeNie []string) ApiVpnIpsecProfilesListRequest {
	r.modeNie = &modeNie
	return r
}

func (r ApiVpnIpsecProfilesListRequest) ModeNiew(modeNiew []string) ApiVpnIpsecProfilesListRequest {
	r.modeNiew = &modeNiew
	return r
}

func (r ApiVpnIpsecProfilesListRequest) ModeNisw(modeNisw []string) ApiVpnIpsecProfilesListRequest {
	r.modeNisw = &modeNisw
	return r
}

func (r ApiVpnIpsecProfilesListRequest) ModifiedByRequest(modifiedByRequest string) ApiVpnIpsecProfilesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiVpnIpsecProfilesListRequest) Name(name []string) ApiVpnIpsecProfilesListRequest {
	r.name = &name
	return r
}

func (r ApiVpnIpsecProfilesListRequest) NameEmpty(nameEmpty bool) ApiVpnIpsecProfilesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVpnIpsecProfilesListRequest) NameIc(nameIc []string) ApiVpnIpsecProfilesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVpnIpsecProfilesListRequest) NameIe(nameIe []string) ApiVpnIpsecProfilesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVpnIpsecProfilesListRequest) NameIew(nameIew []string) ApiVpnIpsecProfilesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVpnIpsecProfilesListRequest) NameIsw(nameIsw []string) ApiVpnIpsecProfilesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVpnIpsecProfilesListRequest) NameN(nameN []string) ApiVpnIpsecProfilesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVpnIpsecProfilesListRequest) NameNic(nameNic []string) ApiVpnIpsecProfilesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVpnIpsecProfilesListRequest) NameNie(nameNie []string) ApiVpnIpsecProfilesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVpnIpsecProfilesListRequest) NameNiew(nameNiew []string) ApiVpnIpsecProfilesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVpnIpsecProfilesListRequest) NameNisw(nameNisw []string) ApiVpnIpsecProfilesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiVpnIpsecProfilesListRequest) Offset(offset int32) ApiVpnIpsecProfilesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiVpnIpsecProfilesListRequest) Ordering(ordering string) ApiVpnIpsecProfilesListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiVpnIpsecProfilesListRequest) Q(q string) ApiVpnIpsecProfilesListRequest {
	r.q = &q
	return r
}

func (r ApiVpnIpsecProfilesListRequest) Tag(tag []string) ApiVpnIpsecProfilesListRequest {
	r.tag = &tag
	return r
}

func (r ApiVpnIpsecProfilesListRequest) TagN(tagN []string) ApiVpnIpsecProfilesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiVpnIpsecProfilesListRequest) UpdatedByRequest(updatedByRequest string) ApiVpnIpsecProfilesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiVpnIpsecProfilesListRequest) Execute() (*PaginatedIPSecProfileList, *http.Response, error) {
	return r.ApiService.VpnIpsecProfilesListExecute(r)
}

/*
VpnIpsecProfilesList Method for VpnIpsecProfilesList

Get a list of IPSec profile objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecProfilesListRequest
*/
func (a *VpnAPIService) VpnIpsecProfilesList(ctx context.Context) ApiVpnIpsecProfilesListRequest {
	return ApiVpnIpsecProfilesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIPSecProfileList
func (a *VpnAPIService) VpnIpsecProfilesListExecute(r ApiVpnIpsecProfilesListRequest) (*PaginatedIPSecProfileList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIPSecProfileList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProfilesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-profiles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.ikePolicy != nil {
		t := *r.ikePolicy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy", t, "form", "multi")
		}
	}
	if r.ikePolicyN != nil {
		t := *r.ikePolicyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy__n", t, "form", "multi")
		}
	}
	if r.ikePolicyId != nil {
		t := *r.ikePolicyId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy_id", t, "form", "multi")
		}
	}
	if r.ikePolicyIdN != nil {
		t := *r.ikePolicyIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ike_policy_id__n", t, "form", "multi")
		}
	}
	if r.ipsecPolicy != nil {
		t := *r.ipsecPolicy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy", t, "form", "multi")
		}
	}
	if r.ipsecPolicyN != nil {
		t := *r.ipsecPolicyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy__n", t, "form", "multi")
		}
	}
	if r.ipsecPolicyId != nil {
		t := *r.ipsecPolicyId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy_id", t, "form", "multi")
		}
	}
	if r.ipsecPolicyIdN != nil {
		t := *r.ipsecPolicyIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.mode != nil {
		t := *r.mode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode", t, "form", "multi")
		}
	}
	if r.modeEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode__empty", r.modeEmpty, "form", "")
	}
	if r.modeIc != nil {
		t := *r.modeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ic", t, "form", "multi")
		}
	}
	if r.modeIe != nil {
		t := *r.modeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__ie", t, "form", "multi")
		}
	}
	if r.modeIew != nil {
		t := *r.modeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__iew", t, "form", "multi")
		}
	}
	if r.modeIsw != nil {
		t := *r.modeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__isw", t, "form", "multi")
		}
	}
	if r.modeN != nil {
		t := *r.modeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__n", t, "form", "multi")
		}
	}
	if r.modeNic != nil {
		t := *r.modeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nic", t, "form", "multi")
		}
	}
	if r.modeNie != nil {
		t := *r.modeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nie", t, "form", "multi")
		}
	}
	if r.modeNiew != nil {
		t := *r.modeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__niew", t, "form", "multi")
		}
	}
	if r.modeNisw != nil {
		t := *r.modeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mode__nisw", t, "form", "multi")
		}
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProfilesPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	patchedWritableIPSecProfileRequest *PatchedWritableIPSecProfileRequest
}

func (r ApiVpnIpsecProfilesPartialUpdateRequest) PatchedWritableIPSecProfileRequest(patchedWritableIPSecProfileRequest PatchedWritableIPSecProfileRequest) ApiVpnIpsecProfilesPartialUpdateRequest {
	r.patchedWritableIPSecProfileRequest = &patchedWritableIPSecProfileRequest
	return r
}

func (r ApiVpnIpsecProfilesPartialUpdateRequest) Execute() (*IPSecProfile, *http.Response, error) {
	return r.ApiService.VpnIpsecProfilesPartialUpdateExecute(r)
}

/*
VpnIpsecProfilesPartialUpdate Method for VpnIpsecProfilesPartialUpdate

Patch a IPSec profile object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec profile.
 @return ApiVpnIpsecProfilesPartialUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecProfilesPartialUpdate(ctx context.Context, id int32) ApiVpnIpsecProfilesPartialUpdateRequest {
	return ApiVpnIpsecProfilesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPSecProfile
func (a *VpnAPIService) VpnIpsecProfilesPartialUpdateExecute(r ApiVpnIpsecProfilesPartialUpdateRequest) (*IPSecProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProfilesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-profiles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableIPSecProfileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProfilesRetrieveRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnIpsecProfilesRetrieveRequest) Execute() (*IPSecProfile, *http.Response, error) {
	return r.ApiService.VpnIpsecProfilesRetrieveExecute(r)
}

/*
VpnIpsecProfilesRetrieve Method for VpnIpsecProfilesRetrieve

Get a IPSec profile object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec profile.
 @return ApiVpnIpsecProfilesRetrieveRequest
*/
func (a *VpnAPIService) VpnIpsecProfilesRetrieve(ctx context.Context, id int32) ApiVpnIpsecProfilesRetrieveRequest {
	return ApiVpnIpsecProfilesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPSecProfile
func (a *VpnAPIService) VpnIpsecProfilesRetrieveExecute(r ApiVpnIpsecProfilesRetrieveRequest) (*IPSecProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProfilesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-profiles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProfilesUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	writableIPSecProfileRequest *WritableIPSecProfileRequest
}

func (r ApiVpnIpsecProfilesUpdateRequest) WritableIPSecProfileRequest(writableIPSecProfileRequest WritableIPSecProfileRequest) ApiVpnIpsecProfilesUpdateRequest {
	r.writableIPSecProfileRequest = &writableIPSecProfileRequest
	return r
}

func (r ApiVpnIpsecProfilesUpdateRequest) Execute() (*IPSecProfile, *http.Response, error) {
	return r.ApiService.VpnIpsecProfilesUpdateExecute(r)
}

/*
VpnIpsecProfilesUpdate Method for VpnIpsecProfilesUpdate

Put a IPSec profile object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec profile.
 @return ApiVpnIpsecProfilesUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecProfilesUpdate(ctx context.Context, id int32) ApiVpnIpsecProfilesUpdateRequest {
	return ApiVpnIpsecProfilesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPSecProfile
func (a *VpnAPIService) VpnIpsecProfilesUpdateExecute(r ApiVpnIpsecProfilesUpdateRequest) (*IPSecProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProfilesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-profiles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPSecProfileRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPSecProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPSecProfileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProposalsBulkDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iPSecProposalRequest *[]IPSecProposalRequest
}

func (r ApiVpnIpsecProposalsBulkDestroyRequest) IPSecProposalRequest(iPSecProposalRequest []IPSecProposalRequest) ApiVpnIpsecProposalsBulkDestroyRequest {
	r.iPSecProposalRequest = &iPSecProposalRequest
	return r
}

func (r ApiVpnIpsecProposalsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnIpsecProposalsBulkDestroyExecute(r)
}

/*
VpnIpsecProposalsBulkDestroy Method for VpnIpsecProposalsBulkDestroy

Delete a list of IPSec proposal objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecProposalsBulkDestroyRequest
*/
func (a *VpnAPIService) VpnIpsecProposalsBulkDestroy(ctx context.Context) ApiVpnIpsecProposalsBulkDestroyRequest {
	return ApiVpnIpsecProposalsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnIpsecProposalsBulkDestroyExecute(r ApiVpnIpsecProposalsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProposalsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-proposals/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPSecProposalRequest == nil {
		return nil, reportError("iPSecProposalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPSecProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnIpsecProposalsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iPSecProposalRequest *[]IPSecProposalRequest
}

func (r ApiVpnIpsecProposalsBulkPartialUpdateRequest) IPSecProposalRequest(iPSecProposalRequest []IPSecProposalRequest) ApiVpnIpsecProposalsBulkPartialUpdateRequest {
	r.iPSecProposalRequest = &iPSecProposalRequest
	return r
}

func (r ApiVpnIpsecProposalsBulkPartialUpdateRequest) Execute() ([]IPSecProposal, *http.Response, error) {
	return r.ApiService.VpnIpsecProposalsBulkPartialUpdateExecute(r)
}

/*
VpnIpsecProposalsBulkPartialUpdate Method for VpnIpsecProposalsBulkPartialUpdate

Patch a list of IPSec proposal objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecProposalsBulkPartialUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecProposalsBulkPartialUpdate(ctx context.Context) ApiVpnIpsecProposalsBulkPartialUpdateRequest {
	return ApiVpnIpsecProposalsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPSecProposal
func (a *VpnAPIService) VpnIpsecProposalsBulkPartialUpdateExecute(r ApiVpnIpsecProposalsBulkPartialUpdateRequest) ([]IPSecProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPSecProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProposalsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-proposals/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPSecProposalRequest == nil {
		return localVarReturnValue, nil, reportError("iPSecProposalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPSecProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProposalsBulkUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	iPSecProposalRequest *[]IPSecProposalRequest
}

func (r ApiVpnIpsecProposalsBulkUpdateRequest) IPSecProposalRequest(iPSecProposalRequest []IPSecProposalRequest) ApiVpnIpsecProposalsBulkUpdateRequest {
	r.iPSecProposalRequest = &iPSecProposalRequest
	return r
}

func (r ApiVpnIpsecProposalsBulkUpdateRequest) Execute() ([]IPSecProposal, *http.Response, error) {
	return r.ApiService.VpnIpsecProposalsBulkUpdateExecute(r)
}

/*
VpnIpsecProposalsBulkUpdate Method for VpnIpsecProposalsBulkUpdate

Put a list of IPSec proposal objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecProposalsBulkUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecProposalsBulkUpdate(ctx context.Context) ApiVpnIpsecProposalsBulkUpdateRequest {
	return ApiVpnIpsecProposalsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPSecProposal
func (a *VpnAPIService) VpnIpsecProposalsBulkUpdateExecute(r ApiVpnIpsecProposalsBulkUpdateRequest) ([]IPSecProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPSecProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProposalsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-proposals/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPSecProposalRequest == nil {
		return localVarReturnValue, nil, reportError("iPSecProposalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPSecProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProposalsCreateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	writableIPSecProposalRequest *WritableIPSecProposalRequest
}

func (r ApiVpnIpsecProposalsCreateRequest) WritableIPSecProposalRequest(writableIPSecProposalRequest WritableIPSecProposalRequest) ApiVpnIpsecProposalsCreateRequest {
	r.writableIPSecProposalRequest = &writableIPSecProposalRequest
	return r
}

func (r ApiVpnIpsecProposalsCreateRequest) Execute() (*IPSecProposal, *http.Response, error) {
	return r.ApiService.VpnIpsecProposalsCreateExecute(r)
}

/*
VpnIpsecProposalsCreate Method for VpnIpsecProposalsCreate

Post a list of IPSec proposal objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecProposalsCreateRequest
*/
func (a *VpnAPIService) VpnIpsecProposalsCreate(ctx context.Context) ApiVpnIpsecProposalsCreateRequest {
	return ApiVpnIpsecProposalsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPSecProposal
func (a *VpnAPIService) VpnIpsecProposalsCreateExecute(r ApiVpnIpsecProposalsCreateRequest) (*IPSecProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProposalsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-proposals/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPSecProposalRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPSecProposalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPSecProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProposalsDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnIpsecProposalsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnIpsecProposalsDestroyExecute(r)
}

/*
VpnIpsecProposalsDestroy Method for VpnIpsecProposalsDestroy

Delete a IPSec proposal object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec proposal.
 @return ApiVpnIpsecProposalsDestroyRequest
*/
func (a *VpnAPIService) VpnIpsecProposalsDestroy(ctx context.Context, id int32) ApiVpnIpsecProposalsDestroyRequest {
	return ApiVpnIpsecProposalsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnIpsecProposalsDestroyExecute(r ApiVpnIpsecProposalsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProposalsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-proposals/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnIpsecProposalsListRequest struct {
	ctx context.Context
	ApiService VpnAPI
	authenticationAlgorithm *[]*string
	authenticationAlgorithmEmpty *bool
	authenticationAlgorithmIc *[]*string
	authenticationAlgorithmIe *[]*string
	authenticationAlgorithmIew *[]*string
	authenticationAlgorithmIsw *[]*string
	authenticationAlgorithmN *[]*string
	authenticationAlgorithmNic *[]*string
	authenticationAlgorithmNie *[]*string
	authenticationAlgorithmNiew *[]*string
	authenticationAlgorithmNisw *[]*string
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	encryptionAlgorithm *[]*string
	encryptionAlgorithmEmpty *bool
	encryptionAlgorithmIc *[]*string
	encryptionAlgorithmIe *[]*string
	encryptionAlgorithmIew *[]*string
	encryptionAlgorithmIsw *[]*string
	encryptionAlgorithmN *[]*string
	encryptionAlgorithmNic *[]*string
	encryptionAlgorithmNie *[]*string
	encryptionAlgorithmNiew *[]*string
	encryptionAlgorithmNisw *[]*string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	ipsecPolicy *[]string
	ipsecPolicyN *[]string
	ipsecPolicyId *[]int32
	ipsecPolicyIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	saLifetimeData *[]int32
	saLifetimeDataEmpty *bool
	saLifetimeDataGt *[]int32
	saLifetimeDataGte *[]int32
	saLifetimeDataLt *[]int32
	saLifetimeDataLte *[]int32
	saLifetimeDataN *[]int32
	saLifetimeSeconds *[]int32
	saLifetimeSecondsEmpty *bool
	saLifetimeSecondsGt *[]int32
	saLifetimeSecondsGte *[]int32
	saLifetimeSecondsLt *[]int32
	saLifetimeSecondsLte *[]int32
	saLifetimeSecondsN *[]int32
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiVpnIpsecProposalsListRequest) AuthenticationAlgorithm(authenticationAlgorithm []*string) ApiVpnIpsecProposalsListRequest {
	r.authenticationAlgorithm = &authenticationAlgorithm
	return r
}

func (r ApiVpnIpsecProposalsListRequest) AuthenticationAlgorithmEmpty(authenticationAlgorithmEmpty bool) ApiVpnIpsecProposalsListRequest {
	r.authenticationAlgorithmEmpty = &authenticationAlgorithmEmpty
	return r
}

func (r ApiVpnIpsecProposalsListRequest) AuthenticationAlgorithmIc(authenticationAlgorithmIc []*string) ApiVpnIpsecProposalsListRequest {
	r.authenticationAlgorithmIc = &authenticationAlgorithmIc
	return r
}

func (r ApiVpnIpsecProposalsListRequest) AuthenticationAlgorithmIe(authenticationAlgorithmIe []*string) ApiVpnIpsecProposalsListRequest {
	r.authenticationAlgorithmIe = &authenticationAlgorithmIe
	return r
}

func (r ApiVpnIpsecProposalsListRequest) AuthenticationAlgorithmIew(authenticationAlgorithmIew []*string) ApiVpnIpsecProposalsListRequest {
	r.authenticationAlgorithmIew = &authenticationAlgorithmIew
	return r
}

func (r ApiVpnIpsecProposalsListRequest) AuthenticationAlgorithmIsw(authenticationAlgorithmIsw []*string) ApiVpnIpsecProposalsListRequest {
	r.authenticationAlgorithmIsw = &authenticationAlgorithmIsw
	return r
}

func (r ApiVpnIpsecProposalsListRequest) AuthenticationAlgorithmN(authenticationAlgorithmN []*string) ApiVpnIpsecProposalsListRequest {
	r.authenticationAlgorithmN = &authenticationAlgorithmN
	return r
}

func (r ApiVpnIpsecProposalsListRequest) AuthenticationAlgorithmNic(authenticationAlgorithmNic []*string) ApiVpnIpsecProposalsListRequest {
	r.authenticationAlgorithmNic = &authenticationAlgorithmNic
	return r
}

func (r ApiVpnIpsecProposalsListRequest) AuthenticationAlgorithmNie(authenticationAlgorithmNie []*string) ApiVpnIpsecProposalsListRequest {
	r.authenticationAlgorithmNie = &authenticationAlgorithmNie
	return r
}

func (r ApiVpnIpsecProposalsListRequest) AuthenticationAlgorithmNiew(authenticationAlgorithmNiew []*string) ApiVpnIpsecProposalsListRequest {
	r.authenticationAlgorithmNiew = &authenticationAlgorithmNiew
	return r
}

func (r ApiVpnIpsecProposalsListRequest) AuthenticationAlgorithmNisw(authenticationAlgorithmNisw []*string) ApiVpnIpsecProposalsListRequest {
	r.authenticationAlgorithmNisw = &authenticationAlgorithmNisw
	return r
}

func (r ApiVpnIpsecProposalsListRequest) Created(created []time.Time) ApiVpnIpsecProposalsListRequest {
	r.created = &created
	return r
}

func (r ApiVpnIpsecProposalsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiVpnIpsecProposalsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiVpnIpsecProposalsListRequest) CreatedGt(createdGt []time.Time) ApiVpnIpsecProposalsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiVpnIpsecProposalsListRequest) CreatedGte(createdGte []time.Time) ApiVpnIpsecProposalsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVpnIpsecProposalsListRequest) CreatedLt(createdLt []time.Time) ApiVpnIpsecProposalsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiVpnIpsecProposalsListRequest) CreatedLte(createdLte []time.Time) ApiVpnIpsecProposalsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVpnIpsecProposalsListRequest) CreatedN(createdN []time.Time) ApiVpnIpsecProposalsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiVpnIpsecProposalsListRequest) CreatedByRequest(createdByRequest string) ApiVpnIpsecProposalsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiVpnIpsecProposalsListRequest) Description(description []string) ApiVpnIpsecProposalsListRequest {
	r.description = &description
	return r
}

func (r ApiVpnIpsecProposalsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiVpnIpsecProposalsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiVpnIpsecProposalsListRequest) DescriptionIc(descriptionIc []string) ApiVpnIpsecProposalsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiVpnIpsecProposalsListRequest) DescriptionIe(descriptionIe []string) ApiVpnIpsecProposalsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiVpnIpsecProposalsListRequest) DescriptionIew(descriptionIew []string) ApiVpnIpsecProposalsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiVpnIpsecProposalsListRequest) DescriptionIsw(descriptionIsw []string) ApiVpnIpsecProposalsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiVpnIpsecProposalsListRequest) DescriptionN(descriptionN []string) ApiVpnIpsecProposalsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiVpnIpsecProposalsListRequest) DescriptionNic(descriptionNic []string) ApiVpnIpsecProposalsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiVpnIpsecProposalsListRequest) DescriptionNie(descriptionNie []string) ApiVpnIpsecProposalsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiVpnIpsecProposalsListRequest) DescriptionNiew(descriptionNiew []string) ApiVpnIpsecProposalsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiVpnIpsecProposalsListRequest) DescriptionNisw(descriptionNisw []string) ApiVpnIpsecProposalsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiVpnIpsecProposalsListRequest) EncryptionAlgorithm(encryptionAlgorithm []*string) ApiVpnIpsecProposalsListRequest {
	r.encryptionAlgorithm = &encryptionAlgorithm
	return r
}

func (r ApiVpnIpsecProposalsListRequest) EncryptionAlgorithmEmpty(encryptionAlgorithmEmpty bool) ApiVpnIpsecProposalsListRequest {
	r.encryptionAlgorithmEmpty = &encryptionAlgorithmEmpty
	return r
}

func (r ApiVpnIpsecProposalsListRequest) EncryptionAlgorithmIc(encryptionAlgorithmIc []*string) ApiVpnIpsecProposalsListRequest {
	r.encryptionAlgorithmIc = &encryptionAlgorithmIc
	return r
}

func (r ApiVpnIpsecProposalsListRequest) EncryptionAlgorithmIe(encryptionAlgorithmIe []*string) ApiVpnIpsecProposalsListRequest {
	r.encryptionAlgorithmIe = &encryptionAlgorithmIe
	return r
}

func (r ApiVpnIpsecProposalsListRequest) EncryptionAlgorithmIew(encryptionAlgorithmIew []*string) ApiVpnIpsecProposalsListRequest {
	r.encryptionAlgorithmIew = &encryptionAlgorithmIew
	return r
}

func (r ApiVpnIpsecProposalsListRequest) EncryptionAlgorithmIsw(encryptionAlgorithmIsw []*string) ApiVpnIpsecProposalsListRequest {
	r.encryptionAlgorithmIsw = &encryptionAlgorithmIsw
	return r
}

func (r ApiVpnIpsecProposalsListRequest) EncryptionAlgorithmN(encryptionAlgorithmN []*string) ApiVpnIpsecProposalsListRequest {
	r.encryptionAlgorithmN = &encryptionAlgorithmN
	return r
}

func (r ApiVpnIpsecProposalsListRequest) EncryptionAlgorithmNic(encryptionAlgorithmNic []*string) ApiVpnIpsecProposalsListRequest {
	r.encryptionAlgorithmNic = &encryptionAlgorithmNic
	return r
}

func (r ApiVpnIpsecProposalsListRequest) EncryptionAlgorithmNie(encryptionAlgorithmNie []*string) ApiVpnIpsecProposalsListRequest {
	r.encryptionAlgorithmNie = &encryptionAlgorithmNie
	return r
}

func (r ApiVpnIpsecProposalsListRequest) EncryptionAlgorithmNiew(encryptionAlgorithmNiew []*string) ApiVpnIpsecProposalsListRequest {
	r.encryptionAlgorithmNiew = &encryptionAlgorithmNiew
	return r
}

func (r ApiVpnIpsecProposalsListRequest) EncryptionAlgorithmNisw(encryptionAlgorithmNisw []*string) ApiVpnIpsecProposalsListRequest {
	r.encryptionAlgorithmNisw = &encryptionAlgorithmNisw
	return r
}

func (r ApiVpnIpsecProposalsListRequest) Id(id []int32) ApiVpnIpsecProposalsListRequest {
	r.id = &id
	return r
}

func (r ApiVpnIpsecProposalsListRequest) IdEmpty(idEmpty bool) ApiVpnIpsecProposalsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiVpnIpsecProposalsListRequest) IdGt(idGt []int32) ApiVpnIpsecProposalsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVpnIpsecProposalsListRequest) IdGte(idGte []int32) ApiVpnIpsecProposalsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVpnIpsecProposalsListRequest) IdLt(idLt []int32) ApiVpnIpsecProposalsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVpnIpsecProposalsListRequest) IdLte(idLte []int32) ApiVpnIpsecProposalsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVpnIpsecProposalsListRequest) IdN(idN []int32) ApiVpnIpsecProposalsListRequest {
	r.idN = &idN
	return r
}

// IPSec policy (name)
func (r ApiVpnIpsecProposalsListRequest) IpsecPolicy(ipsecPolicy []string) ApiVpnIpsecProposalsListRequest {
	r.ipsecPolicy = &ipsecPolicy
	return r
}

// IPSec policy (name)
func (r ApiVpnIpsecProposalsListRequest) IpsecPolicyN(ipsecPolicyN []string) ApiVpnIpsecProposalsListRequest {
	r.ipsecPolicyN = &ipsecPolicyN
	return r
}

// IPSec policy (ID)
func (r ApiVpnIpsecProposalsListRequest) IpsecPolicyId(ipsecPolicyId []int32) ApiVpnIpsecProposalsListRequest {
	r.ipsecPolicyId = &ipsecPolicyId
	return r
}

// IPSec policy (ID)
func (r ApiVpnIpsecProposalsListRequest) IpsecPolicyIdN(ipsecPolicyIdN []int32) ApiVpnIpsecProposalsListRequest {
	r.ipsecPolicyIdN = &ipsecPolicyIdN
	return r
}

func (r ApiVpnIpsecProposalsListRequest) LastUpdated(lastUpdated []time.Time) ApiVpnIpsecProposalsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVpnIpsecProposalsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiVpnIpsecProposalsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiVpnIpsecProposalsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiVpnIpsecProposalsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiVpnIpsecProposalsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiVpnIpsecProposalsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVpnIpsecProposalsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiVpnIpsecProposalsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiVpnIpsecProposalsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiVpnIpsecProposalsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVpnIpsecProposalsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiVpnIpsecProposalsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiVpnIpsecProposalsListRequest) Limit(limit int32) ApiVpnIpsecProposalsListRequest {
	r.limit = &limit
	return r
}

func (r ApiVpnIpsecProposalsListRequest) ModifiedByRequest(modifiedByRequest string) ApiVpnIpsecProposalsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiVpnIpsecProposalsListRequest) Name(name []string) ApiVpnIpsecProposalsListRequest {
	r.name = &name
	return r
}

func (r ApiVpnIpsecProposalsListRequest) NameEmpty(nameEmpty bool) ApiVpnIpsecProposalsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVpnIpsecProposalsListRequest) NameIc(nameIc []string) ApiVpnIpsecProposalsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVpnIpsecProposalsListRequest) NameIe(nameIe []string) ApiVpnIpsecProposalsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVpnIpsecProposalsListRequest) NameIew(nameIew []string) ApiVpnIpsecProposalsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVpnIpsecProposalsListRequest) NameIsw(nameIsw []string) ApiVpnIpsecProposalsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVpnIpsecProposalsListRequest) NameN(nameN []string) ApiVpnIpsecProposalsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVpnIpsecProposalsListRequest) NameNic(nameNic []string) ApiVpnIpsecProposalsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVpnIpsecProposalsListRequest) NameNie(nameNie []string) ApiVpnIpsecProposalsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVpnIpsecProposalsListRequest) NameNiew(nameNiew []string) ApiVpnIpsecProposalsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVpnIpsecProposalsListRequest) NameNisw(nameNisw []string) ApiVpnIpsecProposalsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiVpnIpsecProposalsListRequest) Offset(offset int32) ApiVpnIpsecProposalsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiVpnIpsecProposalsListRequest) Ordering(ordering string) ApiVpnIpsecProposalsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiVpnIpsecProposalsListRequest) Q(q string) ApiVpnIpsecProposalsListRequest {
	r.q = &q
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeData(saLifetimeData []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeData = &saLifetimeData
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeDataEmpty(saLifetimeDataEmpty bool) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeDataEmpty = &saLifetimeDataEmpty
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeDataGt(saLifetimeDataGt []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeDataGt = &saLifetimeDataGt
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeDataGte(saLifetimeDataGte []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeDataGte = &saLifetimeDataGte
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeDataLt(saLifetimeDataLt []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeDataLt = &saLifetimeDataLt
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeDataLte(saLifetimeDataLte []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeDataLte = &saLifetimeDataLte
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeDataN(saLifetimeDataN []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeDataN = &saLifetimeDataN
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeSeconds(saLifetimeSeconds []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeSeconds = &saLifetimeSeconds
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeSecondsEmpty(saLifetimeSecondsEmpty bool) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeSecondsEmpty = &saLifetimeSecondsEmpty
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeSecondsGt(saLifetimeSecondsGt []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeSecondsGt = &saLifetimeSecondsGt
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeSecondsGte(saLifetimeSecondsGte []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeSecondsGte = &saLifetimeSecondsGte
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeSecondsLt(saLifetimeSecondsLt []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeSecondsLt = &saLifetimeSecondsLt
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeSecondsLte(saLifetimeSecondsLte []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeSecondsLte = &saLifetimeSecondsLte
	return r
}

func (r ApiVpnIpsecProposalsListRequest) SaLifetimeSecondsN(saLifetimeSecondsN []int32) ApiVpnIpsecProposalsListRequest {
	r.saLifetimeSecondsN = &saLifetimeSecondsN
	return r
}

func (r ApiVpnIpsecProposalsListRequest) Tag(tag []string) ApiVpnIpsecProposalsListRequest {
	r.tag = &tag
	return r
}

func (r ApiVpnIpsecProposalsListRequest) TagN(tagN []string) ApiVpnIpsecProposalsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiVpnIpsecProposalsListRequest) UpdatedByRequest(updatedByRequest string) ApiVpnIpsecProposalsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiVpnIpsecProposalsListRequest) Execute() (*PaginatedIPSecProposalList, *http.Response, error) {
	return r.ApiService.VpnIpsecProposalsListExecute(r)
}

/*
VpnIpsecProposalsList Method for VpnIpsecProposalsList

Get a list of IPSec proposal objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnIpsecProposalsListRequest
*/
func (a *VpnAPIService) VpnIpsecProposalsList(ctx context.Context) ApiVpnIpsecProposalsListRequest {
	return ApiVpnIpsecProposalsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIPSecProposalList
func (a *VpnAPIService) VpnIpsecProposalsListExecute(r ApiVpnIpsecProposalsListRequest) (*PaginatedIPSecProposalList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIPSecProposalList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProposalsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-proposals/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.authenticationAlgorithm != nil {
		t := *r.authenticationAlgorithm
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__empty", r.authenticationAlgorithmEmpty, "form", "")
	}
	if r.authenticationAlgorithmIc != nil {
		t := *r.authenticationAlgorithmIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__ic", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmIe != nil {
		t := *r.authenticationAlgorithmIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__ie", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmIew != nil {
		t := *r.authenticationAlgorithmIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__iew", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmIsw != nil {
		t := *r.authenticationAlgorithmIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__isw", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmN != nil {
		t := *r.authenticationAlgorithmN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__n", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmNic != nil {
		t := *r.authenticationAlgorithmNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nic", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmNie != nil {
		t := *r.authenticationAlgorithmNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nie", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmNiew != nil {
		t := *r.authenticationAlgorithmNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__niew", t, "form", "multi")
		}
	}
	if r.authenticationAlgorithmNisw != nil {
		t := *r.authenticationAlgorithmNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "authentication_algorithm__nisw", t, "form", "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithm != nil {
		t := *r.encryptionAlgorithm
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__empty", r.encryptionAlgorithmEmpty, "form", "")
	}
	if r.encryptionAlgorithmIc != nil {
		t := *r.encryptionAlgorithmIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__ic", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmIe != nil {
		t := *r.encryptionAlgorithmIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__ie", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmIew != nil {
		t := *r.encryptionAlgorithmIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__iew", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmIsw != nil {
		t := *r.encryptionAlgorithmIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__isw", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmN != nil {
		t := *r.encryptionAlgorithmN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__n", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmNic != nil {
		t := *r.encryptionAlgorithmNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nic", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmNie != nil {
		t := *r.encryptionAlgorithmNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nie", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmNiew != nil {
		t := *r.encryptionAlgorithmNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__niew", t, "form", "multi")
		}
	}
	if r.encryptionAlgorithmNisw != nil {
		t := *r.encryptionAlgorithmNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encryption_algorithm__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.ipsecPolicy != nil {
		t := *r.ipsecPolicy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy", t, "form", "multi")
		}
	}
	if r.ipsecPolicyN != nil {
		t := *r.ipsecPolicyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy__n", t, "form", "multi")
		}
	}
	if r.ipsecPolicyId != nil {
		t := *r.ipsecPolicyId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy_id", t, "form", "multi")
		}
	}
	if r.ipsecPolicyIdN != nil {
		t := *r.ipsecPolicyIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_policy_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.saLifetimeData != nil {
		t := *r.saLifetimeData
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data", t, "form", "multi")
		}
	}
	if r.saLifetimeDataEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data__empty", r.saLifetimeDataEmpty, "form", "")
	}
	if r.saLifetimeDataGt != nil {
		t := *r.saLifetimeDataGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data__gt", t, "form", "multi")
		}
	}
	if r.saLifetimeDataGte != nil {
		t := *r.saLifetimeDataGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data__gte", t, "form", "multi")
		}
	}
	if r.saLifetimeDataLt != nil {
		t := *r.saLifetimeDataLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data__lt", t, "form", "multi")
		}
	}
	if r.saLifetimeDataLte != nil {
		t := *r.saLifetimeDataLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data__lte", t, "form", "multi")
		}
	}
	if r.saLifetimeDataN != nil {
		t := *r.saLifetimeDataN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_data__n", t, "form", "multi")
		}
	}
	if r.saLifetimeSeconds != nil {
		t := *r.saLifetimeSeconds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds", t, "form", "multi")
		}
	}
	if r.saLifetimeSecondsEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds__empty", r.saLifetimeSecondsEmpty, "form", "")
	}
	if r.saLifetimeSecondsGt != nil {
		t := *r.saLifetimeSecondsGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds__gt", t, "form", "multi")
		}
	}
	if r.saLifetimeSecondsGte != nil {
		t := *r.saLifetimeSecondsGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds__gte", t, "form", "multi")
		}
	}
	if r.saLifetimeSecondsLt != nil {
		t := *r.saLifetimeSecondsLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds__lt", t, "form", "multi")
		}
	}
	if r.saLifetimeSecondsLte != nil {
		t := *r.saLifetimeSecondsLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds__lte", t, "form", "multi")
		}
	}
	if r.saLifetimeSecondsN != nil {
		t := *r.saLifetimeSecondsN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sa_lifetime_seconds__n", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProposalsPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	patchedWritableIPSecProposalRequest *PatchedWritableIPSecProposalRequest
}

func (r ApiVpnIpsecProposalsPartialUpdateRequest) PatchedWritableIPSecProposalRequest(patchedWritableIPSecProposalRequest PatchedWritableIPSecProposalRequest) ApiVpnIpsecProposalsPartialUpdateRequest {
	r.patchedWritableIPSecProposalRequest = &patchedWritableIPSecProposalRequest
	return r
}

func (r ApiVpnIpsecProposalsPartialUpdateRequest) Execute() (*IPSecProposal, *http.Response, error) {
	return r.ApiService.VpnIpsecProposalsPartialUpdateExecute(r)
}

/*
VpnIpsecProposalsPartialUpdate Method for VpnIpsecProposalsPartialUpdate

Patch a IPSec proposal object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec proposal.
 @return ApiVpnIpsecProposalsPartialUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecProposalsPartialUpdate(ctx context.Context, id int32) ApiVpnIpsecProposalsPartialUpdateRequest {
	return ApiVpnIpsecProposalsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPSecProposal
func (a *VpnAPIService) VpnIpsecProposalsPartialUpdateExecute(r ApiVpnIpsecProposalsPartialUpdateRequest) (*IPSecProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProposalsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-proposals/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableIPSecProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProposalsRetrieveRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnIpsecProposalsRetrieveRequest) Execute() (*IPSecProposal, *http.Response, error) {
	return r.ApiService.VpnIpsecProposalsRetrieveExecute(r)
}

/*
VpnIpsecProposalsRetrieve Method for VpnIpsecProposalsRetrieve

Get a IPSec proposal object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec proposal.
 @return ApiVpnIpsecProposalsRetrieveRequest
*/
func (a *VpnAPIService) VpnIpsecProposalsRetrieve(ctx context.Context, id int32) ApiVpnIpsecProposalsRetrieveRequest {
	return ApiVpnIpsecProposalsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPSecProposal
func (a *VpnAPIService) VpnIpsecProposalsRetrieveExecute(r ApiVpnIpsecProposalsRetrieveRequest) (*IPSecProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProposalsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-proposals/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnIpsecProposalsUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	writableIPSecProposalRequest *WritableIPSecProposalRequest
}

func (r ApiVpnIpsecProposalsUpdateRequest) WritableIPSecProposalRequest(writableIPSecProposalRequest WritableIPSecProposalRequest) ApiVpnIpsecProposalsUpdateRequest {
	r.writableIPSecProposalRequest = &writableIPSecProposalRequest
	return r
}

func (r ApiVpnIpsecProposalsUpdateRequest) Execute() (*IPSecProposal, *http.Response, error) {
	return r.ApiService.VpnIpsecProposalsUpdateExecute(r)
}

/*
VpnIpsecProposalsUpdate Method for VpnIpsecProposalsUpdate

Put a IPSec proposal object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IPSec proposal.
 @return ApiVpnIpsecProposalsUpdateRequest
*/
func (a *VpnAPIService) VpnIpsecProposalsUpdate(ctx context.Context, id int32) ApiVpnIpsecProposalsUpdateRequest {
	return ApiVpnIpsecProposalsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPSecProposal
func (a *VpnAPIService) VpnIpsecProposalsUpdateExecute(r ApiVpnIpsecProposalsUpdateRequest) (*IPSecProposal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPSecProposal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnIpsecProposalsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/ipsec-proposals/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPSecProposalRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPSecProposalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPSecProposalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnTerminationsBulkDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	l2VPNTerminationRequest *[]L2VPNTerminationRequest
}

func (r ApiVpnL2vpnTerminationsBulkDestroyRequest) L2VPNTerminationRequest(l2VPNTerminationRequest []L2VPNTerminationRequest) ApiVpnL2vpnTerminationsBulkDestroyRequest {
	r.l2VPNTerminationRequest = &l2VPNTerminationRequest
	return r
}

func (r ApiVpnL2vpnTerminationsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnL2vpnTerminationsBulkDestroyExecute(r)
}

/*
VpnL2vpnTerminationsBulkDestroy Method for VpnL2vpnTerminationsBulkDestroy

Delete a list of L2VPN termination objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnL2vpnTerminationsBulkDestroyRequest
*/
func (a *VpnAPIService) VpnL2vpnTerminationsBulkDestroy(ctx context.Context) ApiVpnL2vpnTerminationsBulkDestroyRequest {
	return ApiVpnL2vpnTerminationsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnL2vpnTerminationsBulkDestroyExecute(r ApiVpnL2vpnTerminationsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnTerminationsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpn-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.l2VPNTerminationRequest == nil {
		return nil, reportError("l2VPNTerminationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.l2VPNTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnL2vpnTerminationsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	l2VPNTerminationRequest *[]L2VPNTerminationRequest
}

func (r ApiVpnL2vpnTerminationsBulkPartialUpdateRequest) L2VPNTerminationRequest(l2VPNTerminationRequest []L2VPNTerminationRequest) ApiVpnL2vpnTerminationsBulkPartialUpdateRequest {
	r.l2VPNTerminationRequest = &l2VPNTerminationRequest
	return r
}

func (r ApiVpnL2vpnTerminationsBulkPartialUpdateRequest) Execute() ([]L2VPNTermination, *http.Response, error) {
	return r.ApiService.VpnL2vpnTerminationsBulkPartialUpdateExecute(r)
}

/*
VpnL2vpnTerminationsBulkPartialUpdate Method for VpnL2vpnTerminationsBulkPartialUpdate

Patch a list of L2VPN termination objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnL2vpnTerminationsBulkPartialUpdateRequest
*/
func (a *VpnAPIService) VpnL2vpnTerminationsBulkPartialUpdate(ctx context.Context) ApiVpnL2vpnTerminationsBulkPartialUpdateRequest {
	return ApiVpnL2vpnTerminationsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []L2VPNTermination
func (a *VpnAPIService) VpnL2vpnTerminationsBulkPartialUpdateExecute(r ApiVpnL2vpnTerminationsBulkPartialUpdateRequest) ([]L2VPNTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []L2VPNTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnTerminationsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpn-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.l2VPNTerminationRequest == nil {
		return localVarReturnValue, nil, reportError("l2VPNTerminationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.l2VPNTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnTerminationsBulkUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	l2VPNTerminationRequest *[]L2VPNTerminationRequest
}

func (r ApiVpnL2vpnTerminationsBulkUpdateRequest) L2VPNTerminationRequest(l2VPNTerminationRequest []L2VPNTerminationRequest) ApiVpnL2vpnTerminationsBulkUpdateRequest {
	r.l2VPNTerminationRequest = &l2VPNTerminationRequest
	return r
}

func (r ApiVpnL2vpnTerminationsBulkUpdateRequest) Execute() ([]L2VPNTermination, *http.Response, error) {
	return r.ApiService.VpnL2vpnTerminationsBulkUpdateExecute(r)
}

/*
VpnL2vpnTerminationsBulkUpdate Method for VpnL2vpnTerminationsBulkUpdate

Put a list of L2VPN termination objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnL2vpnTerminationsBulkUpdateRequest
*/
func (a *VpnAPIService) VpnL2vpnTerminationsBulkUpdate(ctx context.Context) ApiVpnL2vpnTerminationsBulkUpdateRequest {
	return ApiVpnL2vpnTerminationsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []L2VPNTermination
func (a *VpnAPIService) VpnL2vpnTerminationsBulkUpdateExecute(r ApiVpnL2vpnTerminationsBulkUpdateRequest) ([]L2VPNTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []L2VPNTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnTerminationsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpn-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.l2VPNTerminationRequest == nil {
		return localVarReturnValue, nil, reportError("l2VPNTerminationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.l2VPNTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnTerminationsCreateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	l2VPNTerminationRequest *L2VPNTerminationRequest
}

func (r ApiVpnL2vpnTerminationsCreateRequest) L2VPNTerminationRequest(l2VPNTerminationRequest L2VPNTerminationRequest) ApiVpnL2vpnTerminationsCreateRequest {
	r.l2VPNTerminationRequest = &l2VPNTerminationRequest
	return r
}

func (r ApiVpnL2vpnTerminationsCreateRequest) Execute() (*L2VPNTermination, *http.Response, error) {
	return r.ApiService.VpnL2vpnTerminationsCreateExecute(r)
}

/*
VpnL2vpnTerminationsCreate Method for VpnL2vpnTerminationsCreate

Post a list of L2VPN termination objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnL2vpnTerminationsCreateRequest
*/
func (a *VpnAPIService) VpnL2vpnTerminationsCreate(ctx context.Context) ApiVpnL2vpnTerminationsCreateRequest {
	return ApiVpnL2vpnTerminationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return L2VPNTermination
func (a *VpnAPIService) VpnL2vpnTerminationsCreateExecute(r ApiVpnL2vpnTerminationsCreateRequest) (*L2VPNTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *L2VPNTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnTerminationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpn-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.l2VPNTerminationRequest == nil {
		return localVarReturnValue, nil, reportError("l2VPNTerminationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.l2VPNTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnTerminationsDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnL2vpnTerminationsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnL2vpnTerminationsDestroyExecute(r)
}

/*
VpnL2vpnTerminationsDestroy Method for VpnL2vpnTerminationsDestroy

Delete a L2VPN termination object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this L2VPN termination.
 @return ApiVpnL2vpnTerminationsDestroyRequest
*/
func (a *VpnAPIService) VpnL2vpnTerminationsDestroy(ctx context.Context, id int32) ApiVpnL2vpnTerminationsDestroyRequest {
	return ApiVpnL2vpnTerminationsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnL2vpnTerminationsDestroyExecute(r ApiVpnL2vpnTerminationsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnTerminationsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpn-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnL2vpnTerminationsListRequest struct {
	ctx context.Context
	ApiService VpnAPI
	assignedObjectId *[]int32
	assignedObjectIdEmpty *bool
	assignedObjectIdGt *[]int32
	assignedObjectIdGte *[]int32
	assignedObjectIdLt *[]int32
	assignedObjectIdLte *[]int32
	assignedObjectIdN *[]int32
	assignedObjectType *string
	assignedObjectTypeN *string
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	device *[]*string
	deviceN *[]*string
	deviceId *[]int32
	deviceIdN *[]int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	interface_ *[]string
	interfaceN *[]string
	interfaceId *[]int32
	interfaceIdN *[]int32
	l2vpn *[]string
	l2vpnN *[]string
	l2vpnId *[]int32
	l2vpnIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	offset *int32
	ordering *string
	q *string
	region *[]string
	regionId *[]int32
	site *[]string
	siteId *[]int32
	tag *[]string
	tagN *[]string
	updatedByRequest *string
	virtualMachine *[]string
	virtualMachineN *[]string
	virtualMachineId *[]int32
	virtualMachineIdN *[]int32
	vlan *[]string
	vlanN *[]string
	vlanId *[]int32
	vlanIdN *[]int32
	vlanVid *int32
	vlanVidEmpty *int32
	vlanVidGt *int32
	vlanVidGte *int32
	vlanVidLt *int32
	vlanVidLte *int32
	vlanVidN *int32
	vminterface *[]string
	vminterfaceN *[]string
	vminterfaceId *[]int32
	vminterfaceIdN *[]int32
}

func (r ApiVpnL2vpnTerminationsListRequest) AssignedObjectId(assignedObjectId []int32) ApiVpnL2vpnTerminationsListRequest {
	r.assignedObjectId = &assignedObjectId
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) AssignedObjectIdEmpty(assignedObjectIdEmpty bool) ApiVpnL2vpnTerminationsListRequest {
	r.assignedObjectIdEmpty = &assignedObjectIdEmpty
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) AssignedObjectIdGt(assignedObjectIdGt []int32) ApiVpnL2vpnTerminationsListRequest {
	r.assignedObjectIdGt = &assignedObjectIdGt
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) AssignedObjectIdGte(assignedObjectIdGte []int32) ApiVpnL2vpnTerminationsListRequest {
	r.assignedObjectIdGte = &assignedObjectIdGte
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) AssignedObjectIdLt(assignedObjectIdLt []int32) ApiVpnL2vpnTerminationsListRequest {
	r.assignedObjectIdLt = &assignedObjectIdLt
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) AssignedObjectIdLte(assignedObjectIdLte []int32) ApiVpnL2vpnTerminationsListRequest {
	r.assignedObjectIdLte = &assignedObjectIdLte
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) AssignedObjectIdN(assignedObjectIdN []int32) ApiVpnL2vpnTerminationsListRequest {
	r.assignedObjectIdN = &assignedObjectIdN
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) AssignedObjectType(assignedObjectType string) ApiVpnL2vpnTerminationsListRequest {
	r.assignedObjectType = &assignedObjectType
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) AssignedObjectTypeN(assignedObjectTypeN string) ApiVpnL2vpnTerminationsListRequest {
	r.assignedObjectTypeN = &assignedObjectTypeN
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) Created(created []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.created = &created
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) CreatedGt(createdGt []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) CreatedGte(createdGte []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) CreatedLt(createdLt []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) CreatedLte(createdLte []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) CreatedN(createdN []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) CreatedByRequest(createdByRequest string) ApiVpnL2vpnTerminationsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

// Device (name)
func (r ApiVpnL2vpnTerminationsListRequest) Device(device []*string) ApiVpnL2vpnTerminationsListRequest {
	r.device = &device
	return r
}

// Device (name)
func (r ApiVpnL2vpnTerminationsListRequest) DeviceN(deviceN []*string) ApiVpnL2vpnTerminationsListRequest {
	r.deviceN = &deviceN
	return r
}

// Device (ID)
func (r ApiVpnL2vpnTerminationsListRequest) DeviceId(deviceId []int32) ApiVpnL2vpnTerminationsListRequest {
	r.deviceId = &deviceId
	return r
}

// Device (ID)
func (r ApiVpnL2vpnTerminationsListRequest) DeviceIdN(deviceIdN []int32) ApiVpnL2vpnTerminationsListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) Id(id []int32) ApiVpnL2vpnTerminationsListRequest {
	r.id = &id
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) IdEmpty(idEmpty bool) ApiVpnL2vpnTerminationsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) IdGt(idGt []int32) ApiVpnL2vpnTerminationsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) IdGte(idGte []int32) ApiVpnL2vpnTerminationsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) IdLt(idLt []int32) ApiVpnL2vpnTerminationsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) IdLte(idLte []int32) ApiVpnL2vpnTerminationsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) IdN(idN []int32) ApiVpnL2vpnTerminationsListRequest {
	r.idN = &idN
	return r
}

// Interface (name)
func (r ApiVpnL2vpnTerminationsListRequest) Interface_(interface_ []string) ApiVpnL2vpnTerminationsListRequest {
	r.interface_ = &interface_
	return r
}

// Interface (name)
func (r ApiVpnL2vpnTerminationsListRequest) InterfaceN(interfaceN []string) ApiVpnL2vpnTerminationsListRequest {
	r.interfaceN = &interfaceN
	return r
}

// Interface (ID)
func (r ApiVpnL2vpnTerminationsListRequest) InterfaceId(interfaceId []int32) ApiVpnL2vpnTerminationsListRequest {
	r.interfaceId = &interfaceId
	return r
}

// Interface (ID)
func (r ApiVpnL2vpnTerminationsListRequest) InterfaceIdN(interfaceIdN []int32) ApiVpnL2vpnTerminationsListRequest {
	r.interfaceIdN = &interfaceIdN
	return r
}

// L2VPN (slug)
func (r ApiVpnL2vpnTerminationsListRequest) L2vpn(l2vpn []string) ApiVpnL2vpnTerminationsListRequest {
	r.l2vpn = &l2vpn
	return r
}

// L2VPN (slug)
func (r ApiVpnL2vpnTerminationsListRequest) L2vpnN(l2vpnN []string) ApiVpnL2vpnTerminationsListRequest {
	r.l2vpnN = &l2vpnN
	return r
}

// L2VPN (ID)
func (r ApiVpnL2vpnTerminationsListRequest) L2vpnId(l2vpnId []int32) ApiVpnL2vpnTerminationsListRequest {
	r.l2vpnId = &l2vpnId
	return r
}

// L2VPN (ID)
func (r ApiVpnL2vpnTerminationsListRequest) L2vpnIdN(l2vpnIdN []int32) ApiVpnL2vpnTerminationsListRequest {
	r.l2vpnIdN = &l2vpnIdN
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) LastUpdated(lastUpdated []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiVpnL2vpnTerminationsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiVpnL2vpnTerminationsListRequest) Limit(limit int32) ApiVpnL2vpnTerminationsListRequest {
	r.limit = &limit
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) ModifiedByRequest(modifiedByRequest string) ApiVpnL2vpnTerminationsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiVpnL2vpnTerminationsListRequest) Offset(offset int32) ApiVpnL2vpnTerminationsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiVpnL2vpnTerminationsListRequest) Ordering(ordering string) ApiVpnL2vpnTerminationsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiVpnL2vpnTerminationsListRequest) Q(q string) ApiVpnL2vpnTerminationsListRequest {
	r.q = &q
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) Region(region []string) ApiVpnL2vpnTerminationsListRequest {
	r.region = &region
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) RegionId(regionId []int32) ApiVpnL2vpnTerminationsListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) Site(site []string) ApiVpnL2vpnTerminationsListRequest {
	r.site = &site
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) SiteId(siteId []int32) ApiVpnL2vpnTerminationsListRequest {
	r.siteId = &siteId
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) Tag(tag []string) ApiVpnL2vpnTerminationsListRequest {
	r.tag = &tag
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) TagN(tagN []string) ApiVpnL2vpnTerminationsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) UpdatedByRequest(updatedByRequest string) ApiVpnL2vpnTerminationsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

// Virtual machine (name)
func (r ApiVpnL2vpnTerminationsListRequest) VirtualMachine(virtualMachine []string) ApiVpnL2vpnTerminationsListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

// Virtual machine (name)
func (r ApiVpnL2vpnTerminationsListRequest) VirtualMachineN(virtualMachineN []string) ApiVpnL2vpnTerminationsListRequest {
	r.virtualMachineN = &virtualMachineN
	return r
}

// Virtual machine (ID)
func (r ApiVpnL2vpnTerminationsListRequest) VirtualMachineId(virtualMachineId []int32) ApiVpnL2vpnTerminationsListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

// Virtual machine (ID)
func (r ApiVpnL2vpnTerminationsListRequest) VirtualMachineIdN(virtualMachineIdN []int32) ApiVpnL2vpnTerminationsListRequest {
	r.virtualMachineIdN = &virtualMachineIdN
	return r
}

// VLAN (name)
func (r ApiVpnL2vpnTerminationsListRequest) Vlan(vlan []string) ApiVpnL2vpnTerminationsListRequest {
	r.vlan = &vlan
	return r
}

// VLAN (name)
func (r ApiVpnL2vpnTerminationsListRequest) VlanN(vlanN []string) ApiVpnL2vpnTerminationsListRequest {
	r.vlanN = &vlanN
	return r
}

// VLAN (ID)
func (r ApiVpnL2vpnTerminationsListRequest) VlanId(vlanId []int32) ApiVpnL2vpnTerminationsListRequest {
	r.vlanId = &vlanId
	return r
}

// VLAN (ID)
func (r ApiVpnL2vpnTerminationsListRequest) VlanIdN(vlanIdN []int32) ApiVpnL2vpnTerminationsListRequest {
	r.vlanIdN = &vlanIdN
	return r
}

// VLAN number (1-4094)
func (r ApiVpnL2vpnTerminationsListRequest) VlanVid(vlanVid int32) ApiVpnL2vpnTerminationsListRequest {
	r.vlanVid = &vlanVid
	return r
}

// VLAN number (1-4094)
func (r ApiVpnL2vpnTerminationsListRequest) VlanVidEmpty(vlanVidEmpty int32) ApiVpnL2vpnTerminationsListRequest {
	r.vlanVidEmpty = &vlanVidEmpty
	return r
}

// VLAN number (1-4094)
func (r ApiVpnL2vpnTerminationsListRequest) VlanVidGt(vlanVidGt int32) ApiVpnL2vpnTerminationsListRequest {
	r.vlanVidGt = &vlanVidGt
	return r
}

// VLAN number (1-4094)
func (r ApiVpnL2vpnTerminationsListRequest) VlanVidGte(vlanVidGte int32) ApiVpnL2vpnTerminationsListRequest {
	r.vlanVidGte = &vlanVidGte
	return r
}

// VLAN number (1-4094)
func (r ApiVpnL2vpnTerminationsListRequest) VlanVidLt(vlanVidLt int32) ApiVpnL2vpnTerminationsListRequest {
	r.vlanVidLt = &vlanVidLt
	return r
}

// VLAN number (1-4094)
func (r ApiVpnL2vpnTerminationsListRequest) VlanVidLte(vlanVidLte int32) ApiVpnL2vpnTerminationsListRequest {
	r.vlanVidLte = &vlanVidLte
	return r
}

// VLAN number (1-4094)
func (r ApiVpnL2vpnTerminationsListRequest) VlanVidN(vlanVidN int32) ApiVpnL2vpnTerminationsListRequest {
	r.vlanVidN = &vlanVidN
	return r
}

// VM interface (name)
func (r ApiVpnL2vpnTerminationsListRequest) Vminterface(vminterface []string) ApiVpnL2vpnTerminationsListRequest {
	r.vminterface = &vminterface
	return r
}

// VM interface (name)
func (r ApiVpnL2vpnTerminationsListRequest) VminterfaceN(vminterfaceN []string) ApiVpnL2vpnTerminationsListRequest {
	r.vminterfaceN = &vminterfaceN
	return r
}

// VM Interface (ID)
func (r ApiVpnL2vpnTerminationsListRequest) VminterfaceId(vminterfaceId []int32) ApiVpnL2vpnTerminationsListRequest {
	r.vminterfaceId = &vminterfaceId
	return r
}

// VM Interface (ID)
func (r ApiVpnL2vpnTerminationsListRequest) VminterfaceIdN(vminterfaceIdN []int32) ApiVpnL2vpnTerminationsListRequest {
	r.vminterfaceIdN = &vminterfaceIdN
	return r
}

func (r ApiVpnL2vpnTerminationsListRequest) Execute() (*PaginatedL2VPNTerminationList, *http.Response, error) {
	return r.ApiService.VpnL2vpnTerminationsListExecute(r)
}

/*
VpnL2vpnTerminationsList Method for VpnL2vpnTerminationsList

Get a list of L2VPN termination objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnL2vpnTerminationsListRequest
*/
func (a *VpnAPIService) VpnL2vpnTerminationsList(ctx context.Context) ApiVpnL2vpnTerminationsListRequest {
	return ApiVpnL2vpnTerminationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedL2VPNTerminationList
func (a *VpnAPIService) VpnL2vpnTerminationsListExecute(r ApiVpnL2vpnTerminationsListRequest) (*PaginatedL2VPNTerminationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedL2VPNTerminationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnTerminationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpn-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.assignedObjectId != nil {
		t := *r.assignedObjectId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id", t, "form", "multi")
		}
	}
	if r.assignedObjectIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__empty", r.assignedObjectIdEmpty, "form", "")
	}
	if r.assignedObjectIdGt != nil {
		t := *r.assignedObjectIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gt", t, "form", "multi")
		}
	}
	if r.assignedObjectIdGte != nil {
		t := *r.assignedObjectIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gte", t, "form", "multi")
		}
	}
	if r.assignedObjectIdLt != nil {
		t := *r.assignedObjectIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lt", t, "form", "multi")
		}
	}
	if r.assignedObjectIdLte != nil {
		t := *r.assignedObjectIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lte", t, "form", "multi")
		}
	}
	if r.assignedObjectIdN != nil {
		t := *r.assignedObjectIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__n", t, "form", "multi")
		}
	}
	if r.assignedObjectType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_type", r.assignedObjectType, "form", "")
	}
	if r.assignedObjectTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_type__n", r.assignedObjectTypeN, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "form", "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "form", "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "form", "multi")
		}
	}
	if r.deviceIdN != nil {
		t := *r.deviceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.interface_ != nil {
		t := *r.interface_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface", t, "form", "multi")
		}
	}
	if r.interfaceN != nil {
		t := *r.interfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", t, "form", "multi")
		}
	}
	if r.interfaceId != nil {
		t := *r.interfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", t, "form", "multi")
		}
	}
	if r.interfaceIdN != nil {
		t := *r.interfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", t, "form", "multi")
		}
	}
	if r.l2vpn != nil {
		t := *r.l2vpn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn", t, "form", "multi")
		}
	}
	if r.l2vpnN != nil {
		t := *r.l2vpnN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn__n", t, "form", "multi")
		}
	}
	if r.l2vpnId != nil {
		t := *r.l2vpnId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id", t, "form", "multi")
		}
	}
	if r.l2vpnIdN != nil {
		t := *r.l2vpnIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.region != nil {
		t := *r.region
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region", t, "form", "multi")
		}
	}
	if r.regionId != nil {
		t := *r.regionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region_id", t, "form", "multi")
		}
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site", t, "form", "multi")
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", t, "form", "multi")
		}
	}
	if r.virtualMachineN != nil {
		t := *r.virtualMachineN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__n", t, "form", "multi")
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", t, "form", "multi")
		}
	}
	if r.virtualMachineIdN != nil {
		t := *r.virtualMachineIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id__n", t, "form", "multi")
		}
	}
	if r.vlan != nil {
		t := *r.vlan
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan", t, "form", "multi")
		}
	}
	if r.vlanN != nil {
		t := *r.vlanN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan__n", t, "form", "multi")
		}
	}
	if r.vlanId != nil {
		t := *r.vlanId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id", t, "form", "multi")
		}
	}
	if r.vlanIdN != nil {
		t := *r.vlanIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id__n", t, "form", "multi")
		}
	}
	if r.vlanVid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid", r.vlanVid, "form", "")
	}
	if r.vlanVidEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__empty", r.vlanVidEmpty, "form", "")
	}
	if r.vlanVidGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__gt", r.vlanVidGt, "form", "")
	}
	if r.vlanVidGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__gte", r.vlanVidGte, "form", "")
	}
	if r.vlanVidLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__lt", r.vlanVidLt, "form", "")
	}
	if r.vlanVidLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__lte", r.vlanVidLte, "form", "")
	}
	if r.vlanVidN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__n", r.vlanVidN, "form", "")
	}
	if r.vminterface != nil {
		t := *r.vminterface
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface", t, "form", "multi")
		}
	}
	if r.vminterfaceN != nil {
		t := *r.vminterfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface__n", t, "form", "multi")
		}
	}
	if r.vminterfaceId != nil {
		t := *r.vminterfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id", t, "form", "multi")
		}
	}
	if r.vminterfaceIdN != nil {
		t := *r.vminterfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id__n", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnTerminationsPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	patchedL2VPNTerminationRequest *PatchedL2VPNTerminationRequest
}

func (r ApiVpnL2vpnTerminationsPartialUpdateRequest) PatchedL2VPNTerminationRequest(patchedL2VPNTerminationRequest PatchedL2VPNTerminationRequest) ApiVpnL2vpnTerminationsPartialUpdateRequest {
	r.patchedL2VPNTerminationRequest = &patchedL2VPNTerminationRequest
	return r
}

func (r ApiVpnL2vpnTerminationsPartialUpdateRequest) Execute() (*L2VPNTermination, *http.Response, error) {
	return r.ApiService.VpnL2vpnTerminationsPartialUpdateExecute(r)
}

/*
VpnL2vpnTerminationsPartialUpdate Method for VpnL2vpnTerminationsPartialUpdate

Patch a L2VPN termination object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this L2VPN termination.
 @return ApiVpnL2vpnTerminationsPartialUpdateRequest
*/
func (a *VpnAPIService) VpnL2vpnTerminationsPartialUpdate(ctx context.Context, id int32) ApiVpnL2vpnTerminationsPartialUpdateRequest {
	return ApiVpnL2vpnTerminationsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return L2VPNTermination
func (a *VpnAPIService) VpnL2vpnTerminationsPartialUpdateExecute(r ApiVpnL2vpnTerminationsPartialUpdateRequest) (*L2VPNTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *L2VPNTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnTerminationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpn-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedL2VPNTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnTerminationsRetrieveRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnL2vpnTerminationsRetrieveRequest) Execute() (*L2VPNTermination, *http.Response, error) {
	return r.ApiService.VpnL2vpnTerminationsRetrieveExecute(r)
}

/*
VpnL2vpnTerminationsRetrieve Method for VpnL2vpnTerminationsRetrieve

Get a L2VPN termination object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this L2VPN termination.
 @return ApiVpnL2vpnTerminationsRetrieveRequest
*/
func (a *VpnAPIService) VpnL2vpnTerminationsRetrieve(ctx context.Context, id int32) ApiVpnL2vpnTerminationsRetrieveRequest {
	return ApiVpnL2vpnTerminationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return L2VPNTermination
func (a *VpnAPIService) VpnL2vpnTerminationsRetrieveExecute(r ApiVpnL2vpnTerminationsRetrieveRequest) (*L2VPNTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *L2VPNTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnTerminationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpn-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnTerminationsUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	l2VPNTerminationRequest *L2VPNTerminationRequest
}

func (r ApiVpnL2vpnTerminationsUpdateRequest) L2VPNTerminationRequest(l2VPNTerminationRequest L2VPNTerminationRequest) ApiVpnL2vpnTerminationsUpdateRequest {
	r.l2VPNTerminationRequest = &l2VPNTerminationRequest
	return r
}

func (r ApiVpnL2vpnTerminationsUpdateRequest) Execute() (*L2VPNTermination, *http.Response, error) {
	return r.ApiService.VpnL2vpnTerminationsUpdateExecute(r)
}

/*
VpnL2vpnTerminationsUpdate Method for VpnL2vpnTerminationsUpdate

Put a L2VPN termination object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this L2VPN termination.
 @return ApiVpnL2vpnTerminationsUpdateRequest
*/
func (a *VpnAPIService) VpnL2vpnTerminationsUpdate(ctx context.Context, id int32) ApiVpnL2vpnTerminationsUpdateRequest {
	return ApiVpnL2vpnTerminationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return L2VPNTermination
func (a *VpnAPIService) VpnL2vpnTerminationsUpdateExecute(r ApiVpnL2vpnTerminationsUpdateRequest) (*L2VPNTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *L2VPNTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnTerminationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpn-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.l2VPNTerminationRequest == nil {
		return localVarReturnValue, nil, reportError("l2VPNTerminationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.l2VPNTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnsBulkDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	l2VPNRequest *[]L2VPNRequest
}

func (r ApiVpnL2vpnsBulkDestroyRequest) L2VPNRequest(l2VPNRequest []L2VPNRequest) ApiVpnL2vpnsBulkDestroyRequest {
	r.l2VPNRequest = &l2VPNRequest
	return r
}

func (r ApiVpnL2vpnsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnL2vpnsBulkDestroyExecute(r)
}

/*
VpnL2vpnsBulkDestroy Method for VpnL2vpnsBulkDestroy

Delete a list of L2VPN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnL2vpnsBulkDestroyRequest
*/
func (a *VpnAPIService) VpnL2vpnsBulkDestroy(ctx context.Context) ApiVpnL2vpnsBulkDestroyRequest {
	return ApiVpnL2vpnsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnL2vpnsBulkDestroyExecute(r ApiVpnL2vpnsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.l2VPNRequest == nil {
		return nil, reportError("l2VPNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.l2VPNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnL2vpnsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	l2VPNRequest *[]L2VPNRequest
}

func (r ApiVpnL2vpnsBulkPartialUpdateRequest) L2VPNRequest(l2VPNRequest []L2VPNRequest) ApiVpnL2vpnsBulkPartialUpdateRequest {
	r.l2VPNRequest = &l2VPNRequest
	return r
}

func (r ApiVpnL2vpnsBulkPartialUpdateRequest) Execute() ([]L2VPN, *http.Response, error) {
	return r.ApiService.VpnL2vpnsBulkPartialUpdateExecute(r)
}

/*
VpnL2vpnsBulkPartialUpdate Method for VpnL2vpnsBulkPartialUpdate

Patch a list of L2VPN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnL2vpnsBulkPartialUpdateRequest
*/
func (a *VpnAPIService) VpnL2vpnsBulkPartialUpdate(ctx context.Context) ApiVpnL2vpnsBulkPartialUpdateRequest {
	return ApiVpnL2vpnsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []L2VPN
func (a *VpnAPIService) VpnL2vpnsBulkPartialUpdateExecute(r ApiVpnL2vpnsBulkPartialUpdateRequest) ([]L2VPN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []L2VPN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.l2VPNRequest == nil {
		return localVarReturnValue, nil, reportError("l2VPNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.l2VPNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnsBulkUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	l2VPNRequest *[]L2VPNRequest
}

func (r ApiVpnL2vpnsBulkUpdateRequest) L2VPNRequest(l2VPNRequest []L2VPNRequest) ApiVpnL2vpnsBulkUpdateRequest {
	r.l2VPNRequest = &l2VPNRequest
	return r
}

func (r ApiVpnL2vpnsBulkUpdateRequest) Execute() ([]L2VPN, *http.Response, error) {
	return r.ApiService.VpnL2vpnsBulkUpdateExecute(r)
}

/*
VpnL2vpnsBulkUpdate Method for VpnL2vpnsBulkUpdate

Put a list of L2VPN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnL2vpnsBulkUpdateRequest
*/
func (a *VpnAPIService) VpnL2vpnsBulkUpdate(ctx context.Context) ApiVpnL2vpnsBulkUpdateRequest {
	return ApiVpnL2vpnsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []L2VPN
func (a *VpnAPIService) VpnL2vpnsBulkUpdateExecute(r ApiVpnL2vpnsBulkUpdateRequest) ([]L2VPN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []L2VPN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.l2VPNRequest == nil {
		return localVarReturnValue, nil, reportError("l2VPNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.l2VPNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnsCreateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	writableL2VPNRequest *WritableL2VPNRequest
}

func (r ApiVpnL2vpnsCreateRequest) WritableL2VPNRequest(writableL2VPNRequest WritableL2VPNRequest) ApiVpnL2vpnsCreateRequest {
	r.writableL2VPNRequest = &writableL2VPNRequest
	return r
}

func (r ApiVpnL2vpnsCreateRequest) Execute() (*L2VPN, *http.Response, error) {
	return r.ApiService.VpnL2vpnsCreateExecute(r)
}

/*
VpnL2vpnsCreate Method for VpnL2vpnsCreate

Post a list of L2VPN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnL2vpnsCreateRequest
*/
func (a *VpnAPIService) VpnL2vpnsCreate(ctx context.Context) ApiVpnL2vpnsCreateRequest {
	return ApiVpnL2vpnsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return L2VPN
func (a *VpnAPIService) VpnL2vpnsCreateExecute(r ApiVpnL2vpnsCreateRequest) (*L2VPN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *L2VPN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableL2VPNRequest == nil {
		return localVarReturnValue, nil, reportError("writableL2VPNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableL2VPNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnsDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnL2vpnsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnL2vpnsDestroyExecute(r)
}

/*
VpnL2vpnsDestroy Method for VpnL2vpnsDestroy

Delete a L2VPN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this L2VPN.
 @return ApiVpnL2vpnsDestroyRequest
*/
func (a *VpnAPIService) VpnL2vpnsDestroy(ctx context.Context, id int32) ApiVpnL2vpnsDestroyRequest {
	return ApiVpnL2vpnsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnL2vpnsDestroyExecute(r ApiVpnL2vpnsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnL2vpnsListRequest struct {
	ctx context.Context
	ApiService VpnAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	exportTarget *[]string
	exportTargetN *[]string
	exportTargetId *[]int32
	exportTargetIdN *[]int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	identifier *[]int32
	identifierEmpty *bool
	identifierGt *[]int32
	identifierGte *[]int32
	identifierLt *[]int32
	identifierLte *[]int32
	identifierN *[]int32
	importTarget *[]string
	importTargetN *[]string
	importTargetId *[]int32
	importTargetIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	slug *[]string
	slugEmpty *bool
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNisw *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*int32
	tenantIdN *[]*int32
	type_ *[]string
	typeEmpty *bool
	typeIc *[]string
	typeIe *[]string
	typeIew *[]string
	typeIsw *[]string
	typeN *[]string
	typeNic *[]string
	typeNie *[]string
	typeNiew *[]string
	typeNisw *[]string
	updatedByRequest *string
}

func (r ApiVpnL2vpnsListRequest) Created(created []time.Time) ApiVpnL2vpnsListRequest {
	r.created = &created
	return r
}

func (r ApiVpnL2vpnsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiVpnL2vpnsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiVpnL2vpnsListRequest) CreatedGt(createdGt []time.Time) ApiVpnL2vpnsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiVpnL2vpnsListRequest) CreatedGte(createdGte []time.Time) ApiVpnL2vpnsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVpnL2vpnsListRequest) CreatedLt(createdLt []time.Time) ApiVpnL2vpnsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiVpnL2vpnsListRequest) CreatedLte(createdLte []time.Time) ApiVpnL2vpnsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVpnL2vpnsListRequest) CreatedN(createdN []time.Time) ApiVpnL2vpnsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiVpnL2vpnsListRequest) CreatedByRequest(createdByRequest string) ApiVpnL2vpnsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiVpnL2vpnsListRequest) Description(description []string) ApiVpnL2vpnsListRequest {
	r.description = &description
	return r
}

func (r ApiVpnL2vpnsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiVpnL2vpnsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiVpnL2vpnsListRequest) DescriptionIc(descriptionIc []string) ApiVpnL2vpnsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiVpnL2vpnsListRequest) DescriptionIe(descriptionIe []string) ApiVpnL2vpnsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiVpnL2vpnsListRequest) DescriptionIew(descriptionIew []string) ApiVpnL2vpnsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiVpnL2vpnsListRequest) DescriptionIsw(descriptionIsw []string) ApiVpnL2vpnsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiVpnL2vpnsListRequest) DescriptionN(descriptionN []string) ApiVpnL2vpnsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiVpnL2vpnsListRequest) DescriptionNic(descriptionNic []string) ApiVpnL2vpnsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiVpnL2vpnsListRequest) DescriptionNie(descriptionNie []string) ApiVpnL2vpnsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiVpnL2vpnsListRequest) DescriptionNiew(descriptionNiew []string) ApiVpnL2vpnsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiVpnL2vpnsListRequest) DescriptionNisw(descriptionNisw []string) ApiVpnL2vpnsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Export target (name)
func (r ApiVpnL2vpnsListRequest) ExportTarget(exportTarget []string) ApiVpnL2vpnsListRequest {
	r.exportTarget = &exportTarget
	return r
}

// Export target (name)
func (r ApiVpnL2vpnsListRequest) ExportTargetN(exportTargetN []string) ApiVpnL2vpnsListRequest {
	r.exportTargetN = &exportTargetN
	return r
}

// Export target
func (r ApiVpnL2vpnsListRequest) ExportTargetId(exportTargetId []int32) ApiVpnL2vpnsListRequest {
	r.exportTargetId = &exportTargetId
	return r
}

// Export target
func (r ApiVpnL2vpnsListRequest) ExportTargetIdN(exportTargetIdN []int32) ApiVpnL2vpnsListRequest {
	r.exportTargetIdN = &exportTargetIdN
	return r
}

func (r ApiVpnL2vpnsListRequest) Id(id []int32) ApiVpnL2vpnsListRequest {
	r.id = &id
	return r
}

func (r ApiVpnL2vpnsListRequest) IdEmpty(idEmpty bool) ApiVpnL2vpnsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiVpnL2vpnsListRequest) IdGt(idGt []int32) ApiVpnL2vpnsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVpnL2vpnsListRequest) IdGte(idGte []int32) ApiVpnL2vpnsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVpnL2vpnsListRequest) IdLt(idLt []int32) ApiVpnL2vpnsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVpnL2vpnsListRequest) IdLte(idLte []int32) ApiVpnL2vpnsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVpnL2vpnsListRequest) IdN(idN []int32) ApiVpnL2vpnsListRequest {
	r.idN = &idN
	return r
}

func (r ApiVpnL2vpnsListRequest) Identifier(identifier []int32) ApiVpnL2vpnsListRequest {
	r.identifier = &identifier
	return r
}

func (r ApiVpnL2vpnsListRequest) IdentifierEmpty(identifierEmpty bool) ApiVpnL2vpnsListRequest {
	r.identifierEmpty = &identifierEmpty
	return r
}

func (r ApiVpnL2vpnsListRequest) IdentifierGt(identifierGt []int32) ApiVpnL2vpnsListRequest {
	r.identifierGt = &identifierGt
	return r
}

func (r ApiVpnL2vpnsListRequest) IdentifierGte(identifierGte []int32) ApiVpnL2vpnsListRequest {
	r.identifierGte = &identifierGte
	return r
}

func (r ApiVpnL2vpnsListRequest) IdentifierLt(identifierLt []int32) ApiVpnL2vpnsListRequest {
	r.identifierLt = &identifierLt
	return r
}

func (r ApiVpnL2vpnsListRequest) IdentifierLte(identifierLte []int32) ApiVpnL2vpnsListRequest {
	r.identifierLte = &identifierLte
	return r
}

func (r ApiVpnL2vpnsListRequest) IdentifierN(identifierN []int32) ApiVpnL2vpnsListRequest {
	r.identifierN = &identifierN
	return r
}

// Import target (name)
func (r ApiVpnL2vpnsListRequest) ImportTarget(importTarget []string) ApiVpnL2vpnsListRequest {
	r.importTarget = &importTarget
	return r
}

// Import target (name)
func (r ApiVpnL2vpnsListRequest) ImportTargetN(importTargetN []string) ApiVpnL2vpnsListRequest {
	r.importTargetN = &importTargetN
	return r
}

// Import target
func (r ApiVpnL2vpnsListRequest) ImportTargetId(importTargetId []int32) ApiVpnL2vpnsListRequest {
	r.importTargetId = &importTargetId
	return r
}

// Import target
func (r ApiVpnL2vpnsListRequest) ImportTargetIdN(importTargetIdN []int32) ApiVpnL2vpnsListRequest {
	r.importTargetIdN = &importTargetIdN
	return r
}

func (r ApiVpnL2vpnsListRequest) LastUpdated(lastUpdated []time.Time) ApiVpnL2vpnsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVpnL2vpnsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiVpnL2vpnsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiVpnL2vpnsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiVpnL2vpnsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiVpnL2vpnsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiVpnL2vpnsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVpnL2vpnsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiVpnL2vpnsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiVpnL2vpnsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiVpnL2vpnsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVpnL2vpnsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiVpnL2vpnsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiVpnL2vpnsListRequest) Limit(limit int32) ApiVpnL2vpnsListRequest {
	r.limit = &limit
	return r
}

func (r ApiVpnL2vpnsListRequest) ModifiedByRequest(modifiedByRequest string) ApiVpnL2vpnsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiVpnL2vpnsListRequest) Name(name []string) ApiVpnL2vpnsListRequest {
	r.name = &name
	return r
}

func (r ApiVpnL2vpnsListRequest) NameEmpty(nameEmpty bool) ApiVpnL2vpnsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVpnL2vpnsListRequest) NameIc(nameIc []string) ApiVpnL2vpnsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVpnL2vpnsListRequest) NameIe(nameIe []string) ApiVpnL2vpnsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVpnL2vpnsListRequest) NameIew(nameIew []string) ApiVpnL2vpnsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVpnL2vpnsListRequest) NameIsw(nameIsw []string) ApiVpnL2vpnsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVpnL2vpnsListRequest) NameN(nameN []string) ApiVpnL2vpnsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVpnL2vpnsListRequest) NameNic(nameNic []string) ApiVpnL2vpnsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVpnL2vpnsListRequest) NameNie(nameNie []string) ApiVpnL2vpnsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVpnL2vpnsListRequest) NameNiew(nameNiew []string) ApiVpnL2vpnsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVpnL2vpnsListRequest) NameNisw(nameNisw []string) ApiVpnL2vpnsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiVpnL2vpnsListRequest) Offset(offset int32) ApiVpnL2vpnsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiVpnL2vpnsListRequest) Ordering(ordering string) ApiVpnL2vpnsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiVpnL2vpnsListRequest) Q(q string) ApiVpnL2vpnsListRequest {
	r.q = &q
	return r
}

func (r ApiVpnL2vpnsListRequest) Slug(slug []string) ApiVpnL2vpnsListRequest {
	r.slug = &slug
	return r
}

func (r ApiVpnL2vpnsListRequest) SlugEmpty(slugEmpty bool) ApiVpnL2vpnsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiVpnL2vpnsListRequest) SlugIc(slugIc []string) ApiVpnL2vpnsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiVpnL2vpnsListRequest) SlugIe(slugIe []string) ApiVpnL2vpnsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiVpnL2vpnsListRequest) SlugIew(slugIew []string) ApiVpnL2vpnsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiVpnL2vpnsListRequest) SlugIsw(slugIsw []string) ApiVpnL2vpnsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiVpnL2vpnsListRequest) SlugN(slugN []string) ApiVpnL2vpnsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiVpnL2vpnsListRequest) SlugNic(slugNic []string) ApiVpnL2vpnsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiVpnL2vpnsListRequest) SlugNie(slugNie []string) ApiVpnL2vpnsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiVpnL2vpnsListRequest) SlugNiew(slugNiew []string) ApiVpnL2vpnsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiVpnL2vpnsListRequest) SlugNisw(slugNisw []string) ApiVpnL2vpnsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiVpnL2vpnsListRequest) Tag(tag []string) ApiVpnL2vpnsListRequest {
	r.tag = &tag
	return r
}

func (r ApiVpnL2vpnsListRequest) TagN(tagN []string) ApiVpnL2vpnsListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiVpnL2vpnsListRequest) Tenant(tenant []string) ApiVpnL2vpnsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiVpnL2vpnsListRequest) TenantN(tenantN []string) ApiVpnL2vpnsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiVpnL2vpnsListRequest) TenantGroup(tenantGroup []string) ApiVpnL2vpnsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiVpnL2vpnsListRequest) TenantGroupN(tenantGroupN []string) ApiVpnL2vpnsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiVpnL2vpnsListRequest) TenantGroupId(tenantGroupId []string) ApiVpnL2vpnsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiVpnL2vpnsListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiVpnL2vpnsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiVpnL2vpnsListRequest) TenantId(tenantId []*int32) ApiVpnL2vpnsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiVpnL2vpnsListRequest) TenantIdN(tenantIdN []*int32) ApiVpnL2vpnsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiVpnL2vpnsListRequest) Type_(type_ []string) ApiVpnL2vpnsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiVpnL2vpnsListRequest) TypeEmpty(typeEmpty bool) ApiVpnL2vpnsListRequest {
	r.typeEmpty = &typeEmpty
	return r
}

func (r ApiVpnL2vpnsListRequest) TypeIc(typeIc []string) ApiVpnL2vpnsListRequest {
	r.typeIc = &typeIc
	return r
}

func (r ApiVpnL2vpnsListRequest) TypeIe(typeIe []string) ApiVpnL2vpnsListRequest {
	r.typeIe = &typeIe
	return r
}

func (r ApiVpnL2vpnsListRequest) TypeIew(typeIew []string) ApiVpnL2vpnsListRequest {
	r.typeIew = &typeIew
	return r
}

func (r ApiVpnL2vpnsListRequest) TypeIsw(typeIsw []string) ApiVpnL2vpnsListRequest {
	r.typeIsw = &typeIsw
	return r
}

func (r ApiVpnL2vpnsListRequest) TypeN(typeN []string) ApiVpnL2vpnsListRequest {
	r.typeN = &typeN
	return r
}

func (r ApiVpnL2vpnsListRequest) TypeNic(typeNic []string) ApiVpnL2vpnsListRequest {
	r.typeNic = &typeNic
	return r
}

func (r ApiVpnL2vpnsListRequest) TypeNie(typeNie []string) ApiVpnL2vpnsListRequest {
	r.typeNie = &typeNie
	return r
}

func (r ApiVpnL2vpnsListRequest) TypeNiew(typeNiew []string) ApiVpnL2vpnsListRequest {
	r.typeNiew = &typeNiew
	return r
}

func (r ApiVpnL2vpnsListRequest) TypeNisw(typeNisw []string) ApiVpnL2vpnsListRequest {
	r.typeNisw = &typeNisw
	return r
}

func (r ApiVpnL2vpnsListRequest) UpdatedByRequest(updatedByRequest string) ApiVpnL2vpnsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiVpnL2vpnsListRequest) Execute() (*PaginatedL2VPNList, *http.Response, error) {
	return r.ApiService.VpnL2vpnsListExecute(r)
}

/*
VpnL2vpnsList Method for VpnL2vpnsList

Get a list of L2VPN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnL2vpnsListRequest
*/
func (a *VpnAPIService) VpnL2vpnsList(ctx context.Context) ApiVpnL2vpnsListRequest {
	return ApiVpnL2vpnsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedL2VPNList
func (a *VpnAPIService) VpnL2vpnsListExecute(r ApiVpnL2vpnsListRequest) (*PaginatedL2VPNList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedL2VPNList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.exportTarget != nil {
		t := *r.exportTarget
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target", t, "form", "multi")
		}
	}
	if r.exportTargetN != nil {
		t := *r.exportTargetN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target__n", t, "form", "multi")
		}
	}
	if r.exportTargetId != nil {
		t := *r.exportTargetId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id", t, "form", "multi")
		}
	}
	if r.exportTargetIdN != nil {
		t := *r.exportTargetIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.identifier != nil {
		t := *r.identifier
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", t, "form", "multi")
		}
	}
	if r.identifierEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identifier__empty", r.identifierEmpty, "form", "")
	}
	if r.identifierGt != nil {
		t := *r.identifierGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "identifier__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "identifier__gt", t, "form", "multi")
		}
	}
	if r.identifierGte != nil {
		t := *r.identifierGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "identifier__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "identifier__gte", t, "form", "multi")
		}
	}
	if r.identifierLt != nil {
		t := *r.identifierLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "identifier__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "identifier__lt", t, "form", "multi")
		}
	}
	if r.identifierLte != nil {
		t := *r.identifierLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "identifier__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "identifier__lte", t, "form", "multi")
		}
	}
	if r.identifierN != nil {
		t := *r.identifierN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "identifier__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "identifier__n", t, "form", "multi")
		}
	}
	if r.importTarget != nil {
		t := *r.importTarget
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target", t, "form", "multi")
		}
	}
	if r.importTargetN != nil {
		t := *r.importTargetN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target__n", t, "form", "multi")
		}
	}
	if r.importTargetId != nil {
		t := *r.importTargetId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id", t, "form", "multi")
		}
	}
	if r.importTargetIdN != nil {
		t := *r.importTargetIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug", t, "form", "multi")
		}
	}
	if r.slugEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slug__empty", r.slugEmpty, "form", "")
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", t, "form", "multi")
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", t, "form", "multi")
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", t, "form", "multi")
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", t, "form", "multi")
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", t, "form", "multi")
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", t, "form", "multi")
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", t, "form", "multi")
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", t, "form", "multi")
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "form", "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "form", "multi")
		}
	}
	if r.typeEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type__empty", r.typeEmpty, "form", "")
	}
	if r.typeIc != nil {
		t := *r.typeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ic", t, "form", "multi")
		}
	}
	if r.typeIe != nil {
		t := *r.typeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__ie", t, "form", "multi")
		}
	}
	if r.typeIew != nil {
		t := *r.typeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__iew", t, "form", "multi")
		}
	}
	if r.typeIsw != nil {
		t := *r.typeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__isw", t, "form", "multi")
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__n", t, "form", "multi")
		}
	}
	if r.typeNic != nil {
		t := *r.typeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nic", t, "form", "multi")
		}
	}
	if r.typeNie != nil {
		t := *r.typeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nie", t, "form", "multi")
		}
	}
	if r.typeNiew != nil {
		t := *r.typeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__niew", t, "form", "multi")
		}
	}
	if r.typeNisw != nil {
		t := *r.typeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type__nisw", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnsPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	patchedWritableL2VPNRequest *PatchedWritableL2VPNRequest
}

func (r ApiVpnL2vpnsPartialUpdateRequest) PatchedWritableL2VPNRequest(patchedWritableL2VPNRequest PatchedWritableL2VPNRequest) ApiVpnL2vpnsPartialUpdateRequest {
	r.patchedWritableL2VPNRequest = &patchedWritableL2VPNRequest
	return r
}

func (r ApiVpnL2vpnsPartialUpdateRequest) Execute() (*L2VPN, *http.Response, error) {
	return r.ApiService.VpnL2vpnsPartialUpdateExecute(r)
}

/*
VpnL2vpnsPartialUpdate Method for VpnL2vpnsPartialUpdate

Patch a L2VPN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this L2VPN.
 @return ApiVpnL2vpnsPartialUpdateRequest
*/
func (a *VpnAPIService) VpnL2vpnsPartialUpdate(ctx context.Context, id int32) ApiVpnL2vpnsPartialUpdateRequest {
	return ApiVpnL2vpnsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return L2VPN
func (a *VpnAPIService) VpnL2vpnsPartialUpdateExecute(r ApiVpnL2vpnsPartialUpdateRequest) (*L2VPN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *L2VPN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableL2VPNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnsRetrieveRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnL2vpnsRetrieveRequest) Execute() (*L2VPN, *http.Response, error) {
	return r.ApiService.VpnL2vpnsRetrieveExecute(r)
}

/*
VpnL2vpnsRetrieve Method for VpnL2vpnsRetrieve

Get a L2VPN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this L2VPN.
 @return ApiVpnL2vpnsRetrieveRequest
*/
func (a *VpnAPIService) VpnL2vpnsRetrieve(ctx context.Context, id int32) ApiVpnL2vpnsRetrieveRequest {
	return ApiVpnL2vpnsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return L2VPN
func (a *VpnAPIService) VpnL2vpnsRetrieveExecute(r ApiVpnL2vpnsRetrieveRequest) (*L2VPN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *L2VPN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnL2vpnsUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	writableL2VPNRequest *WritableL2VPNRequest
}

func (r ApiVpnL2vpnsUpdateRequest) WritableL2VPNRequest(writableL2VPNRequest WritableL2VPNRequest) ApiVpnL2vpnsUpdateRequest {
	r.writableL2VPNRequest = &writableL2VPNRequest
	return r
}

func (r ApiVpnL2vpnsUpdateRequest) Execute() (*L2VPN, *http.Response, error) {
	return r.ApiService.VpnL2vpnsUpdateExecute(r)
}

/*
VpnL2vpnsUpdate Method for VpnL2vpnsUpdate

Put a L2VPN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this L2VPN.
 @return ApiVpnL2vpnsUpdateRequest
*/
func (a *VpnAPIService) VpnL2vpnsUpdate(ctx context.Context, id int32) ApiVpnL2vpnsUpdateRequest {
	return ApiVpnL2vpnsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return L2VPN
func (a *VpnAPIService) VpnL2vpnsUpdateExecute(r ApiVpnL2vpnsUpdateRequest) (*L2VPN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *L2VPN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnL2vpnsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/l2vpns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableL2VPNRequest == nil {
		return localVarReturnValue, nil, reportError("writableL2VPNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableL2VPNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelGroupsBulkDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	tunnelGroupRequest *[]TunnelGroupRequest
}

func (r ApiVpnTunnelGroupsBulkDestroyRequest) TunnelGroupRequest(tunnelGroupRequest []TunnelGroupRequest) ApiVpnTunnelGroupsBulkDestroyRequest {
	r.tunnelGroupRequest = &tunnelGroupRequest
	return r
}

func (r ApiVpnTunnelGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnTunnelGroupsBulkDestroyExecute(r)
}

/*
VpnTunnelGroupsBulkDestroy Method for VpnTunnelGroupsBulkDestroy

Delete a list of tunnel group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelGroupsBulkDestroyRequest
*/
func (a *VpnAPIService) VpnTunnelGroupsBulkDestroy(ctx context.Context) ApiVpnTunnelGroupsBulkDestroyRequest {
	return ApiVpnTunnelGroupsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnTunnelGroupsBulkDestroyExecute(r ApiVpnTunnelGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tunnelGroupRequest == nil {
		return nil, reportError("tunnelGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunnelGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnTunnelGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	tunnelGroupRequest *[]TunnelGroupRequest
}

func (r ApiVpnTunnelGroupsBulkPartialUpdateRequest) TunnelGroupRequest(tunnelGroupRequest []TunnelGroupRequest) ApiVpnTunnelGroupsBulkPartialUpdateRequest {
	r.tunnelGroupRequest = &tunnelGroupRequest
	return r
}

func (r ApiVpnTunnelGroupsBulkPartialUpdateRequest) Execute() ([]TunnelGroup, *http.Response, error) {
	return r.ApiService.VpnTunnelGroupsBulkPartialUpdateExecute(r)
}

/*
VpnTunnelGroupsBulkPartialUpdate Method for VpnTunnelGroupsBulkPartialUpdate

Patch a list of tunnel group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelGroupsBulkPartialUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelGroupsBulkPartialUpdate(ctx context.Context) ApiVpnTunnelGroupsBulkPartialUpdateRequest {
	return ApiVpnTunnelGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TunnelGroup
func (a *VpnAPIService) VpnTunnelGroupsBulkPartialUpdateExecute(r ApiVpnTunnelGroupsBulkPartialUpdateRequest) ([]TunnelGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TunnelGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tunnelGroupRequest == nil {
		return localVarReturnValue, nil, reportError("tunnelGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunnelGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	tunnelGroupRequest *[]TunnelGroupRequest
}

func (r ApiVpnTunnelGroupsBulkUpdateRequest) TunnelGroupRequest(tunnelGroupRequest []TunnelGroupRequest) ApiVpnTunnelGroupsBulkUpdateRequest {
	r.tunnelGroupRequest = &tunnelGroupRequest
	return r
}

func (r ApiVpnTunnelGroupsBulkUpdateRequest) Execute() ([]TunnelGroup, *http.Response, error) {
	return r.ApiService.VpnTunnelGroupsBulkUpdateExecute(r)
}

/*
VpnTunnelGroupsBulkUpdate Method for VpnTunnelGroupsBulkUpdate

Put a list of tunnel group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelGroupsBulkUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelGroupsBulkUpdate(ctx context.Context) ApiVpnTunnelGroupsBulkUpdateRequest {
	return ApiVpnTunnelGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TunnelGroup
func (a *VpnAPIService) VpnTunnelGroupsBulkUpdateExecute(r ApiVpnTunnelGroupsBulkUpdateRequest) ([]TunnelGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TunnelGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tunnelGroupRequest == nil {
		return localVarReturnValue, nil, reportError("tunnelGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunnelGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelGroupsCreateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	tunnelGroupRequest *TunnelGroupRequest
}

func (r ApiVpnTunnelGroupsCreateRequest) TunnelGroupRequest(tunnelGroupRequest TunnelGroupRequest) ApiVpnTunnelGroupsCreateRequest {
	r.tunnelGroupRequest = &tunnelGroupRequest
	return r
}

func (r ApiVpnTunnelGroupsCreateRequest) Execute() (*TunnelGroup, *http.Response, error) {
	return r.ApiService.VpnTunnelGroupsCreateExecute(r)
}

/*
VpnTunnelGroupsCreate Method for VpnTunnelGroupsCreate

Post a list of tunnel group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelGroupsCreateRequest
*/
func (a *VpnAPIService) VpnTunnelGroupsCreate(ctx context.Context) ApiVpnTunnelGroupsCreateRequest {
	return ApiVpnTunnelGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TunnelGroup
func (a *VpnAPIService) VpnTunnelGroupsCreateExecute(r ApiVpnTunnelGroupsCreateRequest) (*TunnelGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TunnelGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tunnelGroupRequest == nil {
		return localVarReturnValue, nil, reportError("tunnelGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunnelGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelGroupsDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnTunnelGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnTunnelGroupsDestroyExecute(r)
}

/*
VpnTunnelGroupsDestroy Method for VpnTunnelGroupsDestroy

Delete a tunnel group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel group.
 @return ApiVpnTunnelGroupsDestroyRequest
*/
func (a *VpnAPIService) VpnTunnelGroupsDestroy(ctx context.Context, id int32) ApiVpnTunnelGroupsDestroyRequest {
	return ApiVpnTunnelGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnTunnelGroupsDestroyExecute(r ApiVpnTunnelGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnTunnelGroupsListRequest struct {
	ctx context.Context
	ApiService VpnAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	slug *[]string
	slugEmpty *bool
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNisw *[]string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiVpnTunnelGroupsListRequest) Created(created []time.Time) ApiVpnTunnelGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiVpnTunnelGroupsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiVpnTunnelGroupsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiVpnTunnelGroupsListRequest) CreatedGt(createdGt []time.Time) ApiVpnTunnelGroupsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiVpnTunnelGroupsListRequest) CreatedGte(createdGte []time.Time) ApiVpnTunnelGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVpnTunnelGroupsListRequest) CreatedLt(createdLt []time.Time) ApiVpnTunnelGroupsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiVpnTunnelGroupsListRequest) CreatedLte(createdLte []time.Time) ApiVpnTunnelGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVpnTunnelGroupsListRequest) CreatedN(createdN []time.Time) ApiVpnTunnelGroupsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiVpnTunnelGroupsListRequest) CreatedByRequest(createdByRequest string) ApiVpnTunnelGroupsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiVpnTunnelGroupsListRequest) Description(description []string) ApiVpnTunnelGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiVpnTunnelGroupsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiVpnTunnelGroupsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiVpnTunnelGroupsListRequest) DescriptionIc(descriptionIc []string) ApiVpnTunnelGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiVpnTunnelGroupsListRequest) DescriptionIe(descriptionIe []string) ApiVpnTunnelGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiVpnTunnelGroupsListRequest) DescriptionIew(descriptionIew []string) ApiVpnTunnelGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiVpnTunnelGroupsListRequest) DescriptionIsw(descriptionIsw []string) ApiVpnTunnelGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiVpnTunnelGroupsListRequest) DescriptionN(descriptionN []string) ApiVpnTunnelGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiVpnTunnelGroupsListRequest) DescriptionNic(descriptionNic []string) ApiVpnTunnelGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiVpnTunnelGroupsListRequest) DescriptionNie(descriptionNie []string) ApiVpnTunnelGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiVpnTunnelGroupsListRequest) DescriptionNiew(descriptionNiew []string) ApiVpnTunnelGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiVpnTunnelGroupsListRequest) DescriptionNisw(descriptionNisw []string) ApiVpnTunnelGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiVpnTunnelGroupsListRequest) Id(id []int32) ApiVpnTunnelGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiVpnTunnelGroupsListRequest) IdEmpty(idEmpty bool) ApiVpnTunnelGroupsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiVpnTunnelGroupsListRequest) IdGt(idGt []int32) ApiVpnTunnelGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVpnTunnelGroupsListRequest) IdGte(idGte []int32) ApiVpnTunnelGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVpnTunnelGroupsListRequest) IdLt(idLt []int32) ApiVpnTunnelGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVpnTunnelGroupsListRequest) IdLte(idLte []int32) ApiVpnTunnelGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVpnTunnelGroupsListRequest) IdN(idN []int32) ApiVpnTunnelGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiVpnTunnelGroupsListRequest) LastUpdated(lastUpdated []time.Time) ApiVpnTunnelGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVpnTunnelGroupsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiVpnTunnelGroupsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiVpnTunnelGroupsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiVpnTunnelGroupsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiVpnTunnelGroupsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiVpnTunnelGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVpnTunnelGroupsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiVpnTunnelGroupsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiVpnTunnelGroupsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiVpnTunnelGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVpnTunnelGroupsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiVpnTunnelGroupsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiVpnTunnelGroupsListRequest) Limit(limit int32) ApiVpnTunnelGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiVpnTunnelGroupsListRequest) ModifiedByRequest(modifiedByRequest string) ApiVpnTunnelGroupsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiVpnTunnelGroupsListRequest) Name(name []string) ApiVpnTunnelGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiVpnTunnelGroupsListRequest) NameEmpty(nameEmpty bool) ApiVpnTunnelGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVpnTunnelGroupsListRequest) NameIc(nameIc []string) ApiVpnTunnelGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVpnTunnelGroupsListRequest) NameIe(nameIe []string) ApiVpnTunnelGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVpnTunnelGroupsListRequest) NameIew(nameIew []string) ApiVpnTunnelGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVpnTunnelGroupsListRequest) NameIsw(nameIsw []string) ApiVpnTunnelGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVpnTunnelGroupsListRequest) NameN(nameN []string) ApiVpnTunnelGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVpnTunnelGroupsListRequest) NameNic(nameNic []string) ApiVpnTunnelGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVpnTunnelGroupsListRequest) NameNie(nameNie []string) ApiVpnTunnelGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVpnTunnelGroupsListRequest) NameNiew(nameNiew []string) ApiVpnTunnelGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVpnTunnelGroupsListRequest) NameNisw(nameNisw []string) ApiVpnTunnelGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiVpnTunnelGroupsListRequest) Offset(offset int32) ApiVpnTunnelGroupsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiVpnTunnelGroupsListRequest) Ordering(ordering string) ApiVpnTunnelGroupsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiVpnTunnelGroupsListRequest) Q(q string) ApiVpnTunnelGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiVpnTunnelGroupsListRequest) Slug(slug []string) ApiVpnTunnelGroupsListRequest {
	r.slug = &slug
	return r
}

func (r ApiVpnTunnelGroupsListRequest) SlugEmpty(slugEmpty bool) ApiVpnTunnelGroupsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiVpnTunnelGroupsListRequest) SlugIc(slugIc []string) ApiVpnTunnelGroupsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiVpnTunnelGroupsListRequest) SlugIe(slugIe []string) ApiVpnTunnelGroupsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiVpnTunnelGroupsListRequest) SlugIew(slugIew []string) ApiVpnTunnelGroupsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiVpnTunnelGroupsListRequest) SlugIsw(slugIsw []string) ApiVpnTunnelGroupsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiVpnTunnelGroupsListRequest) SlugN(slugN []string) ApiVpnTunnelGroupsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiVpnTunnelGroupsListRequest) SlugNic(slugNic []string) ApiVpnTunnelGroupsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiVpnTunnelGroupsListRequest) SlugNie(slugNie []string) ApiVpnTunnelGroupsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiVpnTunnelGroupsListRequest) SlugNiew(slugNiew []string) ApiVpnTunnelGroupsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiVpnTunnelGroupsListRequest) SlugNisw(slugNisw []string) ApiVpnTunnelGroupsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiVpnTunnelGroupsListRequest) Tag(tag []string) ApiVpnTunnelGroupsListRequest {
	r.tag = &tag
	return r
}

func (r ApiVpnTunnelGroupsListRequest) TagN(tagN []string) ApiVpnTunnelGroupsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiVpnTunnelGroupsListRequest) UpdatedByRequest(updatedByRequest string) ApiVpnTunnelGroupsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiVpnTunnelGroupsListRequest) Execute() (*PaginatedTunnelGroupList, *http.Response, error) {
	return r.ApiService.VpnTunnelGroupsListExecute(r)
}

/*
VpnTunnelGroupsList Method for VpnTunnelGroupsList

Get a list of tunnel group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelGroupsListRequest
*/
func (a *VpnAPIService) VpnTunnelGroupsList(ctx context.Context) ApiVpnTunnelGroupsListRequest {
	return ApiVpnTunnelGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedTunnelGroupList
func (a *VpnAPIService) VpnTunnelGroupsListExecute(r ApiVpnTunnelGroupsListRequest) (*PaginatedTunnelGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTunnelGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug", t, "form", "multi")
		}
	}
	if r.slugEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slug__empty", r.slugEmpty, "form", "")
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", t, "form", "multi")
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", t, "form", "multi")
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", t, "form", "multi")
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", t, "form", "multi")
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", t, "form", "multi")
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", t, "form", "multi")
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", t, "form", "multi")
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", t, "form", "multi")
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	patchedTunnelGroupRequest *PatchedTunnelGroupRequest
}

func (r ApiVpnTunnelGroupsPartialUpdateRequest) PatchedTunnelGroupRequest(patchedTunnelGroupRequest PatchedTunnelGroupRequest) ApiVpnTunnelGroupsPartialUpdateRequest {
	r.patchedTunnelGroupRequest = &patchedTunnelGroupRequest
	return r
}

func (r ApiVpnTunnelGroupsPartialUpdateRequest) Execute() (*TunnelGroup, *http.Response, error) {
	return r.ApiService.VpnTunnelGroupsPartialUpdateExecute(r)
}

/*
VpnTunnelGroupsPartialUpdate Method for VpnTunnelGroupsPartialUpdate

Patch a tunnel group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel group.
 @return ApiVpnTunnelGroupsPartialUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelGroupsPartialUpdate(ctx context.Context, id int32) ApiVpnTunnelGroupsPartialUpdateRequest {
	return ApiVpnTunnelGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TunnelGroup
func (a *VpnAPIService) VpnTunnelGroupsPartialUpdateExecute(r ApiVpnTunnelGroupsPartialUpdateRequest) (*TunnelGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TunnelGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTunnelGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnTunnelGroupsRetrieveRequest) Execute() (*TunnelGroup, *http.Response, error) {
	return r.ApiService.VpnTunnelGroupsRetrieveExecute(r)
}

/*
VpnTunnelGroupsRetrieve Method for VpnTunnelGroupsRetrieve

Get a tunnel group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel group.
 @return ApiVpnTunnelGroupsRetrieveRequest
*/
func (a *VpnAPIService) VpnTunnelGroupsRetrieve(ctx context.Context, id int32) ApiVpnTunnelGroupsRetrieveRequest {
	return ApiVpnTunnelGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TunnelGroup
func (a *VpnAPIService) VpnTunnelGroupsRetrieveExecute(r ApiVpnTunnelGroupsRetrieveRequest) (*TunnelGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TunnelGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelGroupsUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	tunnelGroupRequest *TunnelGroupRequest
}

func (r ApiVpnTunnelGroupsUpdateRequest) TunnelGroupRequest(tunnelGroupRequest TunnelGroupRequest) ApiVpnTunnelGroupsUpdateRequest {
	r.tunnelGroupRequest = &tunnelGroupRequest
	return r
}

func (r ApiVpnTunnelGroupsUpdateRequest) Execute() (*TunnelGroup, *http.Response, error) {
	return r.ApiService.VpnTunnelGroupsUpdateExecute(r)
}

/*
VpnTunnelGroupsUpdate Method for VpnTunnelGroupsUpdate

Put a tunnel group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel group.
 @return ApiVpnTunnelGroupsUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelGroupsUpdate(ctx context.Context, id int32) ApiVpnTunnelGroupsUpdateRequest {
	return ApiVpnTunnelGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TunnelGroup
func (a *VpnAPIService) VpnTunnelGroupsUpdateExecute(r ApiVpnTunnelGroupsUpdateRequest) (*TunnelGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TunnelGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tunnelGroupRequest == nil {
		return localVarReturnValue, nil, reportError("tunnelGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunnelGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelTerminationsBulkDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	tunnelTerminationRequest *[]TunnelTerminationRequest
}

func (r ApiVpnTunnelTerminationsBulkDestroyRequest) TunnelTerminationRequest(tunnelTerminationRequest []TunnelTerminationRequest) ApiVpnTunnelTerminationsBulkDestroyRequest {
	r.tunnelTerminationRequest = &tunnelTerminationRequest
	return r
}

func (r ApiVpnTunnelTerminationsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnTunnelTerminationsBulkDestroyExecute(r)
}

/*
VpnTunnelTerminationsBulkDestroy Method for VpnTunnelTerminationsBulkDestroy

Delete a list of tunnel termination objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelTerminationsBulkDestroyRequest
*/
func (a *VpnAPIService) VpnTunnelTerminationsBulkDestroy(ctx context.Context) ApiVpnTunnelTerminationsBulkDestroyRequest {
	return ApiVpnTunnelTerminationsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnTunnelTerminationsBulkDestroyExecute(r ApiVpnTunnelTerminationsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelTerminationsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tunnelTerminationRequest == nil {
		return nil, reportError("tunnelTerminationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunnelTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnTunnelTerminationsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	tunnelTerminationRequest *[]TunnelTerminationRequest
}

func (r ApiVpnTunnelTerminationsBulkPartialUpdateRequest) TunnelTerminationRequest(tunnelTerminationRequest []TunnelTerminationRequest) ApiVpnTunnelTerminationsBulkPartialUpdateRequest {
	r.tunnelTerminationRequest = &tunnelTerminationRequest
	return r
}

func (r ApiVpnTunnelTerminationsBulkPartialUpdateRequest) Execute() ([]TunnelTermination, *http.Response, error) {
	return r.ApiService.VpnTunnelTerminationsBulkPartialUpdateExecute(r)
}

/*
VpnTunnelTerminationsBulkPartialUpdate Method for VpnTunnelTerminationsBulkPartialUpdate

Patch a list of tunnel termination objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelTerminationsBulkPartialUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelTerminationsBulkPartialUpdate(ctx context.Context) ApiVpnTunnelTerminationsBulkPartialUpdateRequest {
	return ApiVpnTunnelTerminationsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TunnelTermination
func (a *VpnAPIService) VpnTunnelTerminationsBulkPartialUpdateExecute(r ApiVpnTunnelTerminationsBulkPartialUpdateRequest) ([]TunnelTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TunnelTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelTerminationsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tunnelTerminationRequest == nil {
		return localVarReturnValue, nil, reportError("tunnelTerminationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunnelTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelTerminationsBulkUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	tunnelTerminationRequest *[]TunnelTerminationRequest
}

func (r ApiVpnTunnelTerminationsBulkUpdateRequest) TunnelTerminationRequest(tunnelTerminationRequest []TunnelTerminationRequest) ApiVpnTunnelTerminationsBulkUpdateRequest {
	r.tunnelTerminationRequest = &tunnelTerminationRequest
	return r
}

func (r ApiVpnTunnelTerminationsBulkUpdateRequest) Execute() ([]TunnelTermination, *http.Response, error) {
	return r.ApiService.VpnTunnelTerminationsBulkUpdateExecute(r)
}

/*
VpnTunnelTerminationsBulkUpdate Method for VpnTunnelTerminationsBulkUpdate

Put a list of tunnel termination objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelTerminationsBulkUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelTerminationsBulkUpdate(ctx context.Context) ApiVpnTunnelTerminationsBulkUpdateRequest {
	return ApiVpnTunnelTerminationsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TunnelTermination
func (a *VpnAPIService) VpnTunnelTerminationsBulkUpdateExecute(r ApiVpnTunnelTerminationsBulkUpdateRequest) ([]TunnelTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TunnelTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelTerminationsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tunnelTerminationRequest == nil {
		return localVarReturnValue, nil, reportError("tunnelTerminationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunnelTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelTerminationsCreateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	writableTunnelTerminationRequest *WritableTunnelTerminationRequest
}

func (r ApiVpnTunnelTerminationsCreateRequest) WritableTunnelTerminationRequest(writableTunnelTerminationRequest WritableTunnelTerminationRequest) ApiVpnTunnelTerminationsCreateRequest {
	r.writableTunnelTerminationRequest = &writableTunnelTerminationRequest
	return r
}

func (r ApiVpnTunnelTerminationsCreateRequest) Execute() (*TunnelTermination, *http.Response, error) {
	return r.ApiService.VpnTunnelTerminationsCreateExecute(r)
}

/*
VpnTunnelTerminationsCreate Method for VpnTunnelTerminationsCreate

Post a list of tunnel termination objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelTerminationsCreateRequest
*/
func (a *VpnAPIService) VpnTunnelTerminationsCreate(ctx context.Context) ApiVpnTunnelTerminationsCreateRequest {
	return ApiVpnTunnelTerminationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TunnelTermination
func (a *VpnAPIService) VpnTunnelTerminationsCreateExecute(r ApiVpnTunnelTerminationsCreateRequest) (*TunnelTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TunnelTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelTerminationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableTunnelTerminationRequest == nil {
		return localVarReturnValue, nil, reportError("writableTunnelTerminationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableTunnelTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelTerminationsDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnTunnelTerminationsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnTunnelTerminationsDestroyExecute(r)
}

/*
VpnTunnelTerminationsDestroy Method for VpnTunnelTerminationsDestroy

Delete a tunnel termination object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel termination.
 @return ApiVpnTunnelTerminationsDestroyRequest
*/
func (a *VpnAPIService) VpnTunnelTerminationsDestroy(ctx context.Context, id int32) ApiVpnTunnelTerminationsDestroyRequest {
	return ApiVpnTunnelTerminationsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnTunnelTerminationsDestroyExecute(r ApiVpnTunnelTerminationsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelTerminationsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnTunnelTerminationsListRequest struct {
	ctx context.Context
	ApiService VpnAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	interface_ *[]string
	interfaceN *[]string
	interfaceId *[]int32
	interfaceIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	offset *int32
	ordering *string
	outsideIpId *[]int32
	outsideIpIdN *[]int32
	q *string
	role *[]string
	roleEmpty *bool
	roleIc *[]string
	roleIe *[]string
	roleIew *[]string
	roleIsw *[]string
	roleN *[]string
	roleNic *[]string
	roleNie *[]string
	roleNiew *[]string
	roleNisw *[]string
	tag *[]string
	tagN *[]string
	terminationId *[]int32
	terminationIdEmpty *bool
	terminationIdGt *[]int32
	terminationIdGte *[]int32
	terminationIdLt *[]int32
	terminationIdLte *[]int32
	terminationIdN *[]int32
	terminationType *string
	terminationTypeN *string
	tunnel *[]string
	tunnelN *[]string
	tunnelId *[]int32
	tunnelIdN *[]int32
	updatedByRequest *string
	vminterface *[]string
	vminterfaceN *[]string
	vminterfaceId *[]int32
	vminterfaceIdN *[]int32
}

func (r ApiVpnTunnelTerminationsListRequest) Created(created []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.created = &created
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) CreatedGt(createdGt []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) CreatedGte(createdGte []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) CreatedLt(createdLt []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) CreatedLte(createdLte []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) CreatedN(createdN []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) CreatedByRequest(createdByRequest string) ApiVpnTunnelTerminationsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) Id(id []int32) ApiVpnTunnelTerminationsListRequest {
	r.id = &id
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) IdEmpty(idEmpty bool) ApiVpnTunnelTerminationsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) IdGt(idGt []int32) ApiVpnTunnelTerminationsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) IdGte(idGte []int32) ApiVpnTunnelTerminationsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) IdLt(idLt []int32) ApiVpnTunnelTerminationsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) IdLte(idLte []int32) ApiVpnTunnelTerminationsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) IdN(idN []int32) ApiVpnTunnelTerminationsListRequest {
	r.idN = &idN
	return r
}

// Interface (name)
func (r ApiVpnTunnelTerminationsListRequest) Interface_(interface_ []string) ApiVpnTunnelTerminationsListRequest {
	r.interface_ = &interface_
	return r
}

// Interface (name)
func (r ApiVpnTunnelTerminationsListRequest) InterfaceN(interfaceN []string) ApiVpnTunnelTerminationsListRequest {
	r.interfaceN = &interfaceN
	return r
}

// Interface (ID)
func (r ApiVpnTunnelTerminationsListRequest) InterfaceId(interfaceId []int32) ApiVpnTunnelTerminationsListRequest {
	r.interfaceId = &interfaceId
	return r
}

// Interface (ID)
func (r ApiVpnTunnelTerminationsListRequest) InterfaceIdN(interfaceIdN []int32) ApiVpnTunnelTerminationsListRequest {
	r.interfaceIdN = &interfaceIdN
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) LastUpdated(lastUpdated []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiVpnTunnelTerminationsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiVpnTunnelTerminationsListRequest) Limit(limit int32) ApiVpnTunnelTerminationsListRequest {
	r.limit = &limit
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) ModifiedByRequest(modifiedByRequest string) ApiVpnTunnelTerminationsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiVpnTunnelTerminationsListRequest) Offset(offset int32) ApiVpnTunnelTerminationsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiVpnTunnelTerminationsListRequest) Ordering(ordering string) ApiVpnTunnelTerminationsListRequest {
	r.ordering = &ordering
	return r
}

// Outside IP (ID)
func (r ApiVpnTunnelTerminationsListRequest) OutsideIpId(outsideIpId []int32) ApiVpnTunnelTerminationsListRequest {
	r.outsideIpId = &outsideIpId
	return r
}

// Outside IP (ID)
func (r ApiVpnTunnelTerminationsListRequest) OutsideIpIdN(outsideIpIdN []int32) ApiVpnTunnelTerminationsListRequest {
	r.outsideIpIdN = &outsideIpIdN
	return r
}

// Search
func (r ApiVpnTunnelTerminationsListRequest) Q(q string) ApiVpnTunnelTerminationsListRequest {
	r.q = &q
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) Role(role []string) ApiVpnTunnelTerminationsListRequest {
	r.role = &role
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) RoleEmpty(roleEmpty bool) ApiVpnTunnelTerminationsListRequest {
	r.roleEmpty = &roleEmpty
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) RoleIc(roleIc []string) ApiVpnTunnelTerminationsListRequest {
	r.roleIc = &roleIc
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) RoleIe(roleIe []string) ApiVpnTunnelTerminationsListRequest {
	r.roleIe = &roleIe
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) RoleIew(roleIew []string) ApiVpnTunnelTerminationsListRequest {
	r.roleIew = &roleIew
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) RoleIsw(roleIsw []string) ApiVpnTunnelTerminationsListRequest {
	r.roleIsw = &roleIsw
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) RoleN(roleN []string) ApiVpnTunnelTerminationsListRequest {
	r.roleN = &roleN
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) RoleNic(roleNic []string) ApiVpnTunnelTerminationsListRequest {
	r.roleNic = &roleNic
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) RoleNie(roleNie []string) ApiVpnTunnelTerminationsListRequest {
	r.roleNie = &roleNie
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) RoleNiew(roleNiew []string) ApiVpnTunnelTerminationsListRequest {
	r.roleNiew = &roleNiew
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) RoleNisw(roleNisw []string) ApiVpnTunnelTerminationsListRequest {
	r.roleNisw = &roleNisw
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) Tag(tag []string) ApiVpnTunnelTerminationsListRequest {
	r.tag = &tag
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) TagN(tagN []string) ApiVpnTunnelTerminationsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) TerminationId(terminationId []int32) ApiVpnTunnelTerminationsListRequest {
	r.terminationId = &terminationId
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) TerminationIdEmpty(terminationIdEmpty bool) ApiVpnTunnelTerminationsListRequest {
	r.terminationIdEmpty = &terminationIdEmpty
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) TerminationIdGt(terminationIdGt []int32) ApiVpnTunnelTerminationsListRequest {
	r.terminationIdGt = &terminationIdGt
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) TerminationIdGte(terminationIdGte []int32) ApiVpnTunnelTerminationsListRequest {
	r.terminationIdGte = &terminationIdGte
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) TerminationIdLt(terminationIdLt []int32) ApiVpnTunnelTerminationsListRequest {
	r.terminationIdLt = &terminationIdLt
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) TerminationIdLte(terminationIdLte []int32) ApiVpnTunnelTerminationsListRequest {
	r.terminationIdLte = &terminationIdLte
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) TerminationIdN(terminationIdN []int32) ApiVpnTunnelTerminationsListRequest {
	r.terminationIdN = &terminationIdN
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) TerminationType(terminationType string) ApiVpnTunnelTerminationsListRequest {
	r.terminationType = &terminationType
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) TerminationTypeN(terminationTypeN string) ApiVpnTunnelTerminationsListRequest {
	r.terminationTypeN = &terminationTypeN
	return r
}

// Tunnel (name)
func (r ApiVpnTunnelTerminationsListRequest) Tunnel(tunnel []string) ApiVpnTunnelTerminationsListRequest {
	r.tunnel = &tunnel
	return r
}

// Tunnel (name)
func (r ApiVpnTunnelTerminationsListRequest) TunnelN(tunnelN []string) ApiVpnTunnelTerminationsListRequest {
	r.tunnelN = &tunnelN
	return r
}

// Tunnel (ID)
func (r ApiVpnTunnelTerminationsListRequest) TunnelId(tunnelId []int32) ApiVpnTunnelTerminationsListRequest {
	r.tunnelId = &tunnelId
	return r
}

// Tunnel (ID)
func (r ApiVpnTunnelTerminationsListRequest) TunnelIdN(tunnelIdN []int32) ApiVpnTunnelTerminationsListRequest {
	r.tunnelIdN = &tunnelIdN
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) UpdatedByRequest(updatedByRequest string) ApiVpnTunnelTerminationsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

// VM interface (name)
func (r ApiVpnTunnelTerminationsListRequest) Vminterface(vminterface []string) ApiVpnTunnelTerminationsListRequest {
	r.vminterface = &vminterface
	return r
}

// VM interface (name)
func (r ApiVpnTunnelTerminationsListRequest) VminterfaceN(vminterfaceN []string) ApiVpnTunnelTerminationsListRequest {
	r.vminterfaceN = &vminterfaceN
	return r
}

// VM interface (ID)
func (r ApiVpnTunnelTerminationsListRequest) VminterfaceId(vminterfaceId []int32) ApiVpnTunnelTerminationsListRequest {
	r.vminterfaceId = &vminterfaceId
	return r
}

// VM interface (ID)
func (r ApiVpnTunnelTerminationsListRequest) VminterfaceIdN(vminterfaceIdN []int32) ApiVpnTunnelTerminationsListRequest {
	r.vminterfaceIdN = &vminterfaceIdN
	return r
}

func (r ApiVpnTunnelTerminationsListRequest) Execute() (*PaginatedTunnelTerminationList, *http.Response, error) {
	return r.ApiService.VpnTunnelTerminationsListExecute(r)
}

/*
VpnTunnelTerminationsList Method for VpnTunnelTerminationsList

Get a list of tunnel termination objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelTerminationsListRequest
*/
func (a *VpnAPIService) VpnTunnelTerminationsList(ctx context.Context) ApiVpnTunnelTerminationsListRequest {
	return ApiVpnTunnelTerminationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedTunnelTerminationList
func (a *VpnAPIService) VpnTunnelTerminationsListExecute(r ApiVpnTunnelTerminationsListRequest) (*PaginatedTunnelTerminationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTunnelTerminationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelTerminationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.interface_ != nil {
		t := *r.interface_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface", t, "form", "multi")
		}
	}
	if r.interfaceN != nil {
		t := *r.interfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", t, "form", "multi")
		}
	}
	if r.interfaceId != nil {
		t := *r.interfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", t, "form", "multi")
		}
	}
	if r.interfaceIdN != nil {
		t := *r.interfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.outsideIpId != nil {
		t := *r.outsideIpId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outside_ip_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outside_ip_id", t, "form", "multi")
		}
	}
	if r.outsideIpIdN != nil {
		t := *r.outsideIpIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "outside_ip_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "outside_ip_id__n", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "form", "multi")
		}
	}
	if r.roleEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role__empty", r.roleEmpty, "form", "")
	}
	if r.roleIc != nil {
		t := *r.roleIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__ic", t, "form", "multi")
		}
	}
	if r.roleIe != nil {
		t := *r.roleIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__ie", t, "form", "multi")
		}
	}
	if r.roleIew != nil {
		t := *r.roleIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__iew", t, "form", "multi")
		}
	}
	if r.roleIsw != nil {
		t := *r.roleIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__isw", t, "form", "multi")
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "form", "multi")
		}
	}
	if r.roleNic != nil {
		t := *r.roleNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__nic", t, "form", "multi")
		}
	}
	if r.roleNie != nil {
		t := *r.roleNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__nie", t, "form", "multi")
		}
	}
	if r.roleNiew != nil {
		t := *r.roleNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__niew", t, "form", "multi")
		}
	}
	if r.roleNisw != nil {
		t := *r.roleNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.terminationId != nil {
		t := *r.terminationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id", t, "form", "multi")
		}
	}
	if r.terminationIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id__empty", r.terminationIdEmpty, "form", "")
	}
	if r.terminationIdGt != nil {
		t := *r.terminationIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id__gt", t, "form", "multi")
		}
	}
	if r.terminationIdGte != nil {
		t := *r.terminationIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id__gte", t, "form", "multi")
		}
	}
	if r.terminationIdLt != nil {
		t := *r.terminationIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id__lt", t, "form", "multi")
		}
	}
	if r.terminationIdLte != nil {
		t := *r.terminationIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id__lte", t, "form", "multi")
		}
	}
	if r.terminationIdN != nil {
		t := *r.terminationIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "termination_id__n", t, "form", "multi")
		}
	}
	if r.terminationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "termination_type", r.terminationType, "form", "")
	}
	if r.terminationTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "termination_type__n", r.terminationTypeN, "form", "")
	}
	if r.tunnel != nil {
		t := *r.tunnel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel", t, "form", "multi")
		}
	}
	if r.tunnelN != nil {
		t := *r.tunnelN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel__n", t, "form", "multi")
		}
	}
	if r.tunnelId != nil {
		t := *r.tunnelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id", t, "form", "multi")
		}
	}
	if r.tunnelIdN != nil {
		t := *r.tunnelIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	if r.vminterface != nil {
		t := *r.vminterface
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface", t, "form", "multi")
		}
	}
	if r.vminterfaceN != nil {
		t := *r.vminterfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface__n", t, "form", "multi")
		}
	}
	if r.vminterfaceId != nil {
		t := *r.vminterfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id", t, "form", "multi")
		}
	}
	if r.vminterfaceIdN != nil {
		t := *r.vminterfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id__n", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelTerminationsPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	patchedWritableTunnelTerminationRequest *PatchedWritableTunnelTerminationRequest
}

func (r ApiVpnTunnelTerminationsPartialUpdateRequest) PatchedWritableTunnelTerminationRequest(patchedWritableTunnelTerminationRequest PatchedWritableTunnelTerminationRequest) ApiVpnTunnelTerminationsPartialUpdateRequest {
	r.patchedWritableTunnelTerminationRequest = &patchedWritableTunnelTerminationRequest
	return r
}

func (r ApiVpnTunnelTerminationsPartialUpdateRequest) Execute() (*TunnelTermination, *http.Response, error) {
	return r.ApiService.VpnTunnelTerminationsPartialUpdateExecute(r)
}

/*
VpnTunnelTerminationsPartialUpdate Method for VpnTunnelTerminationsPartialUpdate

Patch a tunnel termination object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel termination.
 @return ApiVpnTunnelTerminationsPartialUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelTerminationsPartialUpdate(ctx context.Context, id int32) ApiVpnTunnelTerminationsPartialUpdateRequest {
	return ApiVpnTunnelTerminationsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TunnelTermination
func (a *VpnAPIService) VpnTunnelTerminationsPartialUpdateExecute(r ApiVpnTunnelTerminationsPartialUpdateRequest) (*TunnelTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TunnelTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelTerminationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableTunnelTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelTerminationsRetrieveRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnTunnelTerminationsRetrieveRequest) Execute() (*TunnelTermination, *http.Response, error) {
	return r.ApiService.VpnTunnelTerminationsRetrieveExecute(r)
}

/*
VpnTunnelTerminationsRetrieve Method for VpnTunnelTerminationsRetrieve

Get a tunnel termination object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel termination.
 @return ApiVpnTunnelTerminationsRetrieveRequest
*/
func (a *VpnAPIService) VpnTunnelTerminationsRetrieve(ctx context.Context, id int32) ApiVpnTunnelTerminationsRetrieveRequest {
	return ApiVpnTunnelTerminationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TunnelTermination
func (a *VpnAPIService) VpnTunnelTerminationsRetrieveExecute(r ApiVpnTunnelTerminationsRetrieveRequest) (*TunnelTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TunnelTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelTerminationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelTerminationsUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	writableTunnelTerminationRequest *WritableTunnelTerminationRequest
}

func (r ApiVpnTunnelTerminationsUpdateRequest) WritableTunnelTerminationRequest(writableTunnelTerminationRequest WritableTunnelTerminationRequest) ApiVpnTunnelTerminationsUpdateRequest {
	r.writableTunnelTerminationRequest = &writableTunnelTerminationRequest
	return r
}

func (r ApiVpnTunnelTerminationsUpdateRequest) Execute() (*TunnelTermination, *http.Response, error) {
	return r.ApiService.VpnTunnelTerminationsUpdateExecute(r)
}

/*
VpnTunnelTerminationsUpdate Method for VpnTunnelTerminationsUpdate

Put a tunnel termination object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel termination.
 @return ApiVpnTunnelTerminationsUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelTerminationsUpdate(ctx context.Context, id int32) ApiVpnTunnelTerminationsUpdateRequest {
	return ApiVpnTunnelTerminationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TunnelTermination
func (a *VpnAPIService) VpnTunnelTerminationsUpdateExecute(r ApiVpnTunnelTerminationsUpdateRequest) (*TunnelTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TunnelTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelTerminationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnel-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableTunnelTerminationRequest == nil {
		return localVarReturnValue, nil, reportError("writableTunnelTerminationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableTunnelTerminationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelsBulkDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	tunnelRequest *[]TunnelRequest
}

func (r ApiVpnTunnelsBulkDestroyRequest) TunnelRequest(tunnelRequest []TunnelRequest) ApiVpnTunnelsBulkDestroyRequest {
	r.tunnelRequest = &tunnelRequest
	return r
}

func (r ApiVpnTunnelsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnTunnelsBulkDestroyExecute(r)
}

/*
VpnTunnelsBulkDestroy Method for VpnTunnelsBulkDestroy

Delete a list of tunnel objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelsBulkDestroyRequest
*/
func (a *VpnAPIService) VpnTunnelsBulkDestroy(ctx context.Context) ApiVpnTunnelsBulkDestroyRequest {
	return ApiVpnTunnelsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnTunnelsBulkDestroyExecute(r ApiVpnTunnelsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tunnelRequest == nil {
		return nil, reportError("tunnelRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunnelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnTunnelsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	tunnelRequest *[]TunnelRequest
}

func (r ApiVpnTunnelsBulkPartialUpdateRequest) TunnelRequest(tunnelRequest []TunnelRequest) ApiVpnTunnelsBulkPartialUpdateRequest {
	r.tunnelRequest = &tunnelRequest
	return r
}

func (r ApiVpnTunnelsBulkPartialUpdateRequest) Execute() ([]Tunnel, *http.Response, error) {
	return r.ApiService.VpnTunnelsBulkPartialUpdateExecute(r)
}

/*
VpnTunnelsBulkPartialUpdate Method for VpnTunnelsBulkPartialUpdate

Patch a list of tunnel objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelsBulkPartialUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelsBulkPartialUpdate(ctx context.Context) ApiVpnTunnelsBulkPartialUpdateRequest {
	return ApiVpnTunnelsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Tunnel
func (a *VpnAPIService) VpnTunnelsBulkPartialUpdateExecute(r ApiVpnTunnelsBulkPartialUpdateRequest) ([]Tunnel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Tunnel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tunnelRequest == nil {
		return localVarReturnValue, nil, reportError("tunnelRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunnelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelsBulkUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	tunnelRequest *[]TunnelRequest
}

func (r ApiVpnTunnelsBulkUpdateRequest) TunnelRequest(tunnelRequest []TunnelRequest) ApiVpnTunnelsBulkUpdateRequest {
	r.tunnelRequest = &tunnelRequest
	return r
}

func (r ApiVpnTunnelsBulkUpdateRequest) Execute() ([]Tunnel, *http.Response, error) {
	return r.ApiService.VpnTunnelsBulkUpdateExecute(r)
}

/*
VpnTunnelsBulkUpdate Method for VpnTunnelsBulkUpdate

Put a list of tunnel objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelsBulkUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelsBulkUpdate(ctx context.Context) ApiVpnTunnelsBulkUpdateRequest {
	return ApiVpnTunnelsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Tunnel
func (a *VpnAPIService) VpnTunnelsBulkUpdateExecute(r ApiVpnTunnelsBulkUpdateRequest) ([]Tunnel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Tunnel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tunnelRequest == nil {
		return localVarReturnValue, nil, reportError("tunnelRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunnelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelsCreateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	writableTunnelRequest *WritableTunnelRequest
}

func (r ApiVpnTunnelsCreateRequest) WritableTunnelRequest(writableTunnelRequest WritableTunnelRequest) ApiVpnTunnelsCreateRequest {
	r.writableTunnelRequest = &writableTunnelRequest
	return r
}

func (r ApiVpnTunnelsCreateRequest) Execute() (*Tunnel, *http.Response, error) {
	return r.ApiService.VpnTunnelsCreateExecute(r)
}

/*
VpnTunnelsCreate Method for VpnTunnelsCreate

Post a list of tunnel objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelsCreateRequest
*/
func (a *VpnAPIService) VpnTunnelsCreate(ctx context.Context) ApiVpnTunnelsCreateRequest {
	return ApiVpnTunnelsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Tunnel
func (a *VpnAPIService) VpnTunnelsCreateExecute(r ApiVpnTunnelsCreateRequest) (*Tunnel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tunnel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableTunnelRequest == nil {
		return localVarReturnValue, nil, reportError("writableTunnelRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableTunnelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelsDestroyRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnTunnelsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VpnTunnelsDestroyExecute(r)
}

/*
VpnTunnelsDestroy Method for VpnTunnelsDestroy

Delete a tunnel object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel.
 @return ApiVpnTunnelsDestroyRequest
*/
func (a *VpnAPIService) VpnTunnelsDestroy(ctx context.Context, id int32) ApiVpnTunnelsDestroyRequest {
	return ApiVpnTunnelsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VpnAPIService) VpnTunnelsDestroyExecute(r ApiVpnTunnelsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVpnTunnelsListRequest struct {
	ctx context.Context
	ApiService VpnAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	encapsulation *[]string
	encapsulationEmpty *bool
	encapsulationIc *[]string
	encapsulationIe *[]string
	encapsulationIew *[]string
	encapsulationIsw *[]string
	encapsulationN *[]string
	encapsulationNic *[]string
	encapsulationNie *[]string
	encapsulationNiew *[]string
	encapsulationNisw *[]string
	group *[]string
	groupN *[]string
	groupId *[]*int32
	groupIdN *[]*int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	ipsecProfile *[]string
	ipsecProfileN *[]string
	ipsecProfileId *[]*int32
	ipsecProfileIdN *[]*int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	status *[]string
	statusEmpty *bool
	statusIc *[]string
	statusIe *[]string
	statusIew *[]string
	statusIsw *[]string
	statusN *[]string
	statusNic *[]string
	statusNie *[]string
	statusNiew *[]string
	statusNisw *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*int32
	tenantIdN *[]*int32
	tunnelId *[]int32
	tunnelIdEmpty *bool
	tunnelIdGt *[]int32
	tunnelIdGte *[]int32
	tunnelIdLt *[]int32
	tunnelIdLte *[]int32
	tunnelIdN *[]int32
	updatedByRequest *string
}

func (r ApiVpnTunnelsListRequest) Created(created []time.Time) ApiVpnTunnelsListRequest {
	r.created = &created
	return r
}

func (r ApiVpnTunnelsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiVpnTunnelsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiVpnTunnelsListRequest) CreatedGt(createdGt []time.Time) ApiVpnTunnelsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiVpnTunnelsListRequest) CreatedGte(createdGte []time.Time) ApiVpnTunnelsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiVpnTunnelsListRequest) CreatedLt(createdLt []time.Time) ApiVpnTunnelsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiVpnTunnelsListRequest) CreatedLte(createdLte []time.Time) ApiVpnTunnelsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiVpnTunnelsListRequest) CreatedN(createdN []time.Time) ApiVpnTunnelsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiVpnTunnelsListRequest) CreatedByRequest(createdByRequest string) ApiVpnTunnelsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiVpnTunnelsListRequest) Description(description []string) ApiVpnTunnelsListRequest {
	r.description = &description
	return r
}

func (r ApiVpnTunnelsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiVpnTunnelsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiVpnTunnelsListRequest) DescriptionIc(descriptionIc []string) ApiVpnTunnelsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiVpnTunnelsListRequest) DescriptionIe(descriptionIe []string) ApiVpnTunnelsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiVpnTunnelsListRequest) DescriptionIew(descriptionIew []string) ApiVpnTunnelsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiVpnTunnelsListRequest) DescriptionIsw(descriptionIsw []string) ApiVpnTunnelsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiVpnTunnelsListRequest) DescriptionN(descriptionN []string) ApiVpnTunnelsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiVpnTunnelsListRequest) DescriptionNic(descriptionNic []string) ApiVpnTunnelsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiVpnTunnelsListRequest) DescriptionNie(descriptionNie []string) ApiVpnTunnelsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiVpnTunnelsListRequest) DescriptionNiew(descriptionNiew []string) ApiVpnTunnelsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiVpnTunnelsListRequest) DescriptionNisw(descriptionNisw []string) ApiVpnTunnelsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiVpnTunnelsListRequest) Encapsulation(encapsulation []string) ApiVpnTunnelsListRequest {
	r.encapsulation = &encapsulation
	return r
}

func (r ApiVpnTunnelsListRequest) EncapsulationEmpty(encapsulationEmpty bool) ApiVpnTunnelsListRequest {
	r.encapsulationEmpty = &encapsulationEmpty
	return r
}

func (r ApiVpnTunnelsListRequest) EncapsulationIc(encapsulationIc []string) ApiVpnTunnelsListRequest {
	r.encapsulationIc = &encapsulationIc
	return r
}

func (r ApiVpnTunnelsListRequest) EncapsulationIe(encapsulationIe []string) ApiVpnTunnelsListRequest {
	r.encapsulationIe = &encapsulationIe
	return r
}

func (r ApiVpnTunnelsListRequest) EncapsulationIew(encapsulationIew []string) ApiVpnTunnelsListRequest {
	r.encapsulationIew = &encapsulationIew
	return r
}

func (r ApiVpnTunnelsListRequest) EncapsulationIsw(encapsulationIsw []string) ApiVpnTunnelsListRequest {
	r.encapsulationIsw = &encapsulationIsw
	return r
}

func (r ApiVpnTunnelsListRequest) EncapsulationN(encapsulationN []string) ApiVpnTunnelsListRequest {
	r.encapsulationN = &encapsulationN
	return r
}

func (r ApiVpnTunnelsListRequest) EncapsulationNic(encapsulationNic []string) ApiVpnTunnelsListRequest {
	r.encapsulationNic = &encapsulationNic
	return r
}

func (r ApiVpnTunnelsListRequest) EncapsulationNie(encapsulationNie []string) ApiVpnTunnelsListRequest {
	r.encapsulationNie = &encapsulationNie
	return r
}

func (r ApiVpnTunnelsListRequest) EncapsulationNiew(encapsulationNiew []string) ApiVpnTunnelsListRequest {
	r.encapsulationNiew = &encapsulationNiew
	return r
}

func (r ApiVpnTunnelsListRequest) EncapsulationNisw(encapsulationNisw []string) ApiVpnTunnelsListRequest {
	r.encapsulationNisw = &encapsulationNisw
	return r
}

// Tunnel group (slug)
func (r ApiVpnTunnelsListRequest) Group(group []string) ApiVpnTunnelsListRequest {
	r.group = &group
	return r
}

// Tunnel group (slug)
func (r ApiVpnTunnelsListRequest) GroupN(groupN []string) ApiVpnTunnelsListRequest {
	r.groupN = &groupN
	return r
}

// Tunnel group (ID)
func (r ApiVpnTunnelsListRequest) GroupId(groupId []*int32) ApiVpnTunnelsListRequest {
	r.groupId = &groupId
	return r
}

// Tunnel group (ID)
func (r ApiVpnTunnelsListRequest) GroupIdN(groupIdN []*int32) ApiVpnTunnelsListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiVpnTunnelsListRequest) Id(id []int32) ApiVpnTunnelsListRequest {
	r.id = &id
	return r
}

func (r ApiVpnTunnelsListRequest) IdEmpty(idEmpty bool) ApiVpnTunnelsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiVpnTunnelsListRequest) IdGt(idGt []int32) ApiVpnTunnelsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiVpnTunnelsListRequest) IdGte(idGte []int32) ApiVpnTunnelsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiVpnTunnelsListRequest) IdLt(idLt []int32) ApiVpnTunnelsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiVpnTunnelsListRequest) IdLte(idLte []int32) ApiVpnTunnelsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiVpnTunnelsListRequest) IdN(idN []int32) ApiVpnTunnelsListRequest {
	r.idN = &idN
	return r
}

// IPSec profile (name)
func (r ApiVpnTunnelsListRequest) IpsecProfile(ipsecProfile []string) ApiVpnTunnelsListRequest {
	r.ipsecProfile = &ipsecProfile
	return r
}

// IPSec profile (name)
func (r ApiVpnTunnelsListRequest) IpsecProfileN(ipsecProfileN []string) ApiVpnTunnelsListRequest {
	r.ipsecProfileN = &ipsecProfileN
	return r
}

// IPSec profile (ID)
func (r ApiVpnTunnelsListRequest) IpsecProfileId(ipsecProfileId []*int32) ApiVpnTunnelsListRequest {
	r.ipsecProfileId = &ipsecProfileId
	return r
}

// IPSec profile (ID)
func (r ApiVpnTunnelsListRequest) IpsecProfileIdN(ipsecProfileIdN []*int32) ApiVpnTunnelsListRequest {
	r.ipsecProfileIdN = &ipsecProfileIdN
	return r
}

func (r ApiVpnTunnelsListRequest) LastUpdated(lastUpdated []time.Time) ApiVpnTunnelsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiVpnTunnelsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiVpnTunnelsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiVpnTunnelsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiVpnTunnelsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiVpnTunnelsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiVpnTunnelsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiVpnTunnelsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiVpnTunnelsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiVpnTunnelsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiVpnTunnelsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiVpnTunnelsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiVpnTunnelsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiVpnTunnelsListRequest) Limit(limit int32) ApiVpnTunnelsListRequest {
	r.limit = &limit
	return r
}

func (r ApiVpnTunnelsListRequest) ModifiedByRequest(modifiedByRequest string) ApiVpnTunnelsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiVpnTunnelsListRequest) Name(name []string) ApiVpnTunnelsListRequest {
	r.name = &name
	return r
}

func (r ApiVpnTunnelsListRequest) NameEmpty(nameEmpty bool) ApiVpnTunnelsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiVpnTunnelsListRequest) NameIc(nameIc []string) ApiVpnTunnelsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiVpnTunnelsListRequest) NameIe(nameIe []string) ApiVpnTunnelsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiVpnTunnelsListRequest) NameIew(nameIew []string) ApiVpnTunnelsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiVpnTunnelsListRequest) NameIsw(nameIsw []string) ApiVpnTunnelsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiVpnTunnelsListRequest) NameN(nameN []string) ApiVpnTunnelsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiVpnTunnelsListRequest) NameNic(nameNic []string) ApiVpnTunnelsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiVpnTunnelsListRequest) NameNie(nameNie []string) ApiVpnTunnelsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiVpnTunnelsListRequest) NameNiew(nameNiew []string) ApiVpnTunnelsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiVpnTunnelsListRequest) NameNisw(nameNisw []string) ApiVpnTunnelsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiVpnTunnelsListRequest) Offset(offset int32) ApiVpnTunnelsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiVpnTunnelsListRequest) Ordering(ordering string) ApiVpnTunnelsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiVpnTunnelsListRequest) Q(q string) ApiVpnTunnelsListRequest {
	r.q = &q
	return r
}

func (r ApiVpnTunnelsListRequest) Status(status []string) ApiVpnTunnelsListRequest {
	r.status = &status
	return r
}

func (r ApiVpnTunnelsListRequest) StatusEmpty(statusEmpty bool) ApiVpnTunnelsListRequest {
	r.statusEmpty = &statusEmpty
	return r
}

func (r ApiVpnTunnelsListRequest) StatusIc(statusIc []string) ApiVpnTunnelsListRequest {
	r.statusIc = &statusIc
	return r
}

func (r ApiVpnTunnelsListRequest) StatusIe(statusIe []string) ApiVpnTunnelsListRequest {
	r.statusIe = &statusIe
	return r
}

func (r ApiVpnTunnelsListRequest) StatusIew(statusIew []string) ApiVpnTunnelsListRequest {
	r.statusIew = &statusIew
	return r
}

func (r ApiVpnTunnelsListRequest) StatusIsw(statusIsw []string) ApiVpnTunnelsListRequest {
	r.statusIsw = &statusIsw
	return r
}

func (r ApiVpnTunnelsListRequest) StatusN(statusN []string) ApiVpnTunnelsListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiVpnTunnelsListRequest) StatusNic(statusNic []string) ApiVpnTunnelsListRequest {
	r.statusNic = &statusNic
	return r
}

func (r ApiVpnTunnelsListRequest) StatusNie(statusNie []string) ApiVpnTunnelsListRequest {
	r.statusNie = &statusNie
	return r
}

func (r ApiVpnTunnelsListRequest) StatusNiew(statusNiew []string) ApiVpnTunnelsListRequest {
	r.statusNiew = &statusNiew
	return r
}

func (r ApiVpnTunnelsListRequest) StatusNisw(statusNisw []string) ApiVpnTunnelsListRequest {
	r.statusNisw = &statusNisw
	return r
}

func (r ApiVpnTunnelsListRequest) Tag(tag []string) ApiVpnTunnelsListRequest {
	r.tag = &tag
	return r
}

func (r ApiVpnTunnelsListRequest) TagN(tagN []string) ApiVpnTunnelsListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiVpnTunnelsListRequest) Tenant(tenant []string) ApiVpnTunnelsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiVpnTunnelsListRequest) TenantN(tenantN []string) ApiVpnTunnelsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiVpnTunnelsListRequest) TenantGroup(tenantGroup []string) ApiVpnTunnelsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiVpnTunnelsListRequest) TenantGroupN(tenantGroupN []string) ApiVpnTunnelsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiVpnTunnelsListRequest) TenantGroupId(tenantGroupId []string) ApiVpnTunnelsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiVpnTunnelsListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiVpnTunnelsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiVpnTunnelsListRequest) TenantId(tenantId []*int32) ApiVpnTunnelsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiVpnTunnelsListRequest) TenantIdN(tenantIdN []*int32) ApiVpnTunnelsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiVpnTunnelsListRequest) TunnelId(tunnelId []int32) ApiVpnTunnelsListRequest {
	r.tunnelId = &tunnelId
	return r
}

func (r ApiVpnTunnelsListRequest) TunnelIdEmpty(tunnelIdEmpty bool) ApiVpnTunnelsListRequest {
	r.tunnelIdEmpty = &tunnelIdEmpty
	return r
}

func (r ApiVpnTunnelsListRequest) TunnelIdGt(tunnelIdGt []int32) ApiVpnTunnelsListRequest {
	r.tunnelIdGt = &tunnelIdGt
	return r
}

func (r ApiVpnTunnelsListRequest) TunnelIdGte(tunnelIdGte []int32) ApiVpnTunnelsListRequest {
	r.tunnelIdGte = &tunnelIdGte
	return r
}

func (r ApiVpnTunnelsListRequest) TunnelIdLt(tunnelIdLt []int32) ApiVpnTunnelsListRequest {
	r.tunnelIdLt = &tunnelIdLt
	return r
}

func (r ApiVpnTunnelsListRequest) TunnelIdLte(tunnelIdLte []int32) ApiVpnTunnelsListRequest {
	r.tunnelIdLte = &tunnelIdLte
	return r
}

func (r ApiVpnTunnelsListRequest) TunnelIdN(tunnelIdN []int32) ApiVpnTunnelsListRequest {
	r.tunnelIdN = &tunnelIdN
	return r
}

func (r ApiVpnTunnelsListRequest) UpdatedByRequest(updatedByRequest string) ApiVpnTunnelsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiVpnTunnelsListRequest) Execute() (*PaginatedTunnelList, *http.Response, error) {
	return r.ApiService.VpnTunnelsListExecute(r)
}

/*
VpnTunnelsList Method for VpnTunnelsList

Get a list of tunnel objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVpnTunnelsListRequest
*/
func (a *VpnAPIService) VpnTunnelsList(ctx context.Context) ApiVpnTunnelsListRequest {
	return ApiVpnTunnelsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedTunnelList
func (a *VpnAPIService) VpnTunnelsListExecute(r ApiVpnTunnelsListRequest) (*PaginatedTunnelList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTunnelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.encapsulation != nil {
		t := *r.encapsulation
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation", t, "form", "multi")
		}
	}
	if r.encapsulationEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__empty", r.encapsulationEmpty, "form", "")
	}
	if r.encapsulationIc != nil {
		t := *r.encapsulationIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__ic", t, "form", "multi")
		}
	}
	if r.encapsulationIe != nil {
		t := *r.encapsulationIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__ie", t, "form", "multi")
		}
	}
	if r.encapsulationIew != nil {
		t := *r.encapsulationIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__iew", t, "form", "multi")
		}
	}
	if r.encapsulationIsw != nil {
		t := *r.encapsulationIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__isw", t, "form", "multi")
		}
	}
	if r.encapsulationN != nil {
		t := *r.encapsulationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__n", t, "form", "multi")
		}
	}
	if r.encapsulationNic != nil {
		t := *r.encapsulationNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__nic", t, "form", "multi")
		}
	}
	if r.encapsulationNie != nil {
		t := *r.encapsulationNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__nie", t, "form", "multi")
		}
	}
	if r.encapsulationNiew != nil {
		t := *r.encapsulationNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__niew", t, "form", "multi")
		}
	}
	if r.encapsulationNisw != nil {
		t := *r.encapsulationNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "encapsulation__nisw", t, "form", "multi")
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group", t, "form", "multi")
		}
	}
	if r.groupN != nil {
		t := *r.groupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", t, "form", "multi")
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", t, "form", "multi")
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.ipsecProfile != nil {
		t := *r.ipsecProfile
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_profile", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_profile", t, "form", "multi")
		}
	}
	if r.ipsecProfileN != nil {
		t := *r.ipsecProfileN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_profile__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_profile__n", t, "form", "multi")
		}
	}
	if r.ipsecProfileId != nil {
		t := *r.ipsecProfileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_profile_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_profile_id", t, "form", "multi")
		}
	}
	if r.ipsecProfileIdN != nil {
		t := *r.ipsecProfileIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_profile_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipsec_profile_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.statusEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__empty", r.statusEmpty, "form", "")
	}
	if r.statusIc != nil {
		t := *r.statusIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__ic", t, "form", "multi")
		}
	}
	if r.statusIe != nil {
		t := *r.statusIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__ie", t, "form", "multi")
		}
	}
	if r.statusIew != nil {
		t := *r.statusIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__iew", t, "form", "multi")
		}
	}
	if r.statusIsw != nil {
		t := *r.statusIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__isw", t, "form", "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "form", "multi")
		}
	}
	if r.statusNic != nil {
		t := *r.statusNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nic", t, "form", "multi")
		}
	}
	if r.statusNie != nil {
		t := *r.statusNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nie", t, "form", "multi")
		}
	}
	if r.statusNiew != nil {
		t := *r.statusNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__niew", t, "form", "multi")
		}
	}
	if r.statusNisw != nil {
		t := *r.statusNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "form", "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.tunnelId != nil {
		t := *r.tunnelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id", t, "form", "multi")
		}
	}
	if r.tunnelIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__empty", r.tunnelIdEmpty, "form", "")
	}
	if r.tunnelIdGt != nil {
		t := *r.tunnelIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__gt", t, "form", "multi")
		}
	}
	if r.tunnelIdGte != nil {
		t := *r.tunnelIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__gte", t, "form", "multi")
		}
	}
	if r.tunnelIdLt != nil {
		t := *r.tunnelIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__lt", t, "form", "multi")
		}
	}
	if r.tunnelIdLte != nil {
		t := *r.tunnelIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__lte", t, "form", "multi")
		}
	}
	if r.tunnelIdN != nil {
		t := *r.tunnelIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tunnel_id__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelsPartialUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	patchedWritableTunnelRequest *PatchedWritableTunnelRequest
}

func (r ApiVpnTunnelsPartialUpdateRequest) PatchedWritableTunnelRequest(patchedWritableTunnelRequest PatchedWritableTunnelRequest) ApiVpnTunnelsPartialUpdateRequest {
	r.patchedWritableTunnelRequest = &patchedWritableTunnelRequest
	return r
}

func (r ApiVpnTunnelsPartialUpdateRequest) Execute() (*Tunnel, *http.Response, error) {
	return r.ApiService.VpnTunnelsPartialUpdateExecute(r)
}

/*
VpnTunnelsPartialUpdate Method for VpnTunnelsPartialUpdate

Patch a tunnel object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel.
 @return ApiVpnTunnelsPartialUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelsPartialUpdate(ctx context.Context, id int32) ApiVpnTunnelsPartialUpdateRequest {
	return ApiVpnTunnelsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Tunnel
func (a *VpnAPIService) VpnTunnelsPartialUpdateExecute(r ApiVpnTunnelsPartialUpdateRequest) (*Tunnel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tunnel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableTunnelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelsRetrieveRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
}

func (r ApiVpnTunnelsRetrieveRequest) Execute() (*Tunnel, *http.Response, error) {
	return r.ApiService.VpnTunnelsRetrieveExecute(r)
}

/*
VpnTunnelsRetrieve Method for VpnTunnelsRetrieve

Get a tunnel object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel.
 @return ApiVpnTunnelsRetrieveRequest
*/
func (a *VpnAPIService) VpnTunnelsRetrieve(ctx context.Context, id int32) ApiVpnTunnelsRetrieveRequest {
	return ApiVpnTunnelsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Tunnel
func (a *VpnAPIService) VpnTunnelsRetrieveExecute(r ApiVpnTunnelsRetrieveRequest) (*Tunnel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tunnel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVpnTunnelsUpdateRequest struct {
	ctx context.Context
	ApiService VpnAPI
	id int32
	writableTunnelRequest *WritableTunnelRequest
}

func (r ApiVpnTunnelsUpdateRequest) WritableTunnelRequest(writableTunnelRequest WritableTunnelRequest) ApiVpnTunnelsUpdateRequest {
	r.writableTunnelRequest = &writableTunnelRequest
	return r
}

func (r ApiVpnTunnelsUpdateRequest) Execute() (*Tunnel, *http.Response, error) {
	return r.ApiService.VpnTunnelsUpdateExecute(r)
}

/*
VpnTunnelsUpdate Method for VpnTunnelsUpdate

Put a tunnel object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this tunnel.
 @return ApiVpnTunnelsUpdateRequest
*/
func (a *VpnAPIService) VpnTunnelsUpdate(ctx context.Context, id int32) ApiVpnTunnelsUpdateRequest {
	return ApiVpnTunnelsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Tunnel
func (a *VpnAPIService) VpnTunnelsUpdateExecute(r ApiVpnTunnelsUpdateRequest) (*Tunnel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tunnel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VpnAPIService.VpnTunnelsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/vpn/tunnels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableTunnelRequest == nil {
		return localVarReturnValue, nil, reportError("writableTunnelRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableTunnelRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
