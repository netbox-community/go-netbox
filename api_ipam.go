/*
NetBox REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 4.2.2 (4.2)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netbox

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


type IpamAPI interface {

	/*
	IpamAggregatesBulkDestroy Method for IpamAggregatesBulkDestroy

	Delete a list of aggregate objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAggregatesBulkDestroyRequest
	*/
	IpamAggregatesBulkDestroy(ctx context.Context) ApiIpamAggregatesBulkDestroyRequest

	// IpamAggregatesBulkDestroyExecute executes the request
	IpamAggregatesBulkDestroyExecute(r ApiIpamAggregatesBulkDestroyRequest) (*http.Response, error)

	/*
	IpamAggregatesBulkPartialUpdate Method for IpamAggregatesBulkPartialUpdate

	Patch a list of aggregate objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAggregatesBulkPartialUpdateRequest
	*/
	IpamAggregatesBulkPartialUpdate(ctx context.Context) ApiIpamAggregatesBulkPartialUpdateRequest

	// IpamAggregatesBulkPartialUpdateExecute executes the request
	//  @return []Aggregate
	IpamAggregatesBulkPartialUpdateExecute(r ApiIpamAggregatesBulkPartialUpdateRequest) ([]Aggregate, *http.Response, error)

	/*
	IpamAggregatesBulkUpdate Method for IpamAggregatesBulkUpdate

	Put a list of aggregate objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAggregatesBulkUpdateRequest
	*/
	IpamAggregatesBulkUpdate(ctx context.Context) ApiIpamAggregatesBulkUpdateRequest

	// IpamAggregatesBulkUpdateExecute executes the request
	//  @return []Aggregate
	IpamAggregatesBulkUpdateExecute(r ApiIpamAggregatesBulkUpdateRequest) ([]Aggregate, *http.Response, error)

	/*
	IpamAggregatesCreate Method for IpamAggregatesCreate

	Post a list of aggregate objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAggregatesCreateRequest
	*/
	IpamAggregatesCreate(ctx context.Context) ApiIpamAggregatesCreateRequest

	// IpamAggregatesCreateExecute executes the request
	//  @return Aggregate
	IpamAggregatesCreateExecute(r ApiIpamAggregatesCreateRequest) (*Aggregate, *http.Response, error)

	/*
	IpamAggregatesDestroy Method for IpamAggregatesDestroy

	Delete a aggregate object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this aggregate.
	@return ApiIpamAggregatesDestroyRequest
	*/
	IpamAggregatesDestroy(ctx context.Context, id int32) ApiIpamAggregatesDestroyRequest

	// IpamAggregatesDestroyExecute executes the request
	IpamAggregatesDestroyExecute(r ApiIpamAggregatesDestroyRequest) (*http.Response, error)

	/*
	IpamAggregatesList Method for IpamAggregatesList

	Get a list of aggregate objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAggregatesListRequest
	*/
	IpamAggregatesList(ctx context.Context) ApiIpamAggregatesListRequest

	// IpamAggregatesListExecute executes the request
	//  @return PaginatedAggregateList
	IpamAggregatesListExecute(r ApiIpamAggregatesListRequest) (*PaginatedAggregateList, *http.Response, error)

	/*
	IpamAggregatesPartialUpdate Method for IpamAggregatesPartialUpdate

	Patch a aggregate object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this aggregate.
	@return ApiIpamAggregatesPartialUpdateRequest
	*/
	IpamAggregatesPartialUpdate(ctx context.Context, id int32) ApiIpamAggregatesPartialUpdateRequest

	// IpamAggregatesPartialUpdateExecute executes the request
	//  @return Aggregate
	IpamAggregatesPartialUpdateExecute(r ApiIpamAggregatesPartialUpdateRequest) (*Aggregate, *http.Response, error)

	/*
	IpamAggregatesRetrieve Method for IpamAggregatesRetrieve

	Get a aggregate object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this aggregate.
	@return ApiIpamAggregatesRetrieveRequest
	*/
	IpamAggregatesRetrieve(ctx context.Context, id int32) ApiIpamAggregatesRetrieveRequest

	// IpamAggregatesRetrieveExecute executes the request
	//  @return Aggregate
	IpamAggregatesRetrieveExecute(r ApiIpamAggregatesRetrieveRequest) (*Aggregate, *http.Response, error)

	/*
	IpamAggregatesUpdate Method for IpamAggregatesUpdate

	Put a aggregate object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this aggregate.
	@return ApiIpamAggregatesUpdateRequest
	*/
	IpamAggregatesUpdate(ctx context.Context, id int32) ApiIpamAggregatesUpdateRequest

	// IpamAggregatesUpdateExecute executes the request
	//  @return Aggregate
	IpamAggregatesUpdateExecute(r ApiIpamAggregatesUpdateRequest) (*Aggregate, *http.Response, error)

	/*
	IpamAsnRangesAvailableAsnsCreate Method for IpamAsnRangesAvailableAsnsCreate

	Post a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamAsnRangesAvailableAsnsCreateRequest
	*/
	IpamAsnRangesAvailableAsnsCreate(ctx context.Context, id int32) ApiIpamAsnRangesAvailableAsnsCreateRequest

	// IpamAsnRangesAvailableAsnsCreateExecute executes the request
	//  @return []ASN
	IpamAsnRangesAvailableAsnsCreateExecute(r ApiIpamAsnRangesAvailableAsnsCreateRequest) ([]ASN, *http.Response, error)

	/*
	IpamAsnRangesAvailableAsnsList Method for IpamAsnRangesAvailableAsnsList

	Get a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamAsnRangesAvailableAsnsListRequest
	*/
	IpamAsnRangesAvailableAsnsList(ctx context.Context, id int32) ApiIpamAsnRangesAvailableAsnsListRequest

	// IpamAsnRangesAvailableAsnsListExecute executes the request
	//  @return []AvailableASN
	IpamAsnRangesAvailableAsnsListExecute(r ApiIpamAsnRangesAvailableAsnsListRequest) ([]AvailableASN, *http.Response, error)

	/*
	IpamAsnRangesBulkDestroy Method for IpamAsnRangesBulkDestroy

	Delete a list of ASN range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnRangesBulkDestroyRequest
	*/
	IpamAsnRangesBulkDestroy(ctx context.Context) ApiIpamAsnRangesBulkDestroyRequest

	// IpamAsnRangesBulkDestroyExecute executes the request
	IpamAsnRangesBulkDestroyExecute(r ApiIpamAsnRangesBulkDestroyRequest) (*http.Response, error)

	/*
	IpamAsnRangesBulkPartialUpdate Method for IpamAsnRangesBulkPartialUpdate

	Patch a list of ASN range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnRangesBulkPartialUpdateRequest
	*/
	IpamAsnRangesBulkPartialUpdate(ctx context.Context) ApiIpamAsnRangesBulkPartialUpdateRequest

	// IpamAsnRangesBulkPartialUpdateExecute executes the request
	//  @return []ASNRange
	IpamAsnRangesBulkPartialUpdateExecute(r ApiIpamAsnRangesBulkPartialUpdateRequest) ([]ASNRange, *http.Response, error)

	/*
	IpamAsnRangesBulkUpdate Method for IpamAsnRangesBulkUpdate

	Put a list of ASN range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnRangesBulkUpdateRequest
	*/
	IpamAsnRangesBulkUpdate(ctx context.Context) ApiIpamAsnRangesBulkUpdateRequest

	// IpamAsnRangesBulkUpdateExecute executes the request
	//  @return []ASNRange
	IpamAsnRangesBulkUpdateExecute(r ApiIpamAsnRangesBulkUpdateRequest) ([]ASNRange, *http.Response, error)

	/*
	IpamAsnRangesCreate Method for IpamAsnRangesCreate

	Post a list of ASN range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnRangesCreateRequest
	*/
	IpamAsnRangesCreate(ctx context.Context) ApiIpamAsnRangesCreateRequest

	// IpamAsnRangesCreateExecute executes the request
	//  @return ASNRange
	IpamAsnRangesCreateExecute(r ApiIpamAsnRangesCreateRequest) (*ASNRange, *http.Response, error)

	/*
	IpamAsnRangesDestroy Method for IpamAsnRangesDestroy

	Delete a ASN range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN range.
	@return ApiIpamAsnRangesDestroyRequest
	*/
	IpamAsnRangesDestroy(ctx context.Context, id int32) ApiIpamAsnRangesDestroyRequest

	// IpamAsnRangesDestroyExecute executes the request
	IpamAsnRangesDestroyExecute(r ApiIpamAsnRangesDestroyRequest) (*http.Response, error)

	/*
	IpamAsnRangesList Method for IpamAsnRangesList

	Get a list of ASN range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnRangesListRequest
	*/
	IpamAsnRangesList(ctx context.Context) ApiIpamAsnRangesListRequest

	// IpamAsnRangesListExecute executes the request
	//  @return PaginatedASNRangeList
	IpamAsnRangesListExecute(r ApiIpamAsnRangesListRequest) (*PaginatedASNRangeList, *http.Response, error)

	/*
	IpamAsnRangesPartialUpdate Method for IpamAsnRangesPartialUpdate

	Patch a ASN range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN range.
	@return ApiIpamAsnRangesPartialUpdateRequest
	*/
	IpamAsnRangesPartialUpdate(ctx context.Context, id int32) ApiIpamAsnRangesPartialUpdateRequest

	// IpamAsnRangesPartialUpdateExecute executes the request
	//  @return ASNRange
	IpamAsnRangesPartialUpdateExecute(r ApiIpamAsnRangesPartialUpdateRequest) (*ASNRange, *http.Response, error)

	/*
	IpamAsnRangesRetrieve Method for IpamAsnRangesRetrieve

	Get a ASN range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN range.
	@return ApiIpamAsnRangesRetrieveRequest
	*/
	IpamAsnRangesRetrieve(ctx context.Context, id int32) ApiIpamAsnRangesRetrieveRequest

	// IpamAsnRangesRetrieveExecute executes the request
	//  @return ASNRange
	IpamAsnRangesRetrieveExecute(r ApiIpamAsnRangesRetrieveRequest) (*ASNRange, *http.Response, error)

	/*
	IpamAsnRangesUpdate Method for IpamAsnRangesUpdate

	Put a ASN range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN range.
	@return ApiIpamAsnRangesUpdateRequest
	*/
	IpamAsnRangesUpdate(ctx context.Context, id int32) ApiIpamAsnRangesUpdateRequest

	// IpamAsnRangesUpdateExecute executes the request
	//  @return ASNRange
	IpamAsnRangesUpdateExecute(r ApiIpamAsnRangesUpdateRequest) (*ASNRange, *http.Response, error)

	/*
	IpamAsnsBulkDestroy Method for IpamAsnsBulkDestroy

	Delete a list of ASN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnsBulkDestroyRequest
	*/
	IpamAsnsBulkDestroy(ctx context.Context) ApiIpamAsnsBulkDestroyRequest

	// IpamAsnsBulkDestroyExecute executes the request
	IpamAsnsBulkDestroyExecute(r ApiIpamAsnsBulkDestroyRequest) (*http.Response, error)

	/*
	IpamAsnsBulkPartialUpdate Method for IpamAsnsBulkPartialUpdate

	Patch a list of ASN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnsBulkPartialUpdateRequest
	*/
	IpamAsnsBulkPartialUpdate(ctx context.Context) ApiIpamAsnsBulkPartialUpdateRequest

	// IpamAsnsBulkPartialUpdateExecute executes the request
	//  @return []ASN
	IpamAsnsBulkPartialUpdateExecute(r ApiIpamAsnsBulkPartialUpdateRequest) ([]ASN, *http.Response, error)

	/*
	IpamAsnsBulkUpdate Method for IpamAsnsBulkUpdate

	Put a list of ASN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnsBulkUpdateRequest
	*/
	IpamAsnsBulkUpdate(ctx context.Context) ApiIpamAsnsBulkUpdateRequest

	// IpamAsnsBulkUpdateExecute executes the request
	//  @return []ASN
	IpamAsnsBulkUpdateExecute(r ApiIpamAsnsBulkUpdateRequest) ([]ASN, *http.Response, error)

	/*
	IpamAsnsCreate Method for IpamAsnsCreate

	Post a list of ASN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnsCreateRequest
	*/
	IpamAsnsCreate(ctx context.Context) ApiIpamAsnsCreateRequest

	// IpamAsnsCreateExecute executes the request
	//  @return ASN
	IpamAsnsCreateExecute(r ApiIpamAsnsCreateRequest) (*ASN, *http.Response, error)

	/*
	IpamAsnsDestroy Method for IpamAsnsDestroy

	Delete a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN.
	@return ApiIpamAsnsDestroyRequest
	*/
	IpamAsnsDestroy(ctx context.Context, id int32) ApiIpamAsnsDestroyRequest

	// IpamAsnsDestroyExecute executes the request
	IpamAsnsDestroyExecute(r ApiIpamAsnsDestroyRequest) (*http.Response, error)

	/*
	IpamAsnsList Method for IpamAsnsList

	Get a list of ASN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnsListRequest
	*/
	IpamAsnsList(ctx context.Context) ApiIpamAsnsListRequest

	// IpamAsnsListExecute executes the request
	//  @return PaginatedASNList
	IpamAsnsListExecute(r ApiIpamAsnsListRequest) (*PaginatedASNList, *http.Response, error)

	/*
	IpamAsnsPartialUpdate Method for IpamAsnsPartialUpdate

	Patch a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN.
	@return ApiIpamAsnsPartialUpdateRequest
	*/
	IpamAsnsPartialUpdate(ctx context.Context, id int32) ApiIpamAsnsPartialUpdateRequest

	// IpamAsnsPartialUpdateExecute executes the request
	//  @return ASN
	IpamAsnsPartialUpdateExecute(r ApiIpamAsnsPartialUpdateRequest) (*ASN, *http.Response, error)

	/*
	IpamAsnsRetrieve Method for IpamAsnsRetrieve

	Get a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN.
	@return ApiIpamAsnsRetrieveRequest
	*/
	IpamAsnsRetrieve(ctx context.Context, id int32) ApiIpamAsnsRetrieveRequest

	// IpamAsnsRetrieveExecute executes the request
	//  @return ASN
	IpamAsnsRetrieveExecute(r ApiIpamAsnsRetrieveRequest) (*ASN, *http.Response, error)

	/*
	IpamAsnsUpdate Method for IpamAsnsUpdate

	Put a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN.
	@return ApiIpamAsnsUpdateRequest
	*/
	IpamAsnsUpdate(ctx context.Context, id int32) ApiIpamAsnsUpdateRequest

	// IpamAsnsUpdateExecute executes the request
	//  @return ASN
	IpamAsnsUpdateExecute(r ApiIpamAsnsUpdateRequest) (*ASN, *http.Response, error)

	/*
	IpamFhrpGroupAssignmentsBulkDestroy Method for IpamFhrpGroupAssignmentsBulkDestroy

	Delete a list of FHRP group assignment objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupAssignmentsBulkDestroyRequest
	*/
	IpamFhrpGroupAssignmentsBulkDestroy(ctx context.Context) ApiIpamFhrpGroupAssignmentsBulkDestroyRequest

	// IpamFhrpGroupAssignmentsBulkDestroyExecute executes the request
	IpamFhrpGroupAssignmentsBulkDestroyExecute(r ApiIpamFhrpGroupAssignmentsBulkDestroyRequest) (*http.Response, error)

	/*
	IpamFhrpGroupAssignmentsBulkPartialUpdate Method for IpamFhrpGroupAssignmentsBulkPartialUpdate

	Patch a list of FHRP group assignment objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest
	*/
	IpamFhrpGroupAssignmentsBulkPartialUpdate(ctx context.Context) ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest

	// IpamFhrpGroupAssignmentsBulkPartialUpdateExecute executes the request
	//  @return []FHRPGroupAssignment
	IpamFhrpGroupAssignmentsBulkPartialUpdateExecute(r ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest) ([]FHRPGroupAssignment, *http.Response, error)

	/*
	IpamFhrpGroupAssignmentsBulkUpdate Method for IpamFhrpGroupAssignmentsBulkUpdate

	Put a list of FHRP group assignment objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupAssignmentsBulkUpdateRequest
	*/
	IpamFhrpGroupAssignmentsBulkUpdate(ctx context.Context) ApiIpamFhrpGroupAssignmentsBulkUpdateRequest

	// IpamFhrpGroupAssignmentsBulkUpdateExecute executes the request
	//  @return []FHRPGroupAssignment
	IpamFhrpGroupAssignmentsBulkUpdateExecute(r ApiIpamFhrpGroupAssignmentsBulkUpdateRequest) ([]FHRPGroupAssignment, *http.Response, error)

	/*
	IpamFhrpGroupAssignmentsCreate Method for IpamFhrpGroupAssignmentsCreate

	Post a list of FHRP group assignment objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupAssignmentsCreateRequest
	*/
	IpamFhrpGroupAssignmentsCreate(ctx context.Context) ApiIpamFhrpGroupAssignmentsCreateRequest

	// IpamFhrpGroupAssignmentsCreateExecute executes the request
	//  @return FHRPGroupAssignment
	IpamFhrpGroupAssignmentsCreateExecute(r ApiIpamFhrpGroupAssignmentsCreateRequest) (*FHRPGroupAssignment, *http.Response, error)

	/*
	IpamFhrpGroupAssignmentsDestroy Method for IpamFhrpGroupAssignmentsDestroy

	Delete a FHRP group assignment object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group assignment.
	@return ApiIpamFhrpGroupAssignmentsDestroyRequest
	*/
	IpamFhrpGroupAssignmentsDestroy(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsDestroyRequest

	// IpamFhrpGroupAssignmentsDestroyExecute executes the request
	IpamFhrpGroupAssignmentsDestroyExecute(r ApiIpamFhrpGroupAssignmentsDestroyRequest) (*http.Response, error)

	/*
	IpamFhrpGroupAssignmentsList Method for IpamFhrpGroupAssignmentsList

	Get a list of FHRP group assignment objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupAssignmentsListRequest
	*/
	IpamFhrpGroupAssignmentsList(ctx context.Context) ApiIpamFhrpGroupAssignmentsListRequest

	// IpamFhrpGroupAssignmentsListExecute executes the request
	//  @return PaginatedFHRPGroupAssignmentList
	IpamFhrpGroupAssignmentsListExecute(r ApiIpamFhrpGroupAssignmentsListRequest) (*PaginatedFHRPGroupAssignmentList, *http.Response, error)

	/*
	IpamFhrpGroupAssignmentsPartialUpdate Method for IpamFhrpGroupAssignmentsPartialUpdate

	Patch a FHRP group assignment object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group assignment.
	@return ApiIpamFhrpGroupAssignmentsPartialUpdateRequest
	*/
	IpamFhrpGroupAssignmentsPartialUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsPartialUpdateRequest

	// IpamFhrpGroupAssignmentsPartialUpdateExecute executes the request
	//  @return FHRPGroupAssignment
	IpamFhrpGroupAssignmentsPartialUpdateExecute(r ApiIpamFhrpGroupAssignmentsPartialUpdateRequest) (*FHRPGroupAssignment, *http.Response, error)

	/*
	IpamFhrpGroupAssignmentsRetrieve Method for IpamFhrpGroupAssignmentsRetrieve

	Get a FHRP group assignment object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group assignment.
	@return ApiIpamFhrpGroupAssignmentsRetrieveRequest
	*/
	IpamFhrpGroupAssignmentsRetrieve(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsRetrieveRequest

	// IpamFhrpGroupAssignmentsRetrieveExecute executes the request
	//  @return FHRPGroupAssignment
	IpamFhrpGroupAssignmentsRetrieveExecute(r ApiIpamFhrpGroupAssignmentsRetrieveRequest) (*FHRPGroupAssignment, *http.Response, error)

	/*
	IpamFhrpGroupAssignmentsUpdate Method for IpamFhrpGroupAssignmentsUpdate

	Put a FHRP group assignment object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group assignment.
	@return ApiIpamFhrpGroupAssignmentsUpdateRequest
	*/
	IpamFhrpGroupAssignmentsUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsUpdateRequest

	// IpamFhrpGroupAssignmentsUpdateExecute executes the request
	//  @return FHRPGroupAssignment
	IpamFhrpGroupAssignmentsUpdateExecute(r ApiIpamFhrpGroupAssignmentsUpdateRequest) (*FHRPGroupAssignment, *http.Response, error)

	/*
	IpamFhrpGroupsBulkDestroy Method for IpamFhrpGroupsBulkDestroy

	Delete a list of FHRP group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupsBulkDestroyRequest
	*/
	IpamFhrpGroupsBulkDestroy(ctx context.Context) ApiIpamFhrpGroupsBulkDestroyRequest

	// IpamFhrpGroupsBulkDestroyExecute executes the request
	IpamFhrpGroupsBulkDestroyExecute(r ApiIpamFhrpGroupsBulkDestroyRequest) (*http.Response, error)

	/*
	IpamFhrpGroupsBulkPartialUpdate Method for IpamFhrpGroupsBulkPartialUpdate

	Patch a list of FHRP group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupsBulkPartialUpdateRequest
	*/
	IpamFhrpGroupsBulkPartialUpdate(ctx context.Context) ApiIpamFhrpGroupsBulkPartialUpdateRequest

	// IpamFhrpGroupsBulkPartialUpdateExecute executes the request
	//  @return []FHRPGroup
	IpamFhrpGroupsBulkPartialUpdateExecute(r ApiIpamFhrpGroupsBulkPartialUpdateRequest) ([]FHRPGroup, *http.Response, error)

	/*
	IpamFhrpGroupsBulkUpdate Method for IpamFhrpGroupsBulkUpdate

	Put a list of FHRP group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupsBulkUpdateRequest
	*/
	IpamFhrpGroupsBulkUpdate(ctx context.Context) ApiIpamFhrpGroupsBulkUpdateRequest

	// IpamFhrpGroupsBulkUpdateExecute executes the request
	//  @return []FHRPGroup
	IpamFhrpGroupsBulkUpdateExecute(r ApiIpamFhrpGroupsBulkUpdateRequest) ([]FHRPGroup, *http.Response, error)

	/*
	IpamFhrpGroupsCreate Method for IpamFhrpGroupsCreate

	Post a list of FHRP group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupsCreateRequest
	*/
	IpamFhrpGroupsCreate(ctx context.Context) ApiIpamFhrpGroupsCreateRequest

	// IpamFhrpGroupsCreateExecute executes the request
	//  @return FHRPGroup
	IpamFhrpGroupsCreateExecute(r ApiIpamFhrpGroupsCreateRequest) (*FHRPGroup, *http.Response, error)

	/*
	IpamFhrpGroupsDestroy Method for IpamFhrpGroupsDestroy

	Delete a FHRP group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group.
	@return ApiIpamFhrpGroupsDestroyRequest
	*/
	IpamFhrpGroupsDestroy(ctx context.Context, id int32) ApiIpamFhrpGroupsDestroyRequest

	// IpamFhrpGroupsDestroyExecute executes the request
	IpamFhrpGroupsDestroyExecute(r ApiIpamFhrpGroupsDestroyRequest) (*http.Response, error)

	/*
	IpamFhrpGroupsList Method for IpamFhrpGroupsList

	Get a list of FHRP group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupsListRequest
	*/
	IpamFhrpGroupsList(ctx context.Context) ApiIpamFhrpGroupsListRequest

	// IpamFhrpGroupsListExecute executes the request
	//  @return PaginatedFHRPGroupList
	IpamFhrpGroupsListExecute(r ApiIpamFhrpGroupsListRequest) (*PaginatedFHRPGroupList, *http.Response, error)

	/*
	IpamFhrpGroupsPartialUpdate Method for IpamFhrpGroupsPartialUpdate

	Patch a FHRP group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group.
	@return ApiIpamFhrpGroupsPartialUpdateRequest
	*/
	IpamFhrpGroupsPartialUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupsPartialUpdateRequest

	// IpamFhrpGroupsPartialUpdateExecute executes the request
	//  @return FHRPGroup
	IpamFhrpGroupsPartialUpdateExecute(r ApiIpamFhrpGroupsPartialUpdateRequest) (*FHRPGroup, *http.Response, error)

	/*
	IpamFhrpGroupsRetrieve Method for IpamFhrpGroupsRetrieve

	Get a FHRP group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group.
	@return ApiIpamFhrpGroupsRetrieveRequest
	*/
	IpamFhrpGroupsRetrieve(ctx context.Context, id int32) ApiIpamFhrpGroupsRetrieveRequest

	// IpamFhrpGroupsRetrieveExecute executes the request
	//  @return FHRPGroup
	IpamFhrpGroupsRetrieveExecute(r ApiIpamFhrpGroupsRetrieveRequest) (*FHRPGroup, *http.Response, error)

	/*
	IpamFhrpGroupsUpdate Method for IpamFhrpGroupsUpdate

	Put a FHRP group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group.
	@return ApiIpamFhrpGroupsUpdateRequest
	*/
	IpamFhrpGroupsUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupsUpdateRequest

	// IpamFhrpGroupsUpdateExecute executes the request
	//  @return FHRPGroup
	IpamFhrpGroupsUpdateExecute(r ApiIpamFhrpGroupsUpdateRequest) (*FHRPGroup, *http.Response, error)

	/*
	IpamIpAddressesBulkDestroy Method for IpamIpAddressesBulkDestroy

	Delete a list of IP address objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpAddressesBulkDestroyRequest
	*/
	IpamIpAddressesBulkDestroy(ctx context.Context) ApiIpamIpAddressesBulkDestroyRequest

	// IpamIpAddressesBulkDestroyExecute executes the request
	IpamIpAddressesBulkDestroyExecute(r ApiIpamIpAddressesBulkDestroyRequest) (*http.Response, error)

	/*
	IpamIpAddressesBulkPartialUpdate Method for IpamIpAddressesBulkPartialUpdate

	Patch a list of IP address objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpAddressesBulkPartialUpdateRequest
	*/
	IpamIpAddressesBulkPartialUpdate(ctx context.Context) ApiIpamIpAddressesBulkPartialUpdateRequest

	// IpamIpAddressesBulkPartialUpdateExecute executes the request
	//  @return []IPAddress
	IpamIpAddressesBulkPartialUpdateExecute(r ApiIpamIpAddressesBulkPartialUpdateRequest) ([]IPAddress, *http.Response, error)

	/*
	IpamIpAddressesBulkUpdate Method for IpamIpAddressesBulkUpdate

	Put a list of IP address objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpAddressesBulkUpdateRequest
	*/
	IpamIpAddressesBulkUpdate(ctx context.Context) ApiIpamIpAddressesBulkUpdateRequest

	// IpamIpAddressesBulkUpdateExecute executes the request
	//  @return []IPAddress
	IpamIpAddressesBulkUpdateExecute(r ApiIpamIpAddressesBulkUpdateRequest) ([]IPAddress, *http.Response, error)

	/*
	IpamIpAddressesCreate Method for IpamIpAddressesCreate

	Post a list of IP address objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpAddressesCreateRequest
	*/
	IpamIpAddressesCreate(ctx context.Context) ApiIpamIpAddressesCreateRequest

	// IpamIpAddressesCreateExecute executes the request
	//  @return IPAddress
	IpamIpAddressesCreateExecute(r ApiIpamIpAddressesCreateRequest) (*IPAddress, *http.Response, error)

	/*
	IpamIpAddressesDestroy Method for IpamIpAddressesDestroy

	Delete a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP address.
	@return ApiIpamIpAddressesDestroyRequest
	*/
	IpamIpAddressesDestroy(ctx context.Context, id int32) ApiIpamIpAddressesDestroyRequest

	// IpamIpAddressesDestroyExecute executes the request
	IpamIpAddressesDestroyExecute(r ApiIpamIpAddressesDestroyRequest) (*http.Response, error)

	/*
	IpamIpAddressesList Method for IpamIpAddressesList

	Get a list of IP address objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpAddressesListRequest
	*/
	IpamIpAddressesList(ctx context.Context) ApiIpamIpAddressesListRequest

	// IpamIpAddressesListExecute executes the request
	//  @return PaginatedIPAddressList
	IpamIpAddressesListExecute(r ApiIpamIpAddressesListRequest) (*PaginatedIPAddressList, *http.Response, error)

	/*
	IpamIpAddressesPartialUpdate Method for IpamIpAddressesPartialUpdate

	Patch a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP address.
	@return ApiIpamIpAddressesPartialUpdateRequest
	*/
	IpamIpAddressesPartialUpdate(ctx context.Context, id int32) ApiIpamIpAddressesPartialUpdateRequest

	// IpamIpAddressesPartialUpdateExecute executes the request
	//  @return IPAddress
	IpamIpAddressesPartialUpdateExecute(r ApiIpamIpAddressesPartialUpdateRequest) (*IPAddress, *http.Response, error)

	/*
	IpamIpAddressesRetrieve Method for IpamIpAddressesRetrieve

	Get a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP address.
	@return ApiIpamIpAddressesRetrieveRequest
	*/
	IpamIpAddressesRetrieve(ctx context.Context, id int32) ApiIpamIpAddressesRetrieveRequest

	// IpamIpAddressesRetrieveExecute executes the request
	//  @return IPAddress
	IpamIpAddressesRetrieveExecute(r ApiIpamIpAddressesRetrieveRequest) (*IPAddress, *http.Response, error)

	/*
	IpamIpAddressesUpdate Method for IpamIpAddressesUpdate

	Put a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP address.
	@return ApiIpamIpAddressesUpdateRequest
	*/
	IpamIpAddressesUpdate(ctx context.Context, id int32) ApiIpamIpAddressesUpdateRequest

	// IpamIpAddressesUpdateExecute executes the request
	//  @return IPAddress
	IpamIpAddressesUpdateExecute(r ApiIpamIpAddressesUpdateRequest) (*IPAddress, *http.Response, error)

	/*
	IpamIpRangesAvailableIpsCreate Method for IpamIpRangesAvailableIpsCreate

	Post a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamIpRangesAvailableIpsCreateRequest
	*/
	IpamIpRangesAvailableIpsCreate(ctx context.Context, id int32) ApiIpamIpRangesAvailableIpsCreateRequest

	// IpamIpRangesAvailableIpsCreateExecute executes the request
	//  @return []IPAddress
	IpamIpRangesAvailableIpsCreateExecute(r ApiIpamIpRangesAvailableIpsCreateRequest) ([]IPAddress, *http.Response, error)

	/*
	IpamIpRangesAvailableIpsList Method for IpamIpRangesAvailableIpsList

	Get a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamIpRangesAvailableIpsListRequest
	*/
	IpamIpRangesAvailableIpsList(ctx context.Context, id int32) ApiIpamIpRangesAvailableIpsListRequest

	// IpamIpRangesAvailableIpsListExecute executes the request
	//  @return []AvailableIP
	IpamIpRangesAvailableIpsListExecute(r ApiIpamIpRangesAvailableIpsListRequest) ([]AvailableIP, *http.Response, error)

	/*
	IpamIpRangesBulkDestroy Method for IpamIpRangesBulkDestroy

	Delete a list of IP range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpRangesBulkDestroyRequest
	*/
	IpamIpRangesBulkDestroy(ctx context.Context) ApiIpamIpRangesBulkDestroyRequest

	// IpamIpRangesBulkDestroyExecute executes the request
	IpamIpRangesBulkDestroyExecute(r ApiIpamIpRangesBulkDestroyRequest) (*http.Response, error)

	/*
	IpamIpRangesBulkPartialUpdate Method for IpamIpRangesBulkPartialUpdate

	Patch a list of IP range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpRangesBulkPartialUpdateRequest
	*/
	IpamIpRangesBulkPartialUpdate(ctx context.Context) ApiIpamIpRangesBulkPartialUpdateRequest

	// IpamIpRangesBulkPartialUpdateExecute executes the request
	//  @return []IPRange
	IpamIpRangesBulkPartialUpdateExecute(r ApiIpamIpRangesBulkPartialUpdateRequest) ([]IPRange, *http.Response, error)

	/*
	IpamIpRangesBulkUpdate Method for IpamIpRangesBulkUpdate

	Put a list of IP range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpRangesBulkUpdateRequest
	*/
	IpamIpRangesBulkUpdate(ctx context.Context) ApiIpamIpRangesBulkUpdateRequest

	// IpamIpRangesBulkUpdateExecute executes the request
	//  @return []IPRange
	IpamIpRangesBulkUpdateExecute(r ApiIpamIpRangesBulkUpdateRequest) ([]IPRange, *http.Response, error)

	/*
	IpamIpRangesCreate Method for IpamIpRangesCreate

	Post a list of IP range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpRangesCreateRequest
	*/
	IpamIpRangesCreate(ctx context.Context) ApiIpamIpRangesCreateRequest

	// IpamIpRangesCreateExecute executes the request
	//  @return IPRange
	IpamIpRangesCreateExecute(r ApiIpamIpRangesCreateRequest) (*IPRange, *http.Response, error)

	/*
	IpamIpRangesDestroy Method for IpamIpRangesDestroy

	Delete a IP range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP range.
	@return ApiIpamIpRangesDestroyRequest
	*/
	IpamIpRangesDestroy(ctx context.Context, id int32) ApiIpamIpRangesDestroyRequest

	// IpamIpRangesDestroyExecute executes the request
	IpamIpRangesDestroyExecute(r ApiIpamIpRangesDestroyRequest) (*http.Response, error)

	/*
	IpamIpRangesList Method for IpamIpRangesList

	Get a list of IP range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpRangesListRequest
	*/
	IpamIpRangesList(ctx context.Context) ApiIpamIpRangesListRequest

	// IpamIpRangesListExecute executes the request
	//  @return PaginatedIPRangeList
	IpamIpRangesListExecute(r ApiIpamIpRangesListRequest) (*PaginatedIPRangeList, *http.Response, error)

	/*
	IpamIpRangesPartialUpdate Method for IpamIpRangesPartialUpdate

	Patch a IP range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP range.
	@return ApiIpamIpRangesPartialUpdateRequest
	*/
	IpamIpRangesPartialUpdate(ctx context.Context, id int32) ApiIpamIpRangesPartialUpdateRequest

	// IpamIpRangesPartialUpdateExecute executes the request
	//  @return IPRange
	IpamIpRangesPartialUpdateExecute(r ApiIpamIpRangesPartialUpdateRequest) (*IPRange, *http.Response, error)

	/*
	IpamIpRangesRetrieve Method for IpamIpRangesRetrieve

	Get a IP range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP range.
	@return ApiIpamIpRangesRetrieveRequest
	*/
	IpamIpRangesRetrieve(ctx context.Context, id int32) ApiIpamIpRangesRetrieveRequest

	// IpamIpRangesRetrieveExecute executes the request
	//  @return IPRange
	IpamIpRangesRetrieveExecute(r ApiIpamIpRangesRetrieveRequest) (*IPRange, *http.Response, error)

	/*
	IpamIpRangesUpdate Method for IpamIpRangesUpdate

	Put a IP range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP range.
	@return ApiIpamIpRangesUpdateRequest
	*/
	IpamIpRangesUpdate(ctx context.Context, id int32) ApiIpamIpRangesUpdateRequest

	// IpamIpRangesUpdateExecute executes the request
	//  @return IPRange
	IpamIpRangesUpdateExecute(r ApiIpamIpRangesUpdateRequest) (*IPRange, *http.Response, error)

	/*
	IpamPrefixesAvailableIpsCreate Method for IpamPrefixesAvailableIpsCreate

	Post a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamPrefixesAvailableIpsCreateRequest
	*/
	IpamPrefixesAvailableIpsCreate(ctx context.Context, id int32) ApiIpamPrefixesAvailableIpsCreateRequest

	// IpamPrefixesAvailableIpsCreateExecute executes the request
	//  @return []IPAddress
	IpamPrefixesAvailableIpsCreateExecute(r ApiIpamPrefixesAvailableIpsCreateRequest) ([]IPAddress, *http.Response, error)

	/*
	IpamPrefixesAvailableIpsList Method for IpamPrefixesAvailableIpsList

	Get a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamPrefixesAvailableIpsListRequest
	*/
	IpamPrefixesAvailableIpsList(ctx context.Context, id int32) ApiIpamPrefixesAvailableIpsListRequest

	// IpamPrefixesAvailableIpsListExecute executes the request
	//  @return []AvailableIP
	IpamPrefixesAvailableIpsListExecute(r ApiIpamPrefixesAvailableIpsListRequest) ([]AvailableIP, *http.Response, error)

	/*
	IpamPrefixesAvailablePrefixesCreate Method for IpamPrefixesAvailablePrefixesCreate

	Post a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamPrefixesAvailablePrefixesCreateRequest
	*/
	IpamPrefixesAvailablePrefixesCreate(ctx context.Context, id int32) ApiIpamPrefixesAvailablePrefixesCreateRequest

	// IpamPrefixesAvailablePrefixesCreateExecute executes the request
	//  @return []Prefix
	IpamPrefixesAvailablePrefixesCreateExecute(r ApiIpamPrefixesAvailablePrefixesCreateRequest) ([]Prefix, *http.Response, error)

	/*
	IpamPrefixesAvailablePrefixesList Method for IpamPrefixesAvailablePrefixesList

	Get a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamPrefixesAvailablePrefixesListRequest
	*/
	IpamPrefixesAvailablePrefixesList(ctx context.Context, id int32) ApiIpamPrefixesAvailablePrefixesListRequest

	// IpamPrefixesAvailablePrefixesListExecute executes the request
	//  @return []AvailablePrefix
	IpamPrefixesAvailablePrefixesListExecute(r ApiIpamPrefixesAvailablePrefixesListRequest) ([]AvailablePrefix, *http.Response, error)

	/*
	IpamPrefixesBulkDestroy Method for IpamPrefixesBulkDestroy

	Delete a list of prefix objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamPrefixesBulkDestroyRequest
	*/
	IpamPrefixesBulkDestroy(ctx context.Context) ApiIpamPrefixesBulkDestroyRequest

	// IpamPrefixesBulkDestroyExecute executes the request
	IpamPrefixesBulkDestroyExecute(r ApiIpamPrefixesBulkDestroyRequest) (*http.Response, error)

	/*
	IpamPrefixesBulkPartialUpdate Method for IpamPrefixesBulkPartialUpdate

	Patch a list of prefix objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamPrefixesBulkPartialUpdateRequest
	*/
	IpamPrefixesBulkPartialUpdate(ctx context.Context) ApiIpamPrefixesBulkPartialUpdateRequest

	// IpamPrefixesBulkPartialUpdateExecute executes the request
	//  @return []Prefix
	IpamPrefixesBulkPartialUpdateExecute(r ApiIpamPrefixesBulkPartialUpdateRequest) ([]Prefix, *http.Response, error)

	/*
	IpamPrefixesBulkUpdate Method for IpamPrefixesBulkUpdate

	Put a list of prefix objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamPrefixesBulkUpdateRequest
	*/
	IpamPrefixesBulkUpdate(ctx context.Context) ApiIpamPrefixesBulkUpdateRequest

	// IpamPrefixesBulkUpdateExecute executes the request
	//  @return []Prefix
	IpamPrefixesBulkUpdateExecute(r ApiIpamPrefixesBulkUpdateRequest) ([]Prefix, *http.Response, error)

	/*
	IpamPrefixesCreate Method for IpamPrefixesCreate

	Post a list of prefix objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamPrefixesCreateRequest
	*/
	IpamPrefixesCreate(ctx context.Context) ApiIpamPrefixesCreateRequest

	// IpamPrefixesCreateExecute executes the request
	//  @return Prefix
	IpamPrefixesCreateExecute(r ApiIpamPrefixesCreateRequest) (*Prefix, *http.Response, error)

	/*
	IpamPrefixesDestroy Method for IpamPrefixesDestroy

	Delete a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this prefix.
	@return ApiIpamPrefixesDestroyRequest
	*/
	IpamPrefixesDestroy(ctx context.Context, id int32) ApiIpamPrefixesDestroyRequest

	// IpamPrefixesDestroyExecute executes the request
	IpamPrefixesDestroyExecute(r ApiIpamPrefixesDestroyRequest) (*http.Response, error)

	/*
	IpamPrefixesList Method for IpamPrefixesList

	Get a list of prefix objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamPrefixesListRequest
	*/
	IpamPrefixesList(ctx context.Context) ApiIpamPrefixesListRequest

	// IpamPrefixesListExecute executes the request
	//  @return PaginatedPrefixList
	IpamPrefixesListExecute(r ApiIpamPrefixesListRequest) (*PaginatedPrefixList, *http.Response, error)

	/*
	IpamPrefixesPartialUpdate Method for IpamPrefixesPartialUpdate

	Patch a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this prefix.
	@return ApiIpamPrefixesPartialUpdateRequest
	*/
	IpamPrefixesPartialUpdate(ctx context.Context, id int32) ApiIpamPrefixesPartialUpdateRequest

	// IpamPrefixesPartialUpdateExecute executes the request
	//  @return Prefix
	IpamPrefixesPartialUpdateExecute(r ApiIpamPrefixesPartialUpdateRequest) (*Prefix, *http.Response, error)

	/*
	IpamPrefixesRetrieve Method for IpamPrefixesRetrieve

	Get a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this prefix.
	@return ApiIpamPrefixesRetrieveRequest
	*/
	IpamPrefixesRetrieve(ctx context.Context, id int32) ApiIpamPrefixesRetrieveRequest

	// IpamPrefixesRetrieveExecute executes the request
	//  @return Prefix
	IpamPrefixesRetrieveExecute(r ApiIpamPrefixesRetrieveRequest) (*Prefix, *http.Response, error)

	/*
	IpamPrefixesUpdate Method for IpamPrefixesUpdate

	Put a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this prefix.
	@return ApiIpamPrefixesUpdateRequest
	*/
	IpamPrefixesUpdate(ctx context.Context, id int32) ApiIpamPrefixesUpdateRequest

	// IpamPrefixesUpdateExecute executes the request
	//  @return Prefix
	IpamPrefixesUpdateExecute(r ApiIpamPrefixesUpdateRequest) (*Prefix, *http.Response, error)

	/*
	IpamRirsBulkDestroy Method for IpamRirsBulkDestroy

	Delete a list of RIR objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRirsBulkDestroyRequest
	*/
	IpamRirsBulkDestroy(ctx context.Context) ApiIpamRirsBulkDestroyRequest

	// IpamRirsBulkDestroyExecute executes the request
	IpamRirsBulkDestroyExecute(r ApiIpamRirsBulkDestroyRequest) (*http.Response, error)

	/*
	IpamRirsBulkPartialUpdate Method for IpamRirsBulkPartialUpdate

	Patch a list of RIR objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRirsBulkPartialUpdateRequest
	*/
	IpamRirsBulkPartialUpdate(ctx context.Context) ApiIpamRirsBulkPartialUpdateRequest

	// IpamRirsBulkPartialUpdateExecute executes the request
	//  @return []RIR
	IpamRirsBulkPartialUpdateExecute(r ApiIpamRirsBulkPartialUpdateRequest) ([]RIR, *http.Response, error)

	/*
	IpamRirsBulkUpdate Method for IpamRirsBulkUpdate

	Put a list of RIR objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRirsBulkUpdateRequest
	*/
	IpamRirsBulkUpdate(ctx context.Context) ApiIpamRirsBulkUpdateRequest

	// IpamRirsBulkUpdateExecute executes the request
	//  @return []RIR
	IpamRirsBulkUpdateExecute(r ApiIpamRirsBulkUpdateRequest) ([]RIR, *http.Response, error)

	/*
	IpamRirsCreate Method for IpamRirsCreate

	Post a list of RIR objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRirsCreateRequest
	*/
	IpamRirsCreate(ctx context.Context) ApiIpamRirsCreateRequest

	// IpamRirsCreateExecute executes the request
	//  @return RIR
	IpamRirsCreateExecute(r ApiIpamRirsCreateRequest) (*RIR, *http.Response, error)

	/*
	IpamRirsDestroy Method for IpamRirsDestroy

	Delete a RIR object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this RIR.
	@return ApiIpamRirsDestroyRequest
	*/
	IpamRirsDestroy(ctx context.Context, id int32) ApiIpamRirsDestroyRequest

	// IpamRirsDestroyExecute executes the request
	IpamRirsDestroyExecute(r ApiIpamRirsDestroyRequest) (*http.Response, error)

	/*
	IpamRirsList Method for IpamRirsList

	Get a list of RIR objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRirsListRequest
	*/
	IpamRirsList(ctx context.Context) ApiIpamRirsListRequest

	// IpamRirsListExecute executes the request
	//  @return PaginatedRIRList
	IpamRirsListExecute(r ApiIpamRirsListRequest) (*PaginatedRIRList, *http.Response, error)

	/*
	IpamRirsPartialUpdate Method for IpamRirsPartialUpdate

	Patch a RIR object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this RIR.
	@return ApiIpamRirsPartialUpdateRequest
	*/
	IpamRirsPartialUpdate(ctx context.Context, id int32) ApiIpamRirsPartialUpdateRequest

	// IpamRirsPartialUpdateExecute executes the request
	//  @return RIR
	IpamRirsPartialUpdateExecute(r ApiIpamRirsPartialUpdateRequest) (*RIR, *http.Response, error)

	/*
	IpamRirsRetrieve Method for IpamRirsRetrieve

	Get a RIR object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this RIR.
	@return ApiIpamRirsRetrieveRequest
	*/
	IpamRirsRetrieve(ctx context.Context, id int32) ApiIpamRirsRetrieveRequest

	// IpamRirsRetrieveExecute executes the request
	//  @return RIR
	IpamRirsRetrieveExecute(r ApiIpamRirsRetrieveRequest) (*RIR, *http.Response, error)

	/*
	IpamRirsUpdate Method for IpamRirsUpdate

	Put a RIR object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this RIR.
	@return ApiIpamRirsUpdateRequest
	*/
	IpamRirsUpdate(ctx context.Context, id int32) ApiIpamRirsUpdateRequest

	// IpamRirsUpdateExecute executes the request
	//  @return RIR
	IpamRirsUpdateExecute(r ApiIpamRirsUpdateRequest) (*RIR, *http.Response, error)

	/*
	IpamRolesBulkDestroy Method for IpamRolesBulkDestroy

	Delete a list of role objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRolesBulkDestroyRequest
	*/
	IpamRolesBulkDestroy(ctx context.Context) ApiIpamRolesBulkDestroyRequest

	// IpamRolesBulkDestroyExecute executes the request
	IpamRolesBulkDestroyExecute(r ApiIpamRolesBulkDestroyRequest) (*http.Response, error)

	/*
	IpamRolesBulkPartialUpdate Method for IpamRolesBulkPartialUpdate

	Patch a list of role objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRolesBulkPartialUpdateRequest
	*/
	IpamRolesBulkPartialUpdate(ctx context.Context) ApiIpamRolesBulkPartialUpdateRequest

	// IpamRolesBulkPartialUpdateExecute executes the request
	//  @return []Role
	IpamRolesBulkPartialUpdateExecute(r ApiIpamRolesBulkPartialUpdateRequest) ([]Role, *http.Response, error)

	/*
	IpamRolesBulkUpdate Method for IpamRolesBulkUpdate

	Put a list of role objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRolesBulkUpdateRequest
	*/
	IpamRolesBulkUpdate(ctx context.Context) ApiIpamRolesBulkUpdateRequest

	// IpamRolesBulkUpdateExecute executes the request
	//  @return []Role
	IpamRolesBulkUpdateExecute(r ApiIpamRolesBulkUpdateRequest) ([]Role, *http.Response, error)

	/*
	IpamRolesCreate Method for IpamRolesCreate

	Post a list of role objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRolesCreateRequest
	*/
	IpamRolesCreate(ctx context.Context) ApiIpamRolesCreateRequest

	// IpamRolesCreateExecute executes the request
	//  @return Role
	IpamRolesCreateExecute(r ApiIpamRolesCreateRequest) (*Role, *http.Response, error)

	/*
	IpamRolesDestroy Method for IpamRolesDestroy

	Delete a role object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this role.
	@return ApiIpamRolesDestroyRequest
	*/
	IpamRolesDestroy(ctx context.Context, id int32) ApiIpamRolesDestroyRequest

	// IpamRolesDestroyExecute executes the request
	IpamRolesDestroyExecute(r ApiIpamRolesDestroyRequest) (*http.Response, error)

	/*
	IpamRolesList Method for IpamRolesList

	Get a list of role objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRolesListRequest
	*/
	IpamRolesList(ctx context.Context) ApiIpamRolesListRequest

	// IpamRolesListExecute executes the request
	//  @return PaginatedRoleList
	IpamRolesListExecute(r ApiIpamRolesListRequest) (*PaginatedRoleList, *http.Response, error)

	/*
	IpamRolesPartialUpdate Method for IpamRolesPartialUpdate

	Patch a role object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this role.
	@return ApiIpamRolesPartialUpdateRequest
	*/
	IpamRolesPartialUpdate(ctx context.Context, id int32) ApiIpamRolesPartialUpdateRequest

	// IpamRolesPartialUpdateExecute executes the request
	//  @return Role
	IpamRolesPartialUpdateExecute(r ApiIpamRolesPartialUpdateRequest) (*Role, *http.Response, error)

	/*
	IpamRolesRetrieve Method for IpamRolesRetrieve

	Get a role object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this role.
	@return ApiIpamRolesRetrieveRequest
	*/
	IpamRolesRetrieve(ctx context.Context, id int32) ApiIpamRolesRetrieveRequest

	// IpamRolesRetrieveExecute executes the request
	//  @return Role
	IpamRolesRetrieveExecute(r ApiIpamRolesRetrieveRequest) (*Role, *http.Response, error)

	/*
	IpamRolesUpdate Method for IpamRolesUpdate

	Put a role object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this role.
	@return ApiIpamRolesUpdateRequest
	*/
	IpamRolesUpdate(ctx context.Context, id int32) ApiIpamRolesUpdateRequest

	// IpamRolesUpdateExecute executes the request
	//  @return Role
	IpamRolesUpdateExecute(r ApiIpamRolesUpdateRequest) (*Role, *http.Response, error)

	/*
	IpamRouteTargetsBulkDestroy Method for IpamRouteTargetsBulkDestroy

	Delete a list of route target objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRouteTargetsBulkDestroyRequest
	*/
	IpamRouteTargetsBulkDestroy(ctx context.Context) ApiIpamRouteTargetsBulkDestroyRequest

	// IpamRouteTargetsBulkDestroyExecute executes the request
	IpamRouteTargetsBulkDestroyExecute(r ApiIpamRouteTargetsBulkDestroyRequest) (*http.Response, error)

	/*
	IpamRouteTargetsBulkPartialUpdate Method for IpamRouteTargetsBulkPartialUpdate

	Patch a list of route target objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRouteTargetsBulkPartialUpdateRequest
	*/
	IpamRouteTargetsBulkPartialUpdate(ctx context.Context) ApiIpamRouteTargetsBulkPartialUpdateRequest

	// IpamRouteTargetsBulkPartialUpdateExecute executes the request
	//  @return []RouteTarget
	IpamRouteTargetsBulkPartialUpdateExecute(r ApiIpamRouteTargetsBulkPartialUpdateRequest) ([]RouteTarget, *http.Response, error)

	/*
	IpamRouteTargetsBulkUpdate Method for IpamRouteTargetsBulkUpdate

	Put a list of route target objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRouteTargetsBulkUpdateRequest
	*/
	IpamRouteTargetsBulkUpdate(ctx context.Context) ApiIpamRouteTargetsBulkUpdateRequest

	// IpamRouteTargetsBulkUpdateExecute executes the request
	//  @return []RouteTarget
	IpamRouteTargetsBulkUpdateExecute(r ApiIpamRouteTargetsBulkUpdateRequest) ([]RouteTarget, *http.Response, error)

	/*
	IpamRouteTargetsCreate Method for IpamRouteTargetsCreate

	Post a list of route target objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRouteTargetsCreateRequest
	*/
	IpamRouteTargetsCreate(ctx context.Context) ApiIpamRouteTargetsCreateRequest

	// IpamRouteTargetsCreateExecute executes the request
	//  @return RouteTarget
	IpamRouteTargetsCreateExecute(r ApiIpamRouteTargetsCreateRequest) (*RouteTarget, *http.Response, error)

	/*
	IpamRouteTargetsDestroy Method for IpamRouteTargetsDestroy

	Delete a route target object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this route target.
	@return ApiIpamRouteTargetsDestroyRequest
	*/
	IpamRouteTargetsDestroy(ctx context.Context, id int32) ApiIpamRouteTargetsDestroyRequest

	// IpamRouteTargetsDestroyExecute executes the request
	IpamRouteTargetsDestroyExecute(r ApiIpamRouteTargetsDestroyRequest) (*http.Response, error)

	/*
	IpamRouteTargetsList Method for IpamRouteTargetsList

	Get a list of route target objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRouteTargetsListRequest
	*/
	IpamRouteTargetsList(ctx context.Context) ApiIpamRouteTargetsListRequest

	// IpamRouteTargetsListExecute executes the request
	//  @return PaginatedRouteTargetList
	IpamRouteTargetsListExecute(r ApiIpamRouteTargetsListRequest) (*PaginatedRouteTargetList, *http.Response, error)

	/*
	IpamRouteTargetsPartialUpdate Method for IpamRouteTargetsPartialUpdate

	Patch a route target object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this route target.
	@return ApiIpamRouteTargetsPartialUpdateRequest
	*/
	IpamRouteTargetsPartialUpdate(ctx context.Context, id int32) ApiIpamRouteTargetsPartialUpdateRequest

	// IpamRouteTargetsPartialUpdateExecute executes the request
	//  @return RouteTarget
	IpamRouteTargetsPartialUpdateExecute(r ApiIpamRouteTargetsPartialUpdateRequest) (*RouteTarget, *http.Response, error)

	/*
	IpamRouteTargetsRetrieve Method for IpamRouteTargetsRetrieve

	Get a route target object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this route target.
	@return ApiIpamRouteTargetsRetrieveRequest
	*/
	IpamRouteTargetsRetrieve(ctx context.Context, id int32) ApiIpamRouteTargetsRetrieveRequest

	// IpamRouteTargetsRetrieveExecute executes the request
	//  @return RouteTarget
	IpamRouteTargetsRetrieveExecute(r ApiIpamRouteTargetsRetrieveRequest) (*RouteTarget, *http.Response, error)

	/*
	IpamRouteTargetsUpdate Method for IpamRouteTargetsUpdate

	Put a route target object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this route target.
	@return ApiIpamRouteTargetsUpdateRequest
	*/
	IpamRouteTargetsUpdate(ctx context.Context, id int32) ApiIpamRouteTargetsUpdateRequest

	// IpamRouteTargetsUpdateExecute executes the request
	//  @return RouteTarget
	IpamRouteTargetsUpdateExecute(r ApiIpamRouteTargetsUpdateRequest) (*RouteTarget, *http.Response, error)

	/*
	IpamServiceTemplatesBulkDestroy Method for IpamServiceTemplatesBulkDestroy

	Delete a list of service template objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServiceTemplatesBulkDestroyRequest
	*/
	IpamServiceTemplatesBulkDestroy(ctx context.Context) ApiIpamServiceTemplatesBulkDestroyRequest

	// IpamServiceTemplatesBulkDestroyExecute executes the request
	IpamServiceTemplatesBulkDestroyExecute(r ApiIpamServiceTemplatesBulkDestroyRequest) (*http.Response, error)

	/*
	IpamServiceTemplatesBulkPartialUpdate Method for IpamServiceTemplatesBulkPartialUpdate

	Patch a list of service template objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServiceTemplatesBulkPartialUpdateRequest
	*/
	IpamServiceTemplatesBulkPartialUpdate(ctx context.Context) ApiIpamServiceTemplatesBulkPartialUpdateRequest

	// IpamServiceTemplatesBulkPartialUpdateExecute executes the request
	//  @return []ServiceTemplate
	IpamServiceTemplatesBulkPartialUpdateExecute(r ApiIpamServiceTemplatesBulkPartialUpdateRequest) ([]ServiceTemplate, *http.Response, error)

	/*
	IpamServiceTemplatesBulkUpdate Method for IpamServiceTemplatesBulkUpdate

	Put a list of service template objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServiceTemplatesBulkUpdateRequest
	*/
	IpamServiceTemplatesBulkUpdate(ctx context.Context) ApiIpamServiceTemplatesBulkUpdateRequest

	// IpamServiceTemplatesBulkUpdateExecute executes the request
	//  @return []ServiceTemplate
	IpamServiceTemplatesBulkUpdateExecute(r ApiIpamServiceTemplatesBulkUpdateRequest) ([]ServiceTemplate, *http.Response, error)

	/*
	IpamServiceTemplatesCreate Method for IpamServiceTemplatesCreate

	Post a list of service template objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServiceTemplatesCreateRequest
	*/
	IpamServiceTemplatesCreate(ctx context.Context) ApiIpamServiceTemplatesCreateRequest

	// IpamServiceTemplatesCreateExecute executes the request
	//  @return ServiceTemplate
	IpamServiceTemplatesCreateExecute(r ApiIpamServiceTemplatesCreateRequest) (*ServiceTemplate, *http.Response, error)

	/*
	IpamServiceTemplatesDestroy Method for IpamServiceTemplatesDestroy

	Delete a service template object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service template.
	@return ApiIpamServiceTemplatesDestroyRequest
	*/
	IpamServiceTemplatesDestroy(ctx context.Context, id int32) ApiIpamServiceTemplatesDestroyRequest

	// IpamServiceTemplatesDestroyExecute executes the request
	IpamServiceTemplatesDestroyExecute(r ApiIpamServiceTemplatesDestroyRequest) (*http.Response, error)

	/*
	IpamServiceTemplatesList Method for IpamServiceTemplatesList

	Get a list of service template objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServiceTemplatesListRequest
	*/
	IpamServiceTemplatesList(ctx context.Context) ApiIpamServiceTemplatesListRequest

	// IpamServiceTemplatesListExecute executes the request
	//  @return PaginatedServiceTemplateList
	IpamServiceTemplatesListExecute(r ApiIpamServiceTemplatesListRequest) (*PaginatedServiceTemplateList, *http.Response, error)

	/*
	IpamServiceTemplatesPartialUpdate Method for IpamServiceTemplatesPartialUpdate

	Patch a service template object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service template.
	@return ApiIpamServiceTemplatesPartialUpdateRequest
	*/
	IpamServiceTemplatesPartialUpdate(ctx context.Context, id int32) ApiIpamServiceTemplatesPartialUpdateRequest

	// IpamServiceTemplatesPartialUpdateExecute executes the request
	//  @return ServiceTemplate
	IpamServiceTemplatesPartialUpdateExecute(r ApiIpamServiceTemplatesPartialUpdateRequest) (*ServiceTemplate, *http.Response, error)

	/*
	IpamServiceTemplatesRetrieve Method for IpamServiceTemplatesRetrieve

	Get a service template object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service template.
	@return ApiIpamServiceTemplatesRetrieveRequest
	*/
	IpamServiceTemplatesRetrieve(ctx context.Context, id int32) ApiIpamServiceTemplatesRetrieveRequest

	// IpamServiceTemplatesRetrieveExecute executes the request
	//  @return ServiceTemplate
	IpamServiceTemplatesRetrieveExecute(r ApiIpamServiceTemplatesRetrieveRequest) (*ServiceTemplate, *http.Response, error)

	/*
	IpamServiceTemplatesUpdate Method for IpamServiceTemplatesUpdate

	Put a service template object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service template.
	@return ApiIpamServiceTemplatesUpdateRequest
	*/
	IpamServiceTemplatesUpdate(ctx context.Context, id int32) ApiIpamServiceTemplatesUpdateRequest

	// IpamServiceTemplatesUpdateExecute executes the request
	//  @return ServiceTemplate
	IpamServiceTemplatesUpdateExecute(r ApiIpamServiceTemplatesUpdateRequest) (*ServiceTemplate, *http.Response, error)

	/*
	IpamServicesBulkDestroy Method for IpamServicesBulkDestroy

	Delete a list of service objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServicesBulkDestroyRequest
	*/
	IpamServicesBulkDestroy(ctx context.Context) ApiIpamServicesBulkDestroyRequest

	// IpamServicesBulkDestroyExecute executes the request
	IpamServicesBulkDestroyExecute(r ApiIpamServicesBulkDestroyRequest) (*http.Response, error)

	/*
	IpamServicesBulkPartialUpdate Method for IpamServicesBulkPartialUpdate

	Patch a list of service objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServicesBulkPartialUpdateRequest
	*/
	IpamServicesBulkPartialUpdate(ctx context.Context) ApiIpamServicesBulkPartialUpdateRequest

	// IpamServicesBulkPartialUpdateExecute executes the request
	//  @return []Service
	IpamServicesBulkPartialUpdateExecute(r ApiIpamServicesBulkPartialUpdateRequest) ([]Service, *http.Response, error)

	/*
	IpamServicesBulkUpdate Method for IpamServicesBulkUpdate

	Put a list of service objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServicesBulkUpdateRequest
	*/
	IpamServicesBulkUpdate(ctx context.Context) ApiIpamServicesBulkUpdateRequest

	// IpamServicesBulkUpdateExecute executes the request
	//  @return []Service
	IpamServicesBulkUpdateExecute(r ApiIpamServicesBulkUpdateRequest) ([]Service, *http.Response, error)

	/*
	IpamServicesCreate Method for IpamServicesCreate

	Post a list of service objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServicesCreateRequest
	*/
	IpamServicesCreate(ctx context.Context) ApiIpamServicesCreateRequest

	// IpamServicesCreateExecute executes the request
	//  @return Service
	IpamServicesCreateExecute(r ApiIpamServicesCreateRequest) (*Service, *http.Response, error)

	/*
	IpamServicesDestroy Method for IpamServicesDestroy

	Delete a service object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service.
	@return ApiIpamServicesDestroyRequest
	*/
	IpamServicesDestroy(ctx context.Context, id int32) ApiIpamServicesDestroyRequest

	// IpamServicesDestroyExecute executes the request
	IpamServicesDestroyExecute(r ApiIpamServicesDestroyRequest) (*http.Response, error)

	/*
	IpamServicesList Method for IpamServicesList

	Get a list of service objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServicesListRequest
	*/
	IpamServicesList(ctx context.Context) ApiIpamServicesListRequest

	// IpamServicesListExecute executes the request
	//  @return PaginatedServiceList
	IpamServicesListExecute(r ApiIpamServicesListRequest) (*PaginatedServiceList, *http.Response, error)

	/*
	IpamServicesPartialUpdate Method for IpamServicesPartialUpdate

	Patch a service object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service.
	@return ApiIpamServicesPartialUpdateRequest
	*/
	IpamServicesPartialUpdate(ctx context.Context, id int32) ApiIpamServicesPartialUpdateRequest

	// IpamServicesPartialUpdateExecute executes the request
	//  @return Service
	IpamServicesPartialUpdateExecute(r ApiIpamServicesPartialUpdateRequest) (*Service, *http.Response, error)

	/*
	IpamServicesRetrieve Method for IpamServicesRetrieve

	Get a service object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service.
	@return ApiIpamServicesRetrieveRequest
	*/
	IpamServicesRetrieve(ctx context.Context, id int32) ApiIpamServicesRetrieveRequest

	// IpamServicesRetrieveExecute executes the request
	//  @return Service
	IpamServicesRetrieveExecute(r ApiIpamServicesRetrieveRequest) (*Service, *http.Response, error)

	/*
	IpamServicesUpdate Method for IpamServicesUpdate

	Put a service object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service.
	@return ApiIpamServicesUpdateRequest
	*/
	IpamServicesUpdate(ctx context.Context, id int32) ApiIpamServicesUpdateRequest

	// IpamServicesUpdateExecute executes the request
	//  @return Service
	IpamServicesUpdateExecute(r ApiIpamServicesUpdateRequest) (*Service, *http.Response, error)

	/*
	IpamVlanGroupsAvailableVlansCreate Method for IpamVlanGroupsAvailableVlansCreate

	Post a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamVlanGroupsAvailableVlansCreateRequest
	*/
	IpamVlanGroupsAvailableVlansCreate(ctx context.Context, id int32) ApiIpamVlanGroupsAvailableVlansCreateRequest

	// IpamVlanGroupsAvailableVlansCreateExecute executes the request
	//  @return []VLAN
	IpamVlanGroupsAvailableVlansCreateExecute(r ApiIpamVlanGroupsAvailableVlansCreateRequest) ([]VLAN, *http.Response, error)

	/*
	IpamVlanGroupsAvailableVlansList Method for IpamVlanGroupsAvailableVlansList

	Get a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamVlanGroupsAvailableVlansListRequest
	*/
	IpamVlanGroupsAvailableVlansList(ctx context.Context, id int32) ApiIpamVlanGroupsAvailableVlansListRequest

	// IpamVlanGroupsAvailableVlansListExecute executes the request
	//  @return []AvailableVLAN
	IpamVlanGroupsAvailableVlansListExecute(r ApiIpamVlanGroupsAvailableVlansListRequest) ([]AvailableVLAN, *http.Response, error)

	/*
	IpamVlanGroupsBulkDestroy Method for IpamVlanGroupsBulkDestroy

	Delete a list of VLAN group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanGroupsBulkDestroyRequest
	*/
	IpamVlanGroupsBulkDestroy(ctx context.Context) ApiIpamVlanGroupsBulkDestroyRequest

	// IpamVlanGroupsBulkDestroyExecute executes the request
	IpamVlanGroupsBulkDestroyExecute(r ApiIpamVlanGroupsBulkDestroyRequest) (*http.Response, error)

	/*
	IpamVlanGroupsBulkPartialUpdate Method for IpamVlanGroupsBulkPartialUpdate

	Patch a list of VLAN group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanGroupsBulkPartialUpdateRequest
	*/
	IpamVlanGroupsBulkPartialUpdate(ctx context.Context) ApiIpamVlanGroupsBulkPartialUpdateRequest

	// IpamVlanGroupsBulkPartialUpdateExecute executes the request
	//  @return []VLANGroup
	IpamVlanGroupsBulkPartialUpdateExecute(r ApiIpamVlanGroupsBulkPartialUpdateRequest) ([]VLANGroup, *http.Response, error)

	/*
	IpamVlanGroupsBulkUpdate Method for IpamVlanGroupsBulkUpdate

	Put a list of VLAN group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanGroupsBulkUpdateRequest
	*/
	IpamVlanGroupsBulkUpdate(ctx context.Context) ApiIpamVlanGroupsBulkUpdateRequest

	// IpamVlanGroupsBulkUpdateExecute executes the request
	//  @return []VLANGroup
	IpamVlanGroupsBulkUpdateExecute(r ApiIpamVlanGroupsBulkUpdateRequest) ([]VLANGroup, *http.Response, error)

	/*
	IpamVlanGroupsCreate Method for IpamVlanGroupsCreate

	Post a list of VLAN group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanGroupsCreateRequest
	*/
	IpamVlanGroupsCreate(ctx context.Context) ApiIpamVlanGroupsCreateRequest

	// IpamVlanGroupsCreateExecute executes the request
	//  @return VLANGroup
	IpamVlanGroupsCreateExecute(r ApiIpamVlanGroupsCreateRequest) (*VLANGroup, *http.Response, error)

	/*
	IpamVlanGroupsDestroy Method for IpamVlanGroupsDestroy

	Delete a VLAN group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN group.
	@return ApiIpamVlanGroupsDestroyRequest
	*/
	IpamVlanGroupsDestroy(ctx context.Context, id int32) ApiIpamVlanGroupsDestroyRequest

	// IpamVlanGroupsDestroyExecute executes the request
	IpamVlanGroupsDestroyExecute(r ApiIpamVlanGroupsDestroyRequest) (*http.Response, error)

	/*
	IpamVlanGroupsList Method for IpamVlanGroupsList

	Get a list of VLAN group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanGroupsListRequest
	*/
	IpamVlanGroupsList(ctx context.Context) ApiIpamVlanGroupsListRequest

	// IpamVlanGroupsListExecute executes the request
	//  @return PaginatedVLANGroupList
	IpamVlanGroupsListExecute(r ApiIpamVlanGroupsListRequest) (*PaginatedVLANGroupList, *http.Response, error)

	/*
	IpamVlanGroupsPartialUpdate Method for IpamVlanGroupsPartialUpdate

	Patch a VLAN group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN group.
	@return ApiIpamVlanGroupsPartialUpdateRequest
	*/
	IpamVlanGroupsPartialUpdate(ctx context.Context, id int32) ApiIpamVlanGroupsPartialUpdateRequest

	// IpamVlanGroupsPartialUpdateExecute executes the request
	//  @return VLANGroup
	IpamVlanGroupsPartialUpdateExecute(r ApiIpamVlanGroupsPartialUpdateRequest) (*VLANGroup, *http.Response, error)

	/*
	IpamVlanGroupsRetrieve Method for IpamVlanGroupsRetrieve

	Get a VLAN group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN group.
	@return ApiIpamVlanGroupsRetrieveRequest
	*/
	IpamVlanGroupsRetrieve(ctx context.Context, id int32) ApiIpamVlanGroupsRetrieveRequest

	// IpamVlanGroupsRetrieveExecute executes the request
	//  @return VLANGroup
	IpamVlanGroupsRetrieveExecute(r ApiIpamVlanGroupsRetrieveRequest) (*VLANGroup, *http.Response, error)

	/*
	IpamVlanGroupsUpdate Method for IpamVlanGroupsUpdate

	Put a VLAN group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN group.
	@return ApiIpamVlanGroupsUpdateRequest
	*/
	IpamVlanGroupsUpdate(ctx context.Context, id int32) ApiIpamVlanGroupsUpdateRequest

	// IpamVlanGroupsUpdateExecute executes the request
	//  @return VLANGroup
	IpamVlanGroupsUpdateExecute(r ApiIpamVlanGroupsUpdateRequest) (*VLANGroup, *http.Response, error)

	/*
	IpamVlanTranslationPoliciesBulkDestroy Method for IpamVlanTranslationPoliciesBulkDestroy

	Delete a list of VLAN translation policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanTranslationPoliciesBulkDestroyRequest
	*/
	IpamVlanTranslationPoliciesBulkDestroy(ctx context.Context) ApiIpamVlanTranslationPoliciesBulkDestroyRequest

	// IpamVlanTranslationPoliciesBulkDestroyExecute executes the request
	IpamVlanTranslationPoliciesBulkDestroyExecute(r ApiIpamVlanTranslationPoliciesBulkDestroyRequest) (*http.Response, error)

	/*
	IpamVlanTranslationPoliciesBulkPartialUpdate Method for IpamVlanTranslationPoliciesBulkPartialUpdate

	Patch a list of VLAN translation policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanTranslationPoliciesBulkPartialUpdateRequest
	*/
	IpamVlanTranslationPoliciesBulkPartialUpdate(ctx context.Context) ApiIpamVlanTranslationPoliciesBulkPartialUpdateRequest

	// IpamVlanTranslationPoliciesBulkPartialUpdateExecute executes the request
	//  @return []VLANTranslationPolicy
	IpamVlanTranslationPoliciesBulkPartialUpdateExecute(r ApiIpamVlanTranslationPoliciesBulkPartialUpdateRequest) ([]VLANTranslationPolicy, *http.Response, error)

	/*
	IpamVlanTranslationPoliciesBulkUpdate Method for IpamVlanTranslationPoliciesBulkUpdate

	Put a list of VLAN translation policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanTranslationPoliciesBulkUpdateRequest
	*/
	IpamVlanTranslationPoliciesBulkUpdate(ctx context.Context) ApiIpamVlanTranslationPoliciesBulkUpdateRequest

	// IpamVlanTranslationPoliciesBulkUpdateExecute executes the request
	//  @return []VLANTranslationPolicy
	IpamVlanTranslationPoliciesBulkUpdateExecute(r ApiIpamVlanTranslationPoliciesBulkUpdateRequest) ([]VLANTranslationPolicy, *http.Response, error)

	/*
	IpamVlanTranslationPoliciesCreate Method for IpamVlanTranslationPoliciesCreate

	Post a list of VLAN translation policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanTranslationPoliciesCreateRequest
	*/
	IpamVlanTranslationPoliciesCreate(ctx context.Context) ApiIpamVlanTranslationPoliciesCreateRequest

	// IpamVlanTranslationPoliciesCreateExecute executes the request
	//  @return VLANTranslationPolicy
	IpamVlanTranslationPoliciesCreateExecute(r ApiIpamVlanTranslationPoliciesCreateRequest) (*VLANTranslationPolicy, *http.Response, error)

	/*
	IpamVlanTranslationPoliciesDestroy Method for IpamVlanTranslationPoliciesDestroy

	Delete a VLAN translation policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN translation policy.
	@return ApiIpamVlanTranslationPoliciesDestroyRequest
	*/
	IpamVlanTranslationPoliciesDestroy(ctx context.Context, id int32) ApiIpamVlanTranslationPoliciesDestroyRequest

	// IpamVlanTranslationPoliciesDestroyExecute executes the request
	IpamVlanTranslationPoliciesDestroyExecute(r ApiIpamVlanTranslationPoliciesDestroyRequest) (*http.Response, error)

	/*
	IpamVlanTranslationPoliciesList Method for IpamVlanTranslationPoliciesList

	Get a list of VLAN translation policy objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanTranslationPoliciesListRequest
	*/
	IpamVlanTranslationPoliciesList(ctx context.Context) ApiIpamVlanTranslationPoliciesListRequest

	// IpamVlanTranslationPoliciesListExecute executes the request
	//  @return PaginatedVLANTranslationPolicyList
	IpamVlanTranslationPoliciesListExecute(r ApiIpamVlanTranslationPoliciesListRequest) (*PaginatedVLANTranslationPolicyList, *http.Response, error)

	/*
	IpamVlanTranslationPoliciesPartialUpdate Method for IpamVlanTranslationPoliciesPartialUpdate

	Patch a VLAN translation policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN translation policy.
	@return ApiIpamVlanTranslationPoliciesPartialUpdateRequest
	*/
	IpamVlanTranslationPoliciesPartialUpdate(ctx context.Context, id int32) ApiIpamVlanTranslationPoliciesPartialUpdateRequest

	// IpamVlanTranslationPoliciesPartialUpdateExecute executes the request
	//  @return VLANTranslationPolicy
	IpamVlanTranslationPoliciesPartialUpdateExecute(r ApiIpamVlanTranslationPoliciesPartialUpdateRequest) (*VLANTranslationPolicy, *http.Response, error)

	/*
	IpamVlanTranslationPoliciesRetrieve Method for IpamVlanTranslationPoliciesRetrieve

	Get a VLAN translation policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN translation policy.
	@return ApiIpamVlanTranslationPoliciesRetrieveRequest
	*/
	IpamVlanTranslationPoliciesRetrieve(ctx context.Context, id int32) ApiIpamVlanTranslationPoliciesRetrieveRequest

	// IpamVlanTranslationPoliciesRetrieveExecute executes the request
	//  @return VLANTranslationPolicy
	IpamVlanTranslationPoliciesRetrieveExecute(r ApiIpamVlanTranslationPoliciesRetrieveRequest) (*VLANTranslationPolicy, *http.Response, error)

	/*
	IpamVlanTranslationPoliciesUpdate Method for IpamVlanTranslationPoliciesUpdate

	Put a VLAN translation policy object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN translation policy.
	@return ApiIpamVlanTranslationPoliciesUpdateRequest
	*/
	IpamVlanTranslationPoliciesUpdate(ctx context.Context, id int32) ApiIpamVlanTranslationPoliciesUpdateRequest

	// IpamVlanTranslationPoliciesUpdateExecute executes the request
	//  @return VLANTranslationPolicy
	IpamVlanTranslationPoliciesUpdateExecute(r ApiIpamVlanTranslationPoliciesUpdateRequest) (*VLANTranslationPolicy, *http.Response, error)

	/*
	IpamVlanTranslationRulesBulkDestroy Method for IpamVlanTranslationRulesBulkDestroy

	Delete a list of VLAN translation rule objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanTranslationRulesBulkDestroyRequest
	*/
	IpamVlanTranslationRulesBulkDestroy(ctx context.Context) ApiIpamVlanTranslationRulesBulkDestroyRequest

	// IpamVlanTranslationRulesBulkDestroyExecute executes the request
	IpamVlanTranslationRulesBulkDestroyExecute(r ApiIpamVlanTranslationRulesBulkDestroyRequest) (*http.Response, error)

	/*
	IpamVlanTranslationRulesBulkPartialUpdate Method for IpamVlanTranslationRulesBulkPartialUpdate

	Patch a list of VLAN translation rule objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanTranslationRulesBulkPartialUpdateRequest
	*/
	IpamVlanTranslationRulesBulkPartialUpdate(ctx context.Context) ApiIpamVlanTranslationRulesBulkPartialUpdateRequest

	// IpamVlanTranslationRulesBulkPartialUpdateExecute executes the request
	//  @return []VLANTranslationRule
	IpamVlanTranslationRulesBulkPartialUpdateExecute(r ApiIpamVlanTranslationRulesBulkPartialUpdateRequest) ([]VLANTranslationRule, *http.Response, error)

	/*
	IpamVlanTranslationRulesBulkUpdate Method for IpamVlanTranslationRulesBulkUpdate

	Put a list of VLAN translation rule objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanTranslationRulesBulkUpdateRequest
	*/
	IpamVlanTranslationRulesBulkUpdate(ctx context.Context) ApiIpamVlanTranslationRulesBulkUpdateRequest

	// IpamVlanTranslationRulesBulkUpdateExecute executes the request
	//  @return []VLANTranslationRule
	IpamVlanTranslationRulesBulkUpdateExecute(r ApiIpamVlanTranslationRulesBulkUpdateRequest) ([]VLANTranslationRule, *http.Response, error)

	/*
	IpamVlanTranslationRulesCreate Method for IpamVlanTranslationRulesCreate

	Post a list of VLAN translation rule objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanTranslationRulesCreateRequest
	*/
	IpamVlanTranslationRulesCreate(ctx context.Context) ApiIpamVlanTranslationRulesCreateRequest

	// IpamVlanTranslationRulesCreateExecute executes the request
	//  @return VLANTranslationRule
	IpamVlanTranslationRulesCreateExecute(r ApiIpamVlanTranslationRulesCreateRequest) (*VLANTranslationRule, *http.Response, error)

	/*
	IpamVlanTranslationRulesDestroy Method for IpamVlanTranslationRulesDestroy

	Delete a VLAN translation rule object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN translation rule.
	@return ApiIpamVlanTranslationRulesDestroyRequest
	*/
	IpamVlanTranslationRulesDestroy(ctx context.Context, id int32) ApiIpamVlanTranslationRulesDestroyRequest

	// IpamVlanTranslationRulesDestroyExecute executes the request
	IpamVlanTranslationRulesDestroyExecute(r ApiIpamVlanTranslationRulesDestroyRequest) (*http.Response, error)

	/*
	IpamVlanTranslationRulesList Method for IpamVlanTranslationRulesList

	Get a list of VLAN translation rule objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanTranslationRulesListRequest
	*/
	IpamVlanTranslationRulesList(ctx context.Context) ApiIpamVlanTranslationRulesListRequest

	// IpamVlanTranslationRulesListExecute executes the request
	//  @return PaginatedVLANTranslationRuleList
	IpamVlanTranslationRulesListExecute(r ApiIpamVlanTranslationRulesListRequest) (*PaginatedVLANTranslationRuleList, *http.Response, error)

	/*
	IpamVlanTranslationRulesPartialUpdate Method for IpamVlanTranslationRulesPartialUpdate

	Patch a VLAN translation rule object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN translation rule.
	@return ApiIpamVlanTranslationRulesPartialUpdateRequest
	*/
	IpamVlanTranslationRulesPartialUpdate(ctx context.Context, id int32) ApiIpamVlanTranslationRulesPartialUpdateRequest

	// IpamVlanTranslationRulesPartialUpdateExecute executes the request
	//  @return VLANTranslationRule
	IpamVlanTranslationRulesPartialUpdateExecute(r ApiIpamVlanTranslationRulesPartialUpdateRequest) (*VLANTranslationRule, *http.Response, error)

	/*
	IpamVlanTranslationRulesRetrieve Method for IpamVlanTranslationRulesRetrieve

	Get a VLAN translation rule object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN translation rule.
	@return ApiIpamVlanTranslationRulesRetrieveRequest
	*/
	IpamVlanTranslationRulesRetrieve(ctx context.Context, id int32) ApiIpamVlanTranslationRulesRetrieveRequest

	// IpamVlanTranslationRulesRetrieveExecute executes the request
	//  @return VLANTranslationRule
	IpamVlanTranslationRulesRetrieveExecute(r ApiIpamVlanTranslationRulesRetrieveRequest) (*VLANTranslationRule, *http.Response, error)

	/*
	IpamVlanTranslationRulesUpdate Method for IpamVlanTranslationRulesUpdate

	Put a VLAN translation rule object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN translation rule.
	@return ApiIpamVlanTranslationRulesUpdateRequest
	*/
	IpamVlanTranslationRulesUpdate(ctx context.Context, id int32) ApiIpamVlanTranslationRulesUpdateRequest

	// IpamVlanTranslationRulesUpdateExecute executes the request
	//  @return VLANTranslationRule
	IpamVlanTranslationRulesUpdateExecute(r ApiIpamVlanTranslationRulesUpdateRequest) (*VLANTranslationRule, *http.Response, error)

	/*
	IpamVlansBulkDestroy Method for IpamVlansBulkDestroy

	Delete a list of VLAN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlansBulkDestroyRequest
	*/
	IpamVlansBulkDestroy(ctx context.Context) ApiIpamVlansBulkDestroyRequest

	// IpamVlansBulkDestroyExecute executes the request
	IpamVlansBulkDestroyExecute(r ApiIpamVlansBulkDestroyRequest) (*http.Response, error)

	/*
	IpamVlansBulkPartialUpdate Method for IpamVlansBulkPartialUpdate

	Patch a list of VLAN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlansBulkPartialUpdateRequest
	*/
	IpamVlansBulkPartialUpdate(ctx context.Context) ApiIpamVlansBulkPartialUpdateRequest

	// IpamVlansBulkPartialUpdateExecute executes the request
	//  @return []VLAN
	IpamVlansBulkPartialUpdateExecute(r ApiIpamVlansBulkPartialUpdateRequest) ([]VLAN, *http.Response, error)

	/*
	IpamVlansBulkUpdate Method for IpamVlansBulkUpdate

	Put a list of VLAN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlansBulkUpdateRequest
	*/
	IpamVlansBulkUpdate(ctx context.Context) ApiIpamVlansBulkUpdateRequest

	// IpamVlansBulkUpdateExecute executes the request
	//  @return []VLAN
	IpamVlansBulkUpdateExecute(r ApiIpamVlansBulkUpdateRequest) ([]VLAN, *http.Response, error)

	/*
	IpamVlansCreate Method for IpamVlansCreate

	Post a list of VLAN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlansCreateRequest
	*/
	IpamVlansCreate(ctx context.Context) ApiIpamVlansCreateRequest

	// IpamVlansCreateExecute executes the request
	//  @return VLAN
	IpamVlansCreateExecute(r ApiIpamVlansCreateRequest) (*VLAN, *http.Response, error)

	/*
	IpamVlansDestroy Method for IpamVlansDestroy

	Delete a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN.
	@return ApiIpamVlansDestroyRequest
	*/
	IpamVlansDestroy(ctx context.Context, id int32) ApiIpamVlansDestroyRequest

	// IpamVlansDestroyExecute executes the request
	IpamVlansDestroyExecute(r ApiIpamVlansDestroyRequest) (*http.Response, error)

	/*
	IpamVlansList Method for IpamVlansList

	Get a list of VLAN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlansListRequest
	*/
	IpamVlansList(ctx context.Context) ApiIpamVlansListRequest

	// IpamVlansListExecute executes the request
	//  @return PaginatedVLANList
	IpamVlansListExecute(r ApiIpamVlansListRequest) (*PaginatedVLANList, *http.Response, error)

	/*
	IpamVlansPartialUpdate Method for IpamVlansPartialUpdate

	Patch a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN.
	@return ApiIpamVlansPartialUpdateRequest
	*/
	IpamVlansPartialUpdate(ctx context.Context, id int32) ApiIpamVlansPartialUpdateRequest

	// IpamVlansPartialUpdateExecute executes the request
	//  @return VLAN
	IpamVlansPartialUpdateExecute(r ApiIpamVlansPartialUpdateRequest) (*VLAN, *http.Response, error)

	/*
	IpamVlansRetrieve Method for IpamVlansRetrieve

	Get a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN.
	@return ApiIpamVlansRetrieveRequest
	*/
	IpamVlansRetrieve(ctx context.Context, id int32) ApiIpamVlansRetrieveRequest

	// IpamVlansRetrieveExecute executes the request
	//  @return VLAN
	IpamVlansRetrieveExecute(r ApiIpamVlansRetrieveRequest) (*VLAN, *http.Response, error)

	/*
	IpamVlansUpdate Method for IpamVlansUpdate

	Put a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN.
	@return ApiIpamVlansUpdateRequest
	*/
	IpamVlansUpdate(ctx context.Context, id int32) ApiIpamVlansUpdateRequest

	// IpamVlansUpdateExecute executes the request
	//  @return VLAN
	IpamVlansUpdateExecute(r ApiIpamVlansUpdateRequest) (*VLAN, *http.Response, error)

	/*
	IpamVrfsBulkDestroy Method for IpamVrfsBulkDestroy

	Delete a list of VRF objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVrfsBulkDestroyRequest
	*/
	IpamVrfsBulkDestroy(ctx context.Context) ApiIpamVrfsBulkDestroyRequest

	// IpamVrfsBulkDestroyExecute executes the request
	IpamVrfsBulkDestroyExecute(r ApiIpamVrfsBulkDestroyRequest) (*http.Response, error)

	/*
	IpamVrfsBulkPartialUpdate Method for IpamVrfsBulkPartialUpdate

	Patch a list of VRF objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVrfsBulkPartialUpdateRequest
	*/
	IpamVrfsBulkPartialUpdate(ctx context.Context) ApiIpamVrfsBulkPartialUpdateRequest

	// IpamVrfsBulkPartialUpdateExecute executes the request
	//  @return []VRF
	IpamVrfsBulkPartialUpdateExecute(r ApiIpamVrfsBulkPartialUpdateRequest) ([]VRF, *http.Response, error)

	/*
	IpamVrfsBulkUpdate Method for IpamVrfsBulkUpdate

	Put a list of VRF objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVrfsBulkUpdateRequest
	*/
	IpamVrfsBulkUpdate(ctx context.Context) ApiIpamVrfsBulkUpdateRequest

	// IpamVrfsBulkUpdateExecute executes the request
	//  @return []VRF
	IpamVrfsBulkUpdateExecute(r ApiIpamVrfsBulkUpdateRequest) ([]VRF, *http.Response, error)

	/*
	IpamVrfsCreate Method for IpamVrfsCreate

	Post a list of VRF objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVrfsCreateRequest
	*/
	IpamVrfsCreate(ctx context.Context) ApiIpamVrfsCreateRequest

	// IpamVrfsCreateExecute executes the request
	//  @return VRF
	IpamVrfsCreateExecute(r ApiIpamVrfsCreateRequest) (*VRF, *http.Response, error)

	/*
	IpamVrfsDestroy Method for IpamVrfsDestroy

	Delete a VRF object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VRF.
	@return ApiIpamVrfsDestroyRequest
	*/
	IpamVrfsDestroy(ctx context.Context, id int32) ApiIpamVrfsDestroyRequest

	// IpamVrfsDestroyExecute executes the request
	IpamVrfsDestroyExecute(r ApiIpamVrfsDestroyRequest) (*http.Response, error)

	/*
	IpamVrfsList Method for IpamVrfsList

	Get a list of VRF objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVrfsListRequest
	*/
	IpamVrfsList(ctx context.Context) ApiIpamVrfsListRequest

	// IpamVrfsListExecute executes the request
	//  @return PaginatedVRFList
	IpamVrfsListExecute(r ApiIpamVrfsListRequest) (*PaginatedVRFList, *http.Response, error)

	/*
	IpamVrfsPartialUpdate Method for IpamVrfsPartialUpdate

	Patch a VRF object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VRF.
	@return ApiIpamVrfsPartialUpdateRequest
	*/
	IpamVrfsPartialUpdate(ctx context.Context, id int32) ApiIpamVrfsPartialUpdateRequest

	// IpamVrfsPartialUpdateExecute executes the request
	//  @return VRF
	IpamVrfsPartialUpdateExecute(r ApiIpamVrfsPartialUpdateRequest) (*VRF, *http.Response, error)

	/*
	IpamVrfsRetrieve Method for IpamVrfsRetrieve

	Get a VRF object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VRF.
	@return ApiIpamVrfsRetrieveRequest
	*/
	IpamVrfsRetrieve(ctx context.Context, id int32) ApiIpamVrfsRetrieveRequest

	// IpamVrfsRetrieveExecute executes the request
	//  @return VRF
	IpamVrfsRetrieveExecute(r ApiIpamVrfsRetrieveRequest) (*VRF, *http.Response, error)

	/*
	IpamVrfsUpdate Method for IpamVrfsUpdate

	Put a VRF object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VRF.
	@return ApiIpamVrfsUpdateRequest
	*/
	IpamVrfsUpdate(ctx context.Context, id int32) ApiIpamVrfsUpdateRequest

	// IpamVrfsUpdateExecute executes the request
	//  @return VRF
	IpamVrfsUpdateExecute(r ApiIpamVrfsUpdateRequest) (*VRF, *http.Response, error)
}

// IpamAPIService IpamAPI service
type IpamAPIService service

type ApiIpamAggregatesBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	aggregateRequest *[]AggregateRequest
}

func (r ApiIpamAggregatesBulkDestroyRequest) AggregateRequest(aggregateRequest []AggregateRequest) ApiIpamAggregatesBulkDestroyRequest {
	r.aggregateRequest = &aggregateRequest
	return r
}

func (r ApiIpamAggregatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAggregatesBulkDestroyExecute(r)
}

/*
IpamAggregatesBulkDestroy Method for IpamAggregatesBulkDestroy

Delete a list of aggregate objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamAggregatesBulkDestroy(ctx context.Context) ApiIpamAggregatesBulkDestroyRequest {
	return ApiIpamAggregatesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAggregatesBulkDestroyExecute(r ApiIpamAggregatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aggregateRequest == nil {
		return nil, reportError("aggregateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAggregatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	aggregateRequest *[]AggregateRequest
}

func (r ApiIpamAggregatesBulkPartialUpdateRequest) AggregateRequest(aggregateRequest []AggregateRequest) ApiIpamAggregatesBulkPartialUpdateRequest {
	r.aggregateRequest = &aggregateRequest
	return r
}

func (r ApiIpamAggregatesBulkPartialUpdateRequest) Execute() ([]Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesBulkPartialUpdateExecute(r)
}

/*
IpamAggregatesBulkPartialUpdate Method for IpamAggregatesBulkPartialUpdate

Patch a list of aggregate objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAggregatesBulkPartialUpdate(ctx context.Context) ApiIpamAggregatesBulkPartialUpdateRequest {
	return ApiIpamAggregatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Aggregate
func (a *IpamAPIService) IpamAggregatesBulkPartialUpdateExecute(r ApiIpamAggregatesBulkPartialUpdateRequest) ([]Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aggregateRequest == nil {
		return localVarReturnValue, nil, reportError("aggregateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	aggregateRequest *[]AggregateRequest
}

func (r ApiIpamAggregatesBulkUpdateRequest) AggregateRequest(aggregateRequest []AggregateRequest) ApiIpamAggregatesBulkUpdateRequest {
	r.aggregateRequest = &aggregateRequest
	return r
}

func (r ApiIpamAggregatesBulkUpdateRequest) Execute() ([]Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesBulkUpdateExecute(r)
}

/*
IpamAggregatesBulkUpdate Method for IpamAggregatesBulkUpdate

Put a list of aggregate objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamAggregatesBulkUpdate(ctx context.Context) ApiIpamAggregatesBulkUpdateRequest {
	return ApiIpamAggregatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Aggregate
func (a *IpamAPIService) IpamAggregatesBulkUpdateExecute(r ApiIpamAggregatesBulkUpdateRequest) ([]Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aggregateRequest == nil {
		return localVarReturnValue, nil, reportError("aggregateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	writableAggregateRequest *WritableAggregateRequest
}

func (r ApiIpamAggregatesCreateRequest) WritableAggregateRequest(writableAggregateRequest WritableAggregateRequest) ApiIpamAggregatesCreateRequest {
	r.writableAggregateRequest = &writableAggregateRequest
	return r
}

func (r ApiIpamAggregatesCreateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesCreateExecute(r)
}

/*
IpamAggregatesCreate Method for IpamAggregatesCreate

Post a list of aggregate objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesCreateRequest
*/
func (a *IpamAPIService) IpamAggregatesCreate(ctx context.Context) ApiIpamAggregatesCreateRequest {
	return ApiIpamAggregatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamAPIService) IpamAggregatesCreateExecute(r ApiIpamAggregatesCreateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableAggregateRequest == nil {
		return localVarReturnValue, nil, reportError("writableAggregateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableAggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamAggregatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAggregatesDestroyExecute(r)
}

/*
IpamAggregatesDestroy Method for IpamAggregatesDestroy

Delete a aggregate object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this aggregate.
 @return ApiIpamAggregatesDestroyRequest
*/
func (a *IpamAPIService) IpamAggregatesDestroy(ctx context.Context, id int32) ApiIpamAggregatesDestroyRequest {
	return ApiIpamAggregatesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAggregatesDestroyExecute(r ApiIpamAggregatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAggregatesListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	dateAdded *[]string
	dateAddedEmpty *bool
	dateAddedGt *[]string
	dateAddedGte *[]string
	dateAddedLt *[]string
	dateAddedLte *[]string
	dateAddedN *[]string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	family *float32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	offset *int32
	ordering *string
	prefix *string
	q *string
	rir *[]string
	rirN *[]string
	rirId *[]int32
	rirIdN *[]int32
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*int32
	tenantIdN *[]*int32
	updatedByRequest *string
}

func (r ApiIpamAggregatesListRequest) Created(created []time.Time) ApiIpamAggregatesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamAggregatesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedGt(createdGt []time.Time) ApiIpamAggregatesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedGte(createdGte []time.Time) ApiIpamAggregatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedLt(createdLt []time.Time) ApiIpamAggregatesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedLte(createdLte []time.Time) ApiIpamAggregatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedN(createdN []time.Time) ApiIpamAggregatesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedByRequest(createdByRequest string) ApiIpamAggregatesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamAggregatesListRequest) DateAdded(dateAdded []string) ApiIpamAggregatesListRequest {
	r.dateAdded = &dateAdded
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedEmpty(dateAddedEmpty bool) ApiIpamAggregatesListRequest {
	r.dateAddedEmpty = &dateAddedEmpty
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedGt(dateAddedGt []string) ApiIpamAggregatesListRequest {
	r.dateAddedGt = &dateAddedGt
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedGte(dateAddedGte []string) ApiIpamAggregatesListRequest {
	r.dateAddedGte = &dateAddedGte
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedLt(dateAddedLt []string) ApiIpamAggregatesListRequest {
	r.dateAddedLt = &dateAddedLt
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedLte(dateAddedLte []string) ApiIpamAggregatesListRequest {
	r.dateAddedLte = &dateAddedLte
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedN(dateAddedN []string) ApiIpamAggregatesListRequest {
	r.dateAddedN = &dateAddedN
	return r
}

func (r ApiIpamAggregatesListRequest) Description(description []string) ApiIpamAggregatesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamAggregatesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionIc(descriptionIc []string) ApiIpamAggregatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionIe(descriptionIe []string) ApiIpamAggregatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionIew(descriptionIew []string) ApiIpamAggregatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamAggregatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionN(descriptionN []string) ApiIpamAggregatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionNic(descriptionNic []string) ApiIpamAggregatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionNie(descriptionNie []string) ApiIpamAggregatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamAggregatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamAggregatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamAggregatesListRequest) Family(family float32) ApiIpamAggregatesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamAggregatesListRequest) Id(id []int32) ApiIpamAggregatesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamAggregatesListRequest) IdEmpty(idEmpty bool) ApiIpamAggregatesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamAggregatesListRequest) IdGt(idGt []int32) ApiIpamAggregatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamAggregatesListRequest) IdGte(idGte []int32) ApiIpamAggregatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamAggregatesListRequest) IdLt(idLt []int32) ApiIpamAggregatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamAggregatesListRequest) IdLte(idLte []int32) ApiIpamAggregatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamAggregatesListRequest) IdN(idN []int32) ApiIpamAggregatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamAggregatesListRequest) Limit(limit int32) ApiIpamAggregatesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamAggregatesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamAggregatesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiIpamAggregatesListRequest) Offset(offset int32) ApiIpamAggregatesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamAggregatesListRequest) Ordering(ordering string) ApiIpamAggregatesListRequest {
	r.ordering = &ordering
	return r
}

// Prefix
func (r ApiIpamAggregatesListRequest) Prefix(prefix string) ApiIpamAggregatesListRequest {
	r.prefix = &prefix
	return r
}

// Search
func (r ApiIpamAggregatesListRequest) Q(q string) ApiIpamAggregatesListRequest {
	r.q = &q
	return r
}

// RIR (slug)
func (r ApiIpamAggregatesListRequest) Rir(rir []string) ApiIpamAggregatesListRequest {
	r.rir = &rir
	return r
}

// RIR (slug)
func (r ApiIpamAggregatesListRequest) RirN(rirN []string) ApiIpamAggregatesListRequest {
	r.rirN = &rirN
	return r
}

// RIR (ID)
func (r ApiIpamAggregatesListRequest) RirId(rirId []int32) ApiIpamAggregatesListRequest {
	r.rirId = &rirId
	return r
}

// RIR (ID)
func (r ApiIpamAggregatesListRequest) RirIdN(rirIdN []int32) ApiIpamAggregatesListRequest {
	r.rirIdN = &rirIdN
	return r
}

func (r ApiIpamAggregatesListRequest) Tag(tag []string) ApiIpamAggregatesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamAggregatesListRequest) TagN(tagN []string) ApiIpamAggregatesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamAggregatesListRequest) Tenant(tenant []string) ApiIpamAggregatesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamAggregatesListRequest) TenantN(tenantN []string) ApiIpamAggregatesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroup(tenantGroup []string) ApiIpamAggregatesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamAggregatesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamAggregatesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamAggregatesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamAggregatesListRequest) TenantId(tenantId []*int32) ApiIpamAggregatesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamAggregatesListRequest) TenantIdN(tenantIdN []*int32) ApiIpamAggregatesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamAggregatesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamAggregatesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamAggregatesListRequest) Execute() (*PaginatedAggregateList, *http.Response, error) {
	return r.ApiService.IpamAggregatesListExecute(r)
}

/*
IpamAggregatesList Method for IpamAggregatesList

Get a list of aggregate objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesListRequest
*/
func (a *IpamAPIService) IpamAggregatesList(ctx context.Context) ApiIpamAggregatesListRequest {
	return ApiIpamAggregatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedAggregateList
func (a *IpamAPIService) IpamAggregatesListExecute(r ApiIpamAggregatesListRequest) (*PaginatedAggregateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedAggregateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.dateAdded != nil {
		t := *r.dateAdded
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added", t, "form", "multi")
		}
	}
	if r.dateAddedEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__empty", r.dateAddedEmpty, "form", "")
	}
	if r.dateAddedGt != nil {
		t := *r.dateAddedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__gt", t, "form", "multi")
		}
	}
	if r.dateAddedGte != nil {
		t := *r.dateAddedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__gte", t, "form", "multi")
		}
	}
	if r.dateAddedLt != nil {
		t := *r.dateAddedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__lt", t, "form", "multi")
		}
	}
	if r.dateAddedLte != nil {
		t := *r.dateAddedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__lte", t, "form", "multi")
		}
	}
	if r.dateAddedN != nil {
		t := *r.dateAddedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__n", t, "form", "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.family != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "family", r.family, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.rir != nil {
		t := *r.rir
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir", t, "form", "multi")
		}
	}
	if r.rirN != nil {
		t := *r.rirN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", t, "form", "multi")
		}
	}
	if r.rirId != nil {
		t := *r.rirId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", t, "form", "multi")
		}
	}
	if r.rirIdN != nil {
		t := *r.rirIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "form", "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedWritableAggregateRequest *PatchedWritableAggregateRequest
}

func (r ApiIpamAggregatesPartialUpdateRequest) PatchedWritableAggregateRequest(patchedWritableAggregateRequest PatchedWritableAggregateRequest) ApiIpamAggregatesPartialUpdateRequest {
	r.patchedWritableAggregateRequest = &patchedWritableAggregateRequest
	return r
}

func (r ApiIpamAggregatesPartialUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesPartialUpdateExecute(r)
}

/*
IpamAggregatesPartialUpdate Method for IpamAggregatesPartialUpdate

Patch a aggregate object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this aggregate.
 @return ApiIpamAggregatesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAggregatesPartialUpdate(ctx context.Context, id int32) ApiIpamAggregatesPartialUpdateRequest {
	return ApiIpamAggregatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamAPIService) IpamAggregatesPartialUpdateExecute(r ApiIpamAggregatesPartialUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableAggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamAggregatesRetrieveRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesRetrieveExecute(r)
}

/*
IpamAggregatesRetrieve Method for IpamAggregatesRetrieve

Get a aggregate object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this aggregate.
 @return ApiIpamAggregatesRetrieveRequest
*/
func (a *IpamAPIService) IpamAggregatesRetrieve(ctx context.Context, id int32) ApiIpamAggregatesRetrieveRequest {
	return ApiIpamAggregatesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamAPIService) IpamAggregatesRetrieveExecute(r ApiIpamAggregatesRetrieveRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	writableAggregateRequest *WritableAggregateRequest
}

func (r ApiIpamAggregatesUpdateRequest) WritableAggregateRequest(writableAggregateRequest WritableAggregateRequest) ApiIpamAggregatesUpdateRequest {
	r.writableAggregateRequest = &writableAggregateRequest
	return r
}

func (r ApiIpamAggregatesUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesUpdateExecute(r)
}

/*
IpamAggregatesUpdate Method for IpamAggregatesUpdate

Put a aggregate object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this aggregate.
 @return ApiIpamAggregatesUpdateRequest
*/
func (a *IpamAPIService) IpamAggregatesUpdate(ctx context.Context, id int32) ApiIpamAggregatesUpdateRequest {
	return ApiIpamAggregatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamAPIService) IpamAggregatesUpdateExecute(r ApiIpamAggregatesUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableAggregateRequest == nil {
		return localVarReturnValue, nil, reportError("writableAggregateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableAggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesAvailableAsnsCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	aSNRequest *[]ASNRequest
}

func (r ApiIpamAsnRangesAvailableAsnsCreateRequest) ASNRequest(aSNRequest []ASNRequest) ApiIpamAsnRangesAvailableAsnsCreateRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnRangesAvailableAsnsCreateRequest) Execute() ([]ASN, *http.Response, error) {
	return r.ApiService.IpamAsnRangesAvailableAsnsCreateExecute(r)
}

/*
IpamAsnRangesAvailableAsnsCreate Method for IpamAsnRangesAvailableAsnsCreate

Post a ASN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIpamAsnRangesAvailableAsnsCreateRequest
*/
func (a *IpamAPIService) IpamAsnRangesAvailableAsnsCreate(ctx context.Context, id int32) ApiIpamAsnRangesAvailableAsnsCreateRequest {
	return ApiIpamAsnRangesAvailableAsnsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ASN
func (a *IpamAPIService) IpamAsnRangesAvailableAsnsCreateExecute(r ApiIpamAsnRangesAvailableAsnsCreateRequest) ([]ASN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesAvailableAsnsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/available-asns/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesAvailableAsnsListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamAsnRangesAvailableAsnsListRequest) Execute() ([]AvailableASN, *http.Response, error) {
	return r.ApiService.IpamAsnRangesAvailableAsnsListExecute(r)
}

/*
IpamAsnRangesAvailableAsnsList Method for IpamAsnRangesAvailableAsnsList

Get a ASN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIpamAsnRangesAvailableAsnsListRequest
*/
func (a *IpamAPIService) IpamAsnRangesAvailableAsnsList(ctx context.Context, id int32) ApiIpamAsnRangesAvailableAsnsListRequest {
	return ApiIpamAsnRangesAvailableAsnsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []AvailableASN
func (a *IpamAPIService) IpamAsnRangesAvailableAsnsListExecute(r ApiIpamAsnRangesAvailableAsnsListRequest) ([]AvailableASN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AvailableASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesAvailableAsnsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/available-asns/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	aSNRangeRequest *[]ASNRangeRequest
}

func (r ApiIpamAsnRangesBulkDestroyRequest) ASNRangeRequest(aSNRangeRequest []ASNRangeRequest) ApiIpamAsnRangesBulkDestroyRequest {
	r.aSNRangeRequest = &aSNRangeRequest
	return r
}

func (r ApiIpamAsnRangesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAsnRangesBulkDestroyExecute(r)
}

/*
IpamAsnRangesBulkDestroy Method for IpamAsnRangesBulkDestroy

Delete a list of ASN range objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAsnRangesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamAsnRangesBulkDestroy(ctx context.Context) ApiIpamAsnRangesBulkDestroyRequest {
	return ApiIpamAsnRangesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAsnRangesBulkDestroyExecute(r ApiIpamAsnRangesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRangeRequest == nil {
		return nil, reportError("aSNRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAsnRangesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	aSNRangeRequest *[]ASNRangeRequest
}

func (r ApiIpamAsnRangesBulkPartialUpdateRequest) ASNRangeRequest(aSNRangeRequest []ASNRangeRequest) ApiIpamAsnRangesBulkPartialUpdateRequest {
	r.aSNRangeRequest = &aSNRangeRequest
	return r
}

func (r ApiIpamAsnRangesBulkPartialUpdateRequest) Execute() ([]ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesBulkPartialUpdateExecute(r)
}

/*
IpamAsnRangesBulkPartialUpdate Method for IpamAsnRangesBulkPartialUpdate

Patch a list of ASN range objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAsnRangesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAsnRangesBulkPartialUpdate(ctx context.Context) ApiIpamAsnRangesBulkPartialUpdateRequest {
	return ApiIpamAsnRangesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ASNRange
func (a *IpamAPIService) IpamAsnRangesBulkPartialUpdateExecute(r ApiIpamAsnRangesBulkPartialUpdateRequest) ([]ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRangeRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	aSNRangeRequest *[]ASNRangeRequest
}

func (r ApiIpamAsnRangesBulkUpdateRequest) ASNRangeRequest(aSNRangeRequest []ASNRangeRequest) ApiIpamAsnRangesBulkUpdateRequest {
	r.aSNRangeRequest = &aSNRangeRequest
	return r
}

func (r ApiIpamAsnRangesBulkUpdateRequest) Execute() ([]ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesBulkUpdateExecute(r)
}

/*
IpamAsnRangesBulkUpdate Method for IpamAsnRangesBulkUpdate

Put a list of ASN range objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAsnRangesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamAsnRangesBulkUpdate(ctx context.Context) ApiIpamAsnRangesBulkUpdateRequest {
	return ApiIpamAsnRangesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ASNRange
func (a *IpamAPIService) IpamAsnRangesBulkUpdateExecute(r ApiIpamAsnRangesBulkUpdateRequest) ([]ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRangeRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	aSNRangeRequest *ASNRangeRequest
}

func (r ApiIpamAsnRangesCreateRequest) ASNRangeRequest(aSNRangeRequest ASNRangeRequest) ApiIpamAsnRangesCreateRequest {
	r.aSNRangeRequest = &aSNRangeRequest
	return r
}

func (r ApiIpamAsnRangesCreateRequest) Execute() (*ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesCreateExecute(r)
}

/*
IpamAsnRangesCreate Method for IpamAsnRangesCreate

Post a list of ASN range objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAsnRangesCreateRequest
*/
func (a *IpamAPIService) IpamAsnRangesCreate(ctx context.Context) ApiIpamAsnRangesCreateRequest {
	return ApiIpamAsnRangesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ASNRange
func (a *IpamAPIService) IpamAsnRangesCreateExecute(r ApiIpamAsnRangesCreateRequest) (*ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRangeRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamAsnRangesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAsnRangesDestroyExecute(r)
}

/*
IpamAsnRangesDestroy Method for IpamAsnRangesDestroy

Delete a ASN range object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this ASN range.
 @return ApiIpamAsnRangesDestroyRequest
*/
func (a *IpamAPIService) IpamAsnRangesDestroy(ctx context.Context, id int32) ApiIpamAsnRangesDestroyRequest {
	return ApiIpamAsnRangesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAsnRangesDestroyExecute(r ApiIpamAsnRangesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAsnRangesListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	end *[]int32
	endEmpty *bool
	endGt *[]int32
	endGte *[]int32
	endLt *[]int32
	endLte *[]int32
	endN *[]int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	rir *[]string
	rirN *[]string
	rirId *[]int32
	rirIdN *[]int32
	slug *[]string
	slugEmpty *bool
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNisw *[]string
	start *[]int32
	startEmpty *bool
	startGt *[]int32
	startGte *[]int32
	startLt *[]int32
	startLte *[]int32
	startN *[]int32
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*int32
	tenantIdN *[]*int32
	updatedByRequest *string
}

func (r ApiIpamAsnRangesListRequest) Created(created []time.Time) ApiIpamAsnRangesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamAsnRangesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedGt(createdGt []time.Time) ApiIpamAsnRangesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedGte(createdGte []time.Time) ApiIpamAsnRangesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedLt(createdLt []time.Time) ApiIpamAsnRangesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedLte(createdLte []time.Time) ApiIpamAsnRangesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedN(createdN []time.Time) ApiIpamAsnRangesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedByRequest(createdByRequest string) ApiIpamAsnRangesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamAsnRangesListRequest) Description(description []string) ApiIpamAsnRangesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamAsnRangesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionIc(descriptionIc []string) ApiIpamAsnRangesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionIe(descriptionIe []string) ApiIpamAsnRangesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionIew(descriptionIew []string) ApiIpamAsnRangesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamAsnRangesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionN(descriptionN []string) ApiIpamAsnRangesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionNic(descriptionNic []string) ApiIpamAsnRangesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionNie(descriptionNie []string) ApiIpamAsnRangesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamAsnRangesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamAsnRangesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamAsnRangesListRequest) End(end []int32) ApiIpamAsnRangesListRequest {
	r.end = &end
	return r
}

func (r ApiIpamAsnRangesListRequest) EndEmpty(endEmpty bool) ApiIpamAsnRangesListRequest {
	r.endEmpty = &endEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) EndGt(endGt []int32) ApiIpamAsnRangesListRequest {
	r.endGt = &endGt
	return r
}

func (r ApiIpamAsnRangesListRequest) EndGte(endGte []int32) ApiIpamAsnRangesListRequest {
	r.endGte = &endGte
	return r
}

func (r ApiIpamAsnRangesListRequest) EndLt(endLt []int32) ApiIpamAsnRangesListRequest {
	r.endLt = &endLt
	return r
}

func (r ApiIpamAsnRangesListRequest) EndLte(endLte []int32) ApiIpamAsnRangesListRequest {
	r.endLte = &endLte
	return r
}

func (r ApiIpamAsnRangesListRequest) EndN(endN []int32) ApiIpamAsnRangesListRequest {
	r.endN = &endN
	return r
}

func (r ApiIpamAsnRangesListRequest) Id(id []int32) ApiIpamAsnRangesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamAsnRangesListRequest) IdEmpty(idEmpty bool) ApiIpamAsnRangesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) IdGt(idGt []int32) ApiIpamAsnRangesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamAsnRangesListRequest) IdGte(idGte []int32) ApiIpamAsnRangesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamAsnRangesListRequest) IdLt(idLt []int32) ApiIpamAsnRangesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamAsnRangesListRequest) IdLte(idLte []int32) ApiIpamAsnRangesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamAsnRangesListRequest) IdN(idN []int32) ApiIpamAsnRangesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamAsnRangesListRequest) Limit(limit int32) ApiIpamAsnRangesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamAsnRangesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamAsnRangesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamAsnRangesListRequest) Name(name []string) ApiIpamAsnRangesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamAsnRangesListRequest) NameEmpty(nameEmpty bool) ApiIpamAsnRangesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) NameIc(nameIc []string) ApiIpamAsnRangesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamAsnRangesListRequest) NameIe(nameIe []string) ApiIpamAsnRangesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamAsnRangesListRequest) NameIew(nameIew []string) ApiIpamAsnRangesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamAsnRangesListRequest) NameIsw(nameIsw []string) ApiIpamAsnRangesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamAsnRangesListRequest) NameN(nameN []string) ApiIpamAsnRangesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamAsnRangesListRequest) NameNic(nameNic []string) ApiIpamAsnRangesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamAsnRangesListRequest) NameNie(nameNie []string) ApiIpamAsnRangesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamAsnRangesListRequest) NameNiew(nameNiew []string) ApiIpamAsnRangesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamAsnRangesListRequest) NameNisw(nameNisw []string) ApiIpamAsnRangesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamAsnRangesListRequest) Offset(offset int32) ApiIpamAsnRangesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamAsnRangesListRequest) Ordering(ordering string) ApiIpamAsnRangesListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamAsnRangesListRequest) Q(q string) ApiIpamAsnRangesListRequest {
	r.q = &q
	return r
}

// RIR (slug)
func (r ApiIpamAsnRangesListRequest) Rir(rir []string) ApiIpamAsnRangesListRequest {
	r.rir = &rir
	return r
}

// RIR (slug)
func (r ApiIpamAsnRangesListRequest) RirN(rirN []string) ApiIpamAsnRangesListRequest {
	r.rirN = &rirN
	return r
}

// RIR (ID)
func (r ApiIpamAsnRangesListRequest) RirId(rirId []int32) ApiIpamAsnRangesListRequest {
	r.rirId = &rirId
	return r
}

// RIR (ID)
func (r ApiIpamAsnRangesListRequest) RirIdN(rirIdN []int32) ApiIpamAsnRangesListRequest {
	r.rirIdN = &rirIdN
	return r
}

func (r ApiIpamAsnRangesListRequest) Slug(slug []string) ApiIpamAsnRangesListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugEmpty(slugEmpty bool) ApiIpamAsnRangesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugIc(slugIc []string) ApiIpamAsnRangesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugIe(slugIe []string) ApiIpamAsnRangesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugIew(slugIew []string) ApiIpamAsnRangesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugIsw(slugIsw []string) ApiIpamAsnRangesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugN(slugN []string) ApiIpamAsnRangesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugNic(slugNic []string) ApiIpamAsnRangesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugNie(slugNie []string) ApiIpamAsnRangesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugNiew(slugNiew []string) ApiIpamAsnRangesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugNisw(slugNisw []string) ApiIpamAsnRangesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamAsnRangesListRequest) Start(start []int32) ApiIpamAsnRangesListRequest {
	r.start = &start
	return r
}

func (r ApiIpamAsnRangesListRequest) StartEmpty(startEmpty bool) ApiIpamAsnRangesListRequest {
	r.startEmpty = &startEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) StartGt(startGt []int32) ApiIpamAsnRangesListRequest {
	r.startGt = &startGt
	return r
}

func (r ApiIpamAsnRangesListRequest) StartGte(startGte []int32) ApiIpamAsnRangesListRequest {
	r.startGte = &startGte
	return r
}

func (r ApiIpamAsnRangesListRequest) StartLt(startLt []int32) ApiIpamAsnRangesListRequest {
	r.startLt = &startLt
	return r
}

func (r ApiIpamAsnRangesListRequest) StartLte(startLte []int32) ApiIpamAsnRangesListRequest {
	r.startLte = &startLte
	return r
}

func (r ApiIpamAsnRangesListRequest) StartN(startN []int32) ApiIpamAsnRangesListRequest {
	r.startN = &startN
	return r
}

func (r ApiIpamAsnRangesListRequest) Tag(tag []string) ApiIpamAsnRangesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamAsnRangesListRequest) TagN(tagN []string) ApiIpamAsnRangesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamAsnRangesListRequest) Tenant(tenant []string) ApiIpamAsnRangesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamAsnRangesListRequest) TenantN(tenantN []string) ApiIpamAsnRangesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamAsnRangesListRequest) TenantGroup(tenantGroup []string) ApiIpamAsnRangesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamAsnRangesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamAsnRangesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamAsnRangesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamAsnRangesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamAsnRangesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamAsnRangesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamAsnRangesListRequest) TenantId(tenantId []*int32) ApiIpamAsnRangesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamAsnRangesListRequest) TenantIdN(tenantIdN []*int32) ApiIpamAsnRangesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamAsnRangesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamAsnRangesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamAsnRangesListRequest) Execute() (*PaginatedASNRangeList, *http.Response, error) {
	return r.ApiService.IpamAsnRangesListExecute(r)
}

/*
IpamAsnRangesList Method for IpamAsnRangesList

Get a list of ASN range objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAsnRangesListRequest
*/
func (a *IpamAPIService) IpamAsnRangesList(ctx context.Context) ApiIpamAsnRangesListRequest {
	return ApiIpamAsnRangesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedASNRangeList
func (a *IpamAPIService) IpamAsnRangesListExecute(r ApiIpamAsnRangesListRequest) (*PaginatedASNRangeList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedASNRangeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.end != nil {
		t := *r.end
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end", t, "form", "multi")
		}
	}
	if r.endEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end__empty", r.endEmpty, "form", "")
	}
	if r.endGt != nil {
		t := *r.endGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end__gt", t, "form", "multi")
		}
	}
	if r.endGte != nil {
		t := *r.endGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end__gte", t, "form", "multi")
		}
	}
	if r.endLt != nil {
		t := *r.endLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end__lt", t, "form", "multi")
		}
	}
	if r.endLte != nil {
		t := *r.endLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end__lte", t, "form", "multi")
		}
	}
	if r.endN != nil {
		t := *r.endN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.rir != nil {
		t := *r.rir
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir", t, "form", "multi")
		}
	}
	if r.rirN != nil {
		t := *r.rirN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", t, "form", "multi")
		}
	}
	if r.rirId != nil {
		t := *r.rirId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", t, "form", "multi")
		}
	}
	if r.rirIdN != nil {
		t := *r.rirIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", t, "form", "multi")
		}
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug", t, "form", "multi")
		}
	}
	if r.slugEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slug__empty", r.slugEmpty, "form", "")
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", t, "form", "multi")
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", t, "form", "multi")
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", t, "form", "multi")
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", t, "form", "multi")
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", t, "form", "multi")
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", t, "form", "multi")
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", t, "form", "multi")
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", t, "form", "multi")
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", t, "form", "multi")
		}
	}
	if r.start != nil {
		t := *r.start
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start", t, "form", "multi")
		}
	}
	if r.startEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start__empty", r.startEmpty, "form", "")
	}
	if r.startGt != nil {
		t := *r.startGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start__gt", t, "form", "multi")
		}
	}
	if r.startGte != nil {
		t := *r.startGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start__gte", t, "form", "multi")
		}
	}
	if r.startLt != nil {
		t := *r.startLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start__lt", t, "form", "multi")
		}
	}
	if r.startLte != nil {
		t := *r.startLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start__lte", t, "form", "multi")
		}
	}
	if r.startN != nil {
		t := *r.startN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start__n", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "form", "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedASNRangeRequest *PatchedASNRangeRequest
}

func (r ApiIpamAsnRangesPartialUpdateRequest) PatchedASNRangeRequest(patchedASNRangeRequest PatchedASNRangeRequest) ApiIpamAsnRangesPartialUpdateRequest {
	r.patchedASNRangeRequest = &patchedASNRangeRequest
	return r
}

func (r ApiIpamAsnRangesPartialUpdateRequest) Execute() (*ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesPartialUpdateExecute(r)
}

/*
IpamAsnRangesPartialUpdate Method for IpamAsnRangesPartialUpdate

Patch a ASN range object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this ASN range.
 @return ApiIpamAsnRangesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAsnRangesPartialUpdate(ctx context.Context, id int32) ApiIpamAsnRangesPartialUpdateRequest {
	return ApiIpamAsnRangesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ASNRange
func (a *IpamAPIService) IpamAsnRangesPartialUpdateExecute(r ApiIpamAsnRangesPartialUpdateRequest) (*ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedASNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamAsnRangesRetrieveRequest) Execute() (*ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesRetrieveExecute(r)
}

/*
IpamAsnRangesRetrieve Method for IpamAsnRangesRetrieve

Get a ASN range object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this ASN range.
 @return ApiIpamAsnRangesRetrieveRequest
*/
func (a *IpamAPIService) IpamAsnRangesRetrieve(ctx context.Context, id int32) ApiIpamAsnRangesRetrieveRequest {
	return ApiIpamAsnRangesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ASNRange
func (a *IpamAPIService) IpamAsnRangesRetrieveExecute(r ApiIpamAsnRangesRetrieveRequest) (*ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	aSNRangeRequest *ASNRangeRequest
}

func (r ApiIpamAsnRangesUpdateRequest) ASNRangeRequest(aSNRangeRequest ASNRangeRequest) ApiIpamAsnRangesUpdateRequest {
	r.aSNRangeRequest = &aSNRangeRequest
	return r
}

func (r ApiIpamAsnRangesUpdateRequest) Execute() (*ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesUpdateExecute(r)
}

/*
IpamAsnRangesUpdate Method for IpamAsnRangesUpdate

Put a ASN range object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this ASN range.
 @return ApiIpamAsnRangesUpdateRequest
*/
func (a *IpamAPIService) IpamAsnRangesUpdate(ctx context.Context, id int32) ApiIpamAsnRangesUpdateRequest {
	return ApiIpamAsnRangesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ASNRange
func (a *IpamAPIService) IpamAsnRangesUpdateExecute(r ApiIpamAsnRangesUpdateRequest) (*ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRangeRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	aSNRequest *[]ASNRequest
}

func (r ApiIpamAsnsBulkDestroyRequest) ASNRequest(aSNRequest []ASNRequest) ApiIpamAsnsBulkDestroyRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAsnsBulkDestroyExecute(r)
}

/*
IpamAsnsBulkDestroy Method for IpamAsnsBulkDestroy

Delete a list of ASN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAsnsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamAsnsBulkDestroy(ctx context.Context) ApiIpamAsnsBulkDestroyRequest {
	return ApiIpamAsnsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAsnsBulkDestroyExecute(r ApiIpamAsnsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAsnsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	aSNRequest *[]ASNRequest
}

func (r ApiIpamAsnsBulkPartialUpdateRequest) ASNRequest(aSNRequest []ASNRequest) ApiIpamAsnsBulkPartialUpdateRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnsBulkPartialUpdateRequest) Execute() ([]ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsBulkPartialUpdateExecute(r)
}

/*
IpamAsnsBulkPartialUpdate Method for IpamAsnsBulkPartialUpdate

Patch a list of ASN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAsnsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAsnsBulkPartialUpdate(ctx context.Context) ApiIpamAsnsBulkPartialUpdateRequest {
	return ApiIpamAsnsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ASN
func (a *IpamAPIService) IpamAsnsBulkPartialUpdateExecute(r ApiIpamAsnsBulkPartialUpdateRequest) ([]ASN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	aSNRequest *[]ASNRequest
}

func (r ApiIpamAsnsBulkUpdateRequest) ASNRequest(aSNRequest []ASNRequest) ApiIpamAsnsBulkUpdateRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnsBulkUpdateRequest) Execute() ([]ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsBulkUpdateExecute(r)
}

/*
IpamAsnsBulkUpdate Method for IpamAsnsBulkUpdate

Put a list of ASN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAsnsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamAsnsBulkUpdate(ctx context.Context) ApiIpamAsnsBulkUpdateRequest {
	return ApiIpamAsnsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ASN
func (a *IpamAPIService) IpamAsnsBulkUpdateExecute(r ApiIpamAsnsBulkUpdateRequest) ([]ASN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	aSNRequest *ASNRequest
}

func (r ApiIpamAsnsCreateRequest) ASNRequest(aSNRequest ASNRequest) ApiIpamAsnsCreateRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnsCreateRequest) Execute() (*ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsCreateExecute(r)
}

/*
IpamAsnsCreate Method for IpamAsnsCreate

Post a list of ASN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAsnsCreateRequest
*/
func (a *IpamAPIService) IpamAsnsCreate(ctx context.Context) ApiIpamAsnsCreateRequest {
	return ApiIpamAsnsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ASN
func (a *IpamAPIService) IpamAsnsCreateExecute(r ApiIpamAsnsCreateRequest) (*ASN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamAsnsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAsnsDestroyExecute(r)
}

/*
IpamAsnsDestroy Method for IpamAsnsDestroy

Delete a ASN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this ASN.
 @return ApiIpamAsnsDestroyRequest
*/
func (a *IpamAPIService) IpamAsnsDestroy(ctx context.Context, id int32) ApiIpamAsnsDestroyRequest {
	return ApiIpamAsnsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAsnsDestroyExecute(r ApiIpamAsnsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAsnsListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	asn *[]int32
	asnEmpty *bool
	asnGt *[]int32
	asnGte *[]int32
	asnLt *[]int32
	asnLte *[]int32
	asnN *[]int32
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	offset *int32
	ordering *string
	provider *[]string
	providerN *[]string
	providerId *[]int32
	providerIdN *[]int32
	q *string
	rir *[]string
	rirN *[]string
	rirId *[]int32
	rirIdN *[]int32
	site *[]string
	siteN *[]string
	siteId *[]int32
	siteIdN *[]int32
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*int32
	tenantIdN *[]*int32
	updatedByRequest *string
}

func (r ApiIpamAsnsListRequest) Asn(asn []int32) ApiIpamAsnsListRequest {
	r.asn = &asn
	return r
}

func (r ApiIpamAsnsListRequest) AsnEmpty(asnEmpty bool) ApiIpamAsnsListRequest {
	r.asnEmpty = &asnEmpty
	return r
}

func (r ApiIpamAsnsListRequest) AsnGt(asnGt []int32) ApiIpamAsnsListRequest {
	r.asnGt = &asnGt
	return r
}

func (r ApiIpamAsnsListRequest) AsnGte(asnGte []int32) ApiIpamAsnsListRequest {
	r.asnGte = &asnGte
	return r
}

func (r ApiIpamAsnsListRequest) AsnLt(asnLt []int32) ApiIpamAsnsListRequest {
	r.asnLt = &asnLt
	return r
}

func (r ApiIpamAsnsListRequest) AsnLte(asnLte []int32) ApiIpamAsnsListRequest {
	r.asnLte = &asnLte
	return r
}

func (r ApiIpamAsnsListRequest) AsnN(asnN []int32) ApiIpamAsnsListRequest {
	r.asnN = &asnN
	return r
}

func (r ApiIpamAsnsListRequest) Created(created []time.Time) ApiIpamAsnsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamAsnsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamAsnsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamAsnsListRequest) CreatedGt(createdGt []time.Time) ApiIpamAsnsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamAsnsListRequest) CreatedGte(createdGte []time.Time) ApiIpamAsnsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamAsnsListRequest) CreatedLt(createdLt []time.Time) ApiIpamAsnsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamAsnsListRequest) CreatedLte(createdLte []time.Time) ApiIpamAsnsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamAsnsListRequest) CreatedN(createdN []time.Time) ApiIpamAsnsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamAsnsListRequest) CreatedByRequest(createdByRequest string) ApiIpamAsnsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamAsnsListRequest) Description(description []string) ApiIpamAsnsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamAsnsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionIc(descriptionIc []string) ApiIpamAsnsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionIe(descriptionIe []string) ApiIpamAsnsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionIew(descriptionIew []string) ApiIpamAsnsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamAsnsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionN(descriptionN []string) ApiIpamAsnsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionNic(descriptionNic []string) ApiIpamAsnsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionNie(descriptionNie []string) ApiIpamAsnsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamAsnsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamAsnsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamAsnsListRequest) Id(id []int32) ApiIpamAsnsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamAsnsListRequest) IdEmpty(idEmpty bool) ApiIpamAsnsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamAsnsListRequest) IdGt(idGt []int32) ApiIpamAsnsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamAsnsListRequest) IdGte(idGte []int32) ApiIpamAsnsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamAsnsListRequest) IdLt(idLt []int32) ApiIpamAsnsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamAsnsListRequest) IdLte(idLte []int32) ApiIpamAsnsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamAsnsListRequest) IdN(idN []int32) ApiIpamAsnsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamAsnsListRequest) Limit(limit int32) ApiIpamAsnsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamAsnsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamAsnsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiIpamAsnsListRequest) Offset(offset int32) ApiIpamAsnsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamAsnsListRequest) Ordering(ordering string) ApiIpamAsnsListRequest {
	r.ordering = &ordering
	return r
}

// Provider (slug)
func (r ApiIpamAsnsListRequest) Provider(provider []string) ApiIpamAsnsListRequest {
	r.provider = &provider
	return r
}

// Provider (slug)
func (r ApiIpamAsnsListRequest) ProviderN(providerN []string) ApiIpamAsnsListRequest {
	r.providerN = &providerN
	return r
}

// Provider (ID)
func (r ApiIpamAsnsListRequest) ProviderId(providerId []int32) ApiIpamAsnsListRequest {
	r.providerId = &providerId
	return r
}

// Provider (ID)
func (r ApiIpamAsnsListRequest) ProviderIdN(providerIdN []int32) ApiIpamAsnsListRequest {
	r.providerIdN = &providerIdN
	return r
}

// Search
func (r ApiIpamAsnsListRequest) Q(q string) ApiIpamAsnsListRequest {
	r.q = &q
	return r
}

// RIR (slug)
func (r ApiIpamAsnsListRequest) Rir(rir []string) ApiIpamAsnsListRequest {
	r.rir = &rir
	return r
}

// RIR (slug)
func (r ApiIpamAsnsListRequest) RirN(rirN []string) ApiIpamAsnsListRequest {
	r.rirN = &rirN
	return r
}

// RIR (ID)
func (r ApiIpamAsnsListRequest) RirId(rirId []int32) ApiIpamAsnsListRequest {
	r.rirId = &rirId
	return r
}

// RIR (ID)
func (r ApiIpamAsnsListRequest) RirIdN(rirIdN []int32) ApiIpamAsnsListRequest {
	r.rirIdN = &rirIdN
	return r
}

// Site (slug)
func (r ApiIpamAsnsListRequest) Site(site []string) ApiIpamAsnsListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiIpamAsnsListRequest) SiteN(siteN []string) ApiIpamAsnsListRequest {
	r.siteN = &siteN
	return r
}

// Site (ID)
func (r ApiIpamAsnsListRequest) SiteId(siteId []int32) ApiIpamAsnsListRequest {
	r.siteId = &siteId
	return r
}

// Site (ID)
func (r ApiIpamAsnsListRequest) SiteIdN(siteIdN []int32) ApiIpamAsnsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiIpamAsnsListRequest) Tag(tag []string) ApiIpamAsnsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamAsnsListRequest) TagN(tagN []string) ApiIpamAsnsListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamAsnsListRequest) Tenant(tenant []string) ApiIpamAsnsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamAsnsListRequest) TenantN(tenantN []string) ApiIpamAsnsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamAsnsListRequest) TenantGroup(tenantGroup []string) ApiIpamAsnsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamAsnsListRequest) TenantGroupN(tenantGroupN []string) ApiIpamAsnsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamAsnsListRequest) TenantGroupId(tenantGroupId []string) ApiIpamAsnsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamAsnsListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamAsnsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamAsnsListRequest) TenantId(tenantId []*int32) ApiIpamAsnsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamAsnsListRequest) TenantIdN(tenantIdN []*int32) ApiIpamAsnsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamAsnsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamAsnsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamAsnsListRequest) Execute() (*PaginatedASNList, *http.Response, error) {
	return r.ApiService.IpamAsnsListExecute(r)
}

/*
IpamAsnsList Method for IpamAsnsList

Get a list of ASN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAsnsListRequest
*/
func (a *IpamAPIService) IpamAsnsList(ctx context.Context) ApiIpamAsnsListRequest {
	return ApiIpamAsnsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedASNList
func (a *IpamAPIService) IpamAsnsListExecute(r ApiIpamAsnsListRequest) (*PaginatedASNList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedASNList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asn != nil {
		t := *r.asn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn", t, "form", "multi")
		}
	}
	if r.asnEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asn__empty", r.asnEmpty, "form", "")
	}
	if r.asnGt != nil {
		t := *r.asnGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gt", t, "form", "multi")
		}
	}
	if r.asnGte != nil {
		t := *r.asnGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gte", t, "form", "multi")
		}
	}
	if r.asnLt != nil {
		t := *r.asnLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lt", t, "form", "multi")
		}
	}
	if r.asnLte != nil {
		t := *r.asnLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lte", t, "form", "multi")
		}
	}
	if r.asnN != nil {
		t := *r.asnN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__n", t, "form", "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.provider != nil {
		t := *r.provider
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "provider", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "provider", t, "form", "multi")
		}
	}
	if r.providerN != nil {
		t := *r.providerN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "provider__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "provider__n", t, "form", "multi")
		}
	}
	if r.providerId != nil {
		t := *r.providerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "provider_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "provider_id", t, "form", "multi")
		}
	}
	if r.providerIdN != nil {
		t := *r.providerIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "provider_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "provider_id__n", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.rir != nil {
		t := *r.rir
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir", t, "form", "multi")
		}
	}
	if r.rirN != nil {
		t := *r.rirN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", t, "form", "multi")
		}
	}
	if r.rirId != nil {
		t := *r.rirId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", t, "form", "multi")
		}
	}
	if r.rirIdN != nil {
		t := *r.rirIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", t, "form", "multi")
		}
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site", t, "form", "multi")
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", t, "form", "multi")
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", t, "form", "multi")
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "form", "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedASNRequest *PatchedASNRequest
}

func (r ApiIpamAsnsPartialUpdateRequest) PatchedASNRequest(patchedASNRequest PatchedASNRequest) ApiIpamAsnsPartialUpdateRequest {
	r.patchedASNRequest = &patchedASNRequest
	return r
}

func (r ApiIpamAsnsPartialUpdateRequest) Execute() (*ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsPartialUpdateExecute(r)
}

/*
IpamAsnsPartialUpdate Method for IpamAsnsPartialUpdate

Patch a ASN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this ASN.
 @return ApiIpamAsnsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAsnsPartialUpdate(ctx context.Context, id int32) ApiIpamAsnsPartialUpdateRequest {
	return ApiIpamAsnsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ASN
func (a *IpamAPIService) IpamAsnsPartialUpdateExecute(r ApiIpamAsnsPartialUpdateRequest) (*ASN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedASNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamAsnsRetrieveRequest) Execute() (*ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsRetrieveExecute(r)
}

/*
IpamAsnsRetrieve Method for IpamAsnsRetrieve

Get a ASN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this ASN.
 @return ApiIpamAsnsRetrieveRequest
*/
func (a *IpamAPIService) IpamAsnsRetrieve(ctx context.Context, id int32) ApiIpamAsnsRetrieveRequest {
	return ApiIpamAsnsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ASN
func (a *IpamAPIService) IpamAsnsRetrieveExecute(r ApiIpamAsnsRetrieveRequest) (*ASN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	aSNRequest *ASNRequest
}

func (r ApiIpamAsnsUpdateRequest) ASNRequest(aSNRequest ASNRequest) ApiIpamAsnsUpdateRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnsUpdateRequest) Execute() (*ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsUpdateExecute(r)
}

/*
IpamAsnsUpdate Method for IpamAsnsUpdate

Put a ASN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this ASN.
 @return ApiIpamAsnsUpdateRequest
*/
func (a *IpamAPIService) IpamAsnsUpdate(ctx context.Context, id int32) ApiIpamAsnsUpdateRequest {
	return ApiIpamAsnsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ASN
func (a *IpamAPIService) IpamAsnsUpdateExecute(r ApiIpamAsnsUpdateRequest) (*ASN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	fHRPGroupAssignmentRequest *[]FHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsBulkDestroyRequest) FHRPGroupAssignmentRequest(fHRPGroupAssignmentRequest []FHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsBulkDestroyRequest {
	r.fHRPGroupAssignmentRequest = &fHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsBulkDestroyExecute(r)
}

/*
IpamFhrpGroupAssignmentsBulkDestroy Method for IpamFhrpGroupAssignmentsBulkDestroy

Delete a list of FHRP group assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamFhrpGroupAssignmentsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkDestroy(ctx context.Context) ApiIpamFhrpGroupAssignmentsBulkDestroyRequest {
	return ApiIpamFhrpGroupAssignmentsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkDestroyExecute(r ApiIpamFhrpGroupAssignmentsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupAssignmentRequest == nil {
		return nil, reportError("fHRPGroupAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	fHRPGroupAssignmentRequest *[]FHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest) FHRPGroupAssignmentRequest(fHRPGroupAssignmentRequest []FHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest {
	r.fHRPGroupAssignmentRequest = &fHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest) Execute() ([]FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsBulkPartialUpdateExecute(r)
}

/*
IpamFhrpGroupAssignmentsBulkPartialUpdate Method for IpamFhrpGroupAssignmentsBulkPartialUpdate

Patch a list of FHRP group assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkPartialUpdate(ctx context.Context) ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest {
	return ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkPartialUpdateExecute(r ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest) ([]FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	fHRPGroupAssignmentRequest *[]FHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsBulkUpdateRequest) FHRPGroupAssignmentRequest(fHRPGroupAssignmentRequest []FHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsBulkUpdateRequest {
	r.fHRPGroupAssignmentRequest = &fHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsBulkUpdateRequest) Execute() ([]FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsBulkUpdateExecute(r)
}

/*
IpamFhrpGroupAssignmentsBulkUpdate Method for IpamFhrpGroupAssignmentsBulkUpdate

Put a list of FHRP group assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamFhrpGroupAssignmentsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkUpdate(ctx context.Context) ApiIpamFhrpGroupAssignmentsBulkUpdateRequest {
	return ApiIpamFhrpGroupAssignmentsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkUpdateExecute(r ApiIpamFhrpGroupAssignmentsBulkUpdateRequest) ([]FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	fHRPGroupAssignmentRequest *FHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsCreateRequest) FHRPGroupAssignmentRequest(fHRPGroupAssignmentRequest FHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsCreateRequest {
	r.fHRPGroupAssignmentRequest = &fHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsCreateRequest) Execute() (*FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsCreateExecute(r)
}

/*
IpamFhrpGroupAssignmentsCreate Method for IpamFhrpGroupAssignmentsCreate

Post a list of FHRP group assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamFhrpGroupAssignmentsCreateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsCreate(ctx context.Context) ApiIpamFhrpGroupAssignmentsCreateRequest {
	return ApiIpamFhrpGroupAssignmentsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsCreateExecute(r ApiIpamFhrpGroupAssignmentsCreateRequest) (*FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamFhrpGroupAssignmentsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsDestroyExecute(r)
}

/*
IpamFhrpGroupAssignmentsDestroy Method for IpamFhrpGroupAssignmentsDestroy

Delete a FHRP group assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this FHRP group assignment.
 @return ApiIpamFhrpGroupAssignmentsDestroyRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsDestroy(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsDestroyRequest {
	return ApiIpamFhrpGroupAssignmentsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamFhrpGroupAssignmentsDestroyExecute(r ApiIpamFhrpGroupAssignmentsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	device *[]string
	deviceId *[]int32
	groupId *[]int32
	groupIdN *[]int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	interfaceId *[]int32
	interfaceIdEmpty *bool
	interfaceIdGt *[]int32
	interfaceIdGte *[]int32
	interfaceIdLt *[]int32
	interfaceIdLte *[]int32
	interfaceIdN *[]int32
	interfaceType *string
	interfaceTypeN *string
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	offset *int32
	ordering *string
	priority *[]int32
	priorityEmpty *bool
	priorityGt *[]int32
	priorityGte *[]int32
	priorityLt *[]int32
	priorityLte *[]int32
	priorityN *[]int32
	updatedByRequest *string
	virtualMachine *[]string
	virtualMachineId *[]int32
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) Created(created []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedGt(createdGt []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedGte(createdGte []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedLt(createdLt []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedLte(createdLte []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedN(createdN []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedByRequest(createdByRequest string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) Device(device []string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.device = &device
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) DeviceId(deviceId []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.deviceId = &deviceId
	return r
}

// Group (ID)
func (r ApiIpamFhrpGroupAssignmentsListRequest) GroupId(groupId []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.groupId = &groupId
	return r
}

// Group (ID)
func (r ApiIpamFhrpGroupAssignmentsListRequest) GroupIdN(groupIdN []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) Id(id []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdEmpty(idEmpty bool) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdGt(idGt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdGte(idGte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdLt(idLt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdLte(idLte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdN(idN []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceId(interfaceId []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceId = &interfaceId
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdEmpty(interfaceIdEmpty bool) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdEmpty = &interfaceIdEmpty
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdGt(interfaceIdGt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdGt = &interfaceIdGt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdGte(interfaceIdGte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdGte = &interfaceIdGte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdLt(interfaceIdLt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdLt = &interfaceIdLt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdLte(interfaceIdLte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdLte = &interfaceIdLte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdN(interfaceIdN []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdN = &interfaceIdN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceType(interfaceType string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceType = &interfaceType
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceTypeN(interfaceTypeN string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceTypeN = &interfaceTypeN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamFhrpGroupAssignmentsListRequest) Limit(limit int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiIpamFhrpGroupAssignmentsListRequest) Offset(offset int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamFhrpGroupAssignmentsListRequest) Ordering(ordering string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) Priority(priority []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priority = &priority
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityEmpty(priorityEmpty bool) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityEmpty = &priorityEmpty
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityGt(priorityGt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityGt = &priorityGt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityGte(priorityGte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityGte = &priorityGte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityLt(priorityLt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityLt = &priorityLt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityLte(priorityLte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityLte = &priorityLte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityN(priorityN []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityN = &priorityN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) VirtualMachine(virtualMachine []string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) VirtualMachineId(virtualMachineId []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) Execute() (*PaginatedFHRPGroupAssignmentList, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsListExecute(r)
}

/*
IpamFhrpGroupAssignmentsList Method for IpamFhrpGroupAssignmentsList

Get a list of FHRP group assignment objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamFhrpGroupAssignmentsListRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsList(ctx context.Context) ApiIpamFhrpGroupAssignmentsListRequest {
	return ApiIpamFhrpGroupAssignmentsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedFHRPGroupAssignmentList
func (a *IpamAPIService) IpamFhrpGroupAssignmentsListExecute(r ApiIpamFhrpGroupAssignmentsListRequest) (*PaginatedFHRPGroupAssignmentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedFHRPGroupAssignmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "form", "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "form", "multi")
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", t, "form", "multi")
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.interfaceId != nil {
		t := *r.interfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", t, "form", "multi")
		}
	}
	if r.interfaceIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__empty", r.interfaceIdEmpty, "form", "")
	}
	if r.interfaceIdGt != nil {
		t := *r.interfaceIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__gt", t, "form", "multi")
		}
	}
	if r.interfaceIdGte != nil {
		t := *r.interfaceIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__gte", t, "form", "multi")
		}
	}
	if r.interfaceIdLt != nil {
		t := *r.interfaceIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__lt", t, "form", "multi")
		}
	}
	if r.interfaceIdLte != nil {
		t := *r.interfaceIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__lte", t, "form", "multi")
		}
	}
	if r.interfaceIdN != nil {
		t := *r.interfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", t, "form", "multi")
		}
	}
	if r.interfaceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface_type", r.interfaceType, "form", "")
	}
	if r.interfaceTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface_type__n", r.interfaceTypeN, "form", "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.priority != nil {
		t := *r.priority
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority", t, "form", "multi")
		}
	}
	if r.priorityEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority__empty", r.priorityEmpty, "form", "")
	}
	if r.priorityGt != nil {
		t := *r.priorityGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gt", t, "form", "multi")
		}
	}
	if r.priorityGte != nil {
		t := *r.priorityGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gte", t, "form", "multi")
		}
	}
	if r.priorityLt != nil {
		t := *r.priorityLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lt", t, "form", "multi")
		}
	}
	if r.priorityLte != nil {
		t := *r.priorityLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lte", t, "form", "multi")
		}
	}
	if r.priorityN != nil {
		t := *r.priorityN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", t, "form", "multi")
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedFHRPGroupAssignmentRequest *PatchedFHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsPartialUpdateRequest) PatchedFHRPGroupAssignmentRequest(patchedFHRPGroupAssignmentRequest PatchedFHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsPartialUpdateRequest {
	r.patchedFHRPGroupAssignmentRequest = &patchedFHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsPartialUpdateRequest) Execute() (*FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsPartialUpdateExecute(r)
}

/*
IpamFhrpGroupAssignmentsPartialUpdate Method for IpamFhrpGroupAssignmentsPartialUpdate

Patch a FHRP group assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this FHRP group assignment.
 @return ApiIpamFhrpGroupAssignmentsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsPartialUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsPartialUpdateRequest {
	return ApiIpamFhrpGroupAssignmentsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsPartialUpdateExecute(r ApiIpamFhrpGroupAssignmentsPartialUpdateRequest) (*FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedFHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamFhrpGroupAssignmentsRetrieveRequest) Execute() (*FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsRetrieveExecute(r)
}

/*
IpamFhrpGroupAssignmentsRetrieve Method for IpamFhrpGroupAssignmentsRetrieve

Get a FHRP group assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this FHRP group assignment.
 @return ApiIpamFhrpGroupAssignmentsRetrieveRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsRetrieve(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsRetrieveRequest {
	return ApiIpamFhrpGroupAssignmentsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsRetrieveExecute(r ApiIpamFhrpGroupAssignmentsRetrieveRequest) (*FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	fHRPGroupAssignmentRequest *FHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsUpdateRequest) FHRPGroupAssignmentRequest(fHRPGroupAssignmentRequest FHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsUpdateRequest {
	r.fHRPGroupAssignmentRequest = &fHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsUpdateRequest) Execute() (*FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsUpdateExecute(r)
}

/*
IpamFhrpGroupAssignmentsUpdate Method for IpamFhrpGroupAssignmentsUpdate

Put a FHRP group assignment object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this FHRP group assignment.
 @return ApiIpamFhrpGroupAssignmentsUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsUpdateRequest {
	return ApiIpamFhrpGroupAssignmentsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsUpdateExecute(r ApiIpamFhrpGroupAssignmentsUpdateRequest) (*FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	fHRPGroupRequest *[]FHRPGroupRequest
}

func (r ApiIpamFhrpGroupsBulkDestroyRequest) FHRPGroupRequest(fHRPGroupRequest []FHRPGroupRequest) ApiIpamFhrpGroupsBulkDestroyRequest {
	r.fHRPGroupRequest = &fHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamFhrpGroupsBulkDestroyExecute(r)
}

/*
IpamFhrpGroupsBulkDestroy Method for IpamFhrpGroupsBulkDestroy

Delete a list of FHRP group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamFhrpGroupsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsBulkDestroy(ctx context.Context) ApiIpamFhrpGroupsBulkDestroyRequest {
	return ApiIpamFhrpGroupsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamFhrpGroupsBulkDestroyExecute(r ApiIpamFhrpGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupRequest == nil {
		return nil, reportError("fHRPGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	fHRPGroupRequest *[]FHRPGroupRequest
}

func (r ApiIpamFhrpGroupsBulkPartialUpdateRequest) FHRPGroupRequest(fHRPGroupRequest []FHRPGroupRequest) ApiIpamFhrpGroupsBulkPartialUpdateRequest {
	r.fHRPGroupRequest = &fHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsBulkPartialUpdateRequest) Execute() ([]FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsBulkPartialUpdateExecute(r)
}

/*
IpamFhrpGroupsBulkPartialUpdate Method for IpamFhrpGroupsBulkPartialUpdate

Patch a list of FHRP group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamFhrpGroupsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsBulkPartialUpdate(ctx context.Context) ApiIpamFhrpGroupsBulkPartialUpdateRequest {
	return ApiIpamFhrpGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsBulkPartialUpdateExecute(r ApiIpamFhrpGroupsBulkPartialUpdateRequest) ([]FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	fHRPGroupRequest *[]FHRPGroupRequest
}

func (r ApiIpamFhrpGroupsBulkUpdateRequest) FHRPGroupRequest(fHRPGroupRequest []FHRPGroupRequest) ApiIpamFhrpGroupsBulkUpdateRequest {
	r.fHRPGroupRequest = &fHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsBulkUpdateRequest) Execute() ([]FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsBulkUpdateExecute(r)
}

/*
IpamFhrpGroupsBulkUpdate Method for IpamFhrpGroupsBulkUpdate

Put a list of FHRP group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamFhrpGroupsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsBulkUpdate(ctx context.Context) ApiIpamFhrpGroupsBulkUpdateRequest {
	return ApiIpamFhrpGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsBulkUpdateExecute(r ApiIpamFhrpGroupsBulkUpdateRequest) ([]FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	fHRPGroupRequest *FHRPGroupRequest
}

func (r ApiIpamFhrpGroupsCreateRequest) FHRPGroupRequest(fHRPGroupRequest FHRPGroupRequest) ApiIpamFhrpGroupsCreateRequest {
	r.fHRPGroupRequest = &fHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsCreateRequest) Execute() (*FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsCreateExecute(r)
}

/*
IpamFhrpGroupsCreate Method for IpamFhrpGroupsCreate

Post a list of FHRP group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamFhrpGroupsCreateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsCreate(ctx context.Context) ApiIpamFhrpGroupsCreateRequest {
	return ApiIpamFhrpGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsCreateExecute(r ApiIpamFhrpGroupsCreateRequest) (*FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamFhrpGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamFhrpGroupsDestroyExecute(r)
}

/*
IpamFhrpGroupsDestroy Method for IpamFhrpGroupsDestroy

Delete a FHRP group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this FHRP group.
 @return ApiIpamFhrpGroupsDestroyRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsDestroy(ctx context.Context, id int32) ApiIpamFhrpGroupsDestroyRequest {
	return ApiIpamFhrpGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamFhrpGroupsDestroyExecute(r ApiIpamFhrpGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	authKey *[]string
	authKeyEmpty *bool
	authKeyIc *[]string
	authKeyIe *[]string
	authKeyIew *[]string
	authKeyIsw *[]string
	authKeyN *[]string
	authKeyNic *[]string
	authKeyNie *[]string
	authKeyNiew *[]string
	authKeyNisw *[]string
	authType *[]*string
	authTypeEmpty *bool
	authTypeIc *[]*string
	authTypeIe *[]*string
	authTypeIew *[]*string
	authTypeIsw *[]*string
	authTypeN *[]*string
	authTypeNic *[]*string
	authTypeNie *[]*string
	authTypeNiew *[]*string
	authTypeNisw *[]*string
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	groupId *[]int32
	groupIdEmpty *bool
	groupIdGt *[]int32
	groupIdGte *[]int32
	groupIdLt *[]int32
	groupIdLte *[]int32
	groupIdN *[]int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	protocol *[]string
	protocolEmpty *bool
	protocolIc *[]string
	protocolIe *[]string
	protocolIew *[]string
	protocolIsw *[]string
	protocolN *[]string
	protocolNic *[]string
	protocolNie *[]string
	protocolNiew *[]string
	protocolNisw *[]string
	q *string
	relatedIp *[]string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiIpamFhrpGroupsListRequest) AuthKey(authKey []string) ApiIpamFhrpGroupsListRequest {
	r.authKey = &authKey
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyEmpty(authKeyEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.authKeyEmpty = &authKeyEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyIc(authKeyIc []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyIc = &authKeyIc
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyIe(authKeyIe []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyIe = &authKeyIe
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyIew(authKeyIew []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyIew = &authKeyIew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyIsw(authKeyIsw []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyIsw = &authKeyIsw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyN(authKeyN []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyN = &authKeyN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyNic(authKeyNic []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyNic = &authKeyNic
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyNie(authKeyNie []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyNie = &authKeyNie
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyNiew(authKeyNiew []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyNiew = &authKeyNiew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyNisw(authKeyNisw []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyNisw = &authKeyNisw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthType(authType []*string) ApiIpamFhrpGroupsListRequest {
	r.authType = &authType
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthTypeEmpty(authTypeEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.authTypeEmpty = &authTypeEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthTypeIc(authTypeIc []*string) ApiIpamFhrpGroupsListRequest {
	r.authTypeIc = &authTypeIc
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthTypeIe(authTypeIe []*string) ApiIpamFhrpGroupsListRequest {
	r.authTypeIe = &authTypeIe
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthTypeIew(authTypeIew []*string) ApiIpamFhrpGroupsListRequest {
	r.authTypeIew = &authTypeIew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthTypeIsw(authTypeIsw []*string) ApiIpamFhrpGroupsListRequest {
	r.authTypeIsw = &authTypeIsw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthTypeN(authTypeN []*string) ApiIpamFhrpGroupsListRequest {
	r.authTypeN = &authTypeN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthTypeNic(authTypeNic []*string) ApiIpamFhrpGroupsListRequest {
	r.authTypeNic = &authTypeNic
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthTypeNie(authTypeNie []*string) ApiIpamFhrpGroupsListRequest {
	r.authTypeNie = &authTypeNie
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthTypeNiew(authTypeNiew []*string) ApiIpamFhrpGroupsListRequest {
	r.authTypeNiew = &authTypeNiew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthTypeNisw(authTypeNisw []*string) ApiIpamFhrpGroupsListRequest {
	r.authTypeNisw = &authTypeNisw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Created(created []time.Time) ApiIpamFhrpGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedGt(createdGt []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedGte(createdGte []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedLt(createdLt []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedLte(createdLte []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedN(createdN []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedByRequest(createdByRequest string) ApiIpamFhrpGroupsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Description(description []string) ApiIpamFhrpGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionIc(descriptionIc []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionIe(descriptionIe []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionIew(descriptionIew []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionN(descriptionN []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionNic(descriptionNic []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionNie(descriptionNie []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupId(groupId []int32) ApiIpamFhrpGroupsListRequest {
	r.groupId = &groupId
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdEmpty(groupIdEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.groupIdEmpty = &groupIdEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdGt(groupIdGt []int32) ApiIpamFhrpGroupsListRequest {
	r.groupIdGt = &groupIdGt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdGte(groupIdGte []int32) ApiIpamFhrpGroupsListRequest {
	r.groupIdGte = &groupIdGte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdLt(groupIdLt []int32) ApiIpamFhrpGroupsListRequest {
	r.groupIdLt = &groupIdLt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdLte(groupIdLte []int32) ApiIpamFhrpGroupsListRequest {
	r.groupIdLte = &groupIdLte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdN(groupIdN []int32) ApiIpamFhrpGroupsListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Id(id []int32) ApiIpamFhrpGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdEmpty(idEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdGt(idGt []int32) ApiIpamFhrpGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdGte(idGte []int32) ApiIpamFhrpGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdLt(idLt []int32) ApiIpamFhrpGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdLte(idLte []int32) ApiIpamFhrpGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdN(idN []int32) ApiIpamFhrpGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamFhrpGroupsListRequest) Limit(limit int32) ApiIpamFhrpGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamFhrpGroupsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Name(name []string) ApiIpamFhrpGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameEmpty(nameEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameIc(nameIc []string) ApiIpamFhrpGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameIe(nameIe []string) ApiIpamFhrpGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameIew(nameIew []string) ApiIpamFhrpGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameIsw(nameIsw []string) ApiIpamFhrpGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameN(nameN []string) ApiIpamFhrpGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameNic(nameNic []string) ApiIpamFhrpGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameNie(nameNie []string) ApiIpamFhrpGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameNiew(nameNiew []string) ApiIpamFhrpGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameNisw(nameNisw []string) ApiIpamFhrpGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamFhrpGroupsListRequest) Offset(offset int32) ApiIpamFhrpGroupsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamFhrpGroupsListRequest) Ordering(ordering string) ApiIpamFhrpGroupsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Protocol(protocol []string) ApiIpamFhrpGroupsListRequest {
	r.protocol = &protocol
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ProtocolEmpty(protocolEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.protocolEmpty = &protocolEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ProtocolIc(protocolIc []string) ApiIpamFhrpGroupsListRequest {
	r.protocolIc = &protocolIc
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ProtocolIe(protocolIe []string) ApiIpamFhrpGroupsListRequest {
	r.protocolIe = &protocolIe
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ProtocolIew(protocolIew []string) ApiIpamFhrpGroupsListRequest {
	r.protocolIew = &protocolIew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ProtocolIsw(protocolIsw []string) ApiIpamFhrpGroupsListRequest {
	r.protocolIsw = &protocolIsw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ProtocolN(protocolN []string) ApiIpamFhrpGroupsListRequest {
	r.protocolN = &protocolN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ProtocolNic(protocolNic []string) ApiIpamFhrpGroupsListRequest {
	r.protocolNic = &protocolNic
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ProtocolNie(protocolNie []string) ApiIpamFhrpGroupsListRequest {
	r.protocolNie = &protocolNie
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ProtocolNiew(protocolNiew []string) ApiIpamFhrpGroupsListRequest {
	r.protocolNiew = &protocolNiew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ProtocolNisw(protocolNisw []string) ApiIpamFhrpGroupsListRequest {
	r.protocolNisw = &protocolNisw
	return r
}

// Search
func (r ApiIpamFhrpGroupsListRequest) Q(q string) ApiIpamFhrpGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamFhrpGroupsListRequest) RelatedIp(relatedIp []string) ApiIpamFhrpGroupsListRequest {
	r.relatedIp = &relatedIp
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Tag(tag []string) ApiIpamFhrpGroupsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamFhrpGroupsListRequest) TagN(tagN []string) ApiIpamFhrpGroupsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamFhrpGroupsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Execute() (*PaginatedFHRPGroupList, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsListExecute(r)
}

/*
IpamFhrpGroupsList Method for IpamFhrpGroupsList

Get a list of FHRP group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamFhrpGroupsListRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsList(ctx context.Context) ApiIpamFhrpGroupsListRequest {
	return ApiIpamFhrpGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedFHRPGroupList
func (a *IpamAPIService) IpamFhrpGroupsListExecute(r ApiIpamFhrpGroupsListRequest) (*PaginatedFHRPGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedFHRPGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.authKey != nil {
		t := *r.authKey
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key", t, "form", "multi")
		}
	}
	if r.authKeyEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__empty", r.authKeyEmpty, "form", "")
	}
	if r.authKeyIc != nil {
		t := *r.authKeyIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__ic", t, "form", "multi")
		}
	}
	if r.authKeyIe != nil {
		t := *r.authKeyIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__ie", t, "form", "multi")
		}
	}
	if r.authKeyIew != nil {
		t := *r.authKeyIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__iew", t, "form", "multi")
		}
	}
	if r.authKeyIsw != nil {
		t := *r.authKeyIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__isw", t, "form", "multi")
		}
	}
	if r.authKeyN != nil {
		t := *r.authKeyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__n", t, "form", "multi")
		}
	}
	if r.authKeyNic != nil {
		t := *r.authKeyNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nic", t, "form", "multi")
		}
	}
	if r.authKeyNie != nil {
		t := *r.authKeyNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nie", t, "form", "multi")
		}
	}
	if r.authKeyNiew != nil {
		t := *r.authKeyNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__niew", t, "form", "multi")
		}
	}
	if r.authKeyNisw != nil {
		t := *r.authKeyNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nisw", t, "form", "multi")
		}
	}
	if r.authType != nil {
		t := *r.authType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type", t, "form", "multi")
		}
	}
	if r.authTypeEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__empty", r.authTypeEmpty, "form", "")
	}
	if r.authTypeIc != nil {
		t := *r.authTypeIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__ic", t, "form", "multi")
		}
	}
	if r.authTypeIe != nil {
		t := *r.authTypeIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__ie", t, "form", "multi")
		}
	}
	if r.authTypeIew != nil {
		t := *r.authTypeIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__iew", t, "form", "multi")
		}
	}
	if r.authTypeIsw != nil {
		t := *r.authTypeIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__isw", t, "form", "multi")
		}
	}
	if r.authTypeN != nil {
		t := *r.authTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__n", t, "form", "multi")
		}
	}
	if r.authTypeNic != nil {
		t := *r.authTypeNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__nic", t, "form", "multi")
		}
	}
	if r.authTypeNie != nil {
		t := *r.authTypeNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__nie", t, "form", "multi")
		}
	}
	if r.authTypeNiew != nil {
		t := *r.authTypeNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__niew", t, "form", "multi")
		}
	}
	if r.authTypeNisw != nil {
		t := *r.authTypeNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__nisw", t, "form", "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", t, "form", "multi")
		}
	}
	if r.groupIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__empty", r.groupIdEmpty, "form", "")
	}
	if r.groupIdGt != nil {
		t := *r.groupIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__gt", t, "form", "multi")
		}
	}
	if r.groupIdGte != nil {
		t := *r.groupIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__gte", t, "form", "multi")
		}
	}
	if r.groupIdLt != nil {
		t := *r.groupIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__lt", t, "form", "multi")
		}
	}
	if r.groupIdLte != nil {
		t := *r.groupIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__lte", t, "form", "multi")
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.protocol != nil {
		t := *r.protocol
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", t, "form", "multi")
		}
	}
	if r.protocolEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__empty", r.protocolEmpty, "form", "")
	}
	if r.protocolIc != nil {
		t := *r.protocolIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ic", t, "form", "multi")
		}
	}
	if r.protocolIe != nil {
		t := *r.protocolIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__ie", t, "form", "multi")
		}
	}
	if r.protocolIew != nil {
		t := *r.protocolIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__iew", t, "form", "multi")
		}
	}
	if r.protocolIsw != nil {
		t := *r.protocolIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__isw", t, "form", "multi")
		}
	}
	if r.protocolN != nil {
		t := *r.protocolN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__n", t, "form", "multi")
		}
	}
	if r.protocolNic != nil {
		t := *r.protocolNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nic", t, "form", "multi")
		}
	}
	if r.protocolNie != nil {
		t := *r.protocolNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nie", t, "form", "multi")
		}
	}
	if r.protocolNiew != nil {
		t := *r.protocolNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__niew", t, "form", "multi")
		}
	}
	if r.protocolNisw != nil {
		t := *r.protocolNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__nisw", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.relatedIp != nil {
		t := *r.relatedIp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "related_ip", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "related_ip", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedFHRPGroupRequest *PatchedFHRPGroupRequest
}

func (r ApiIpamFhrpGroupsPartialUpdateRequest) PatchedFHRPGroupRequest(patchedFHRPGroupRequest PatchedFHRPGroupRequest) ApiIpamFhrpGroupsPartialUpdateRequest {
	r.patchedFHRPGroupRequest = &patchedFHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsPartialUpdateRequest) Execute() (*FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsPartialUpdateExecute(r)
}

/*
IpamFhrpGroupsPartialUpdate Method for IpamFhrpGroupsPartialUpdate

Patch a FHRP group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this FHRP group.
 @return ApiIpamFhrpGroupsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsPartialUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupsPartialUpdateRequest {
	return ApiIpamFhrpGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsPartialUpdateExecute(r ApiIpamFhrpGroupsPartialUpdateRequest) (*FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedFHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamFhrpGroupsRetrieveRequest) Execute() (*FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsRetrieveExecute(r)
}

/*
IpamFhrpGroupsRetrieve Method for IpamFhrpGroupsRetrieve

Get a FHRP group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this FHRP group.
 @return ApiIpamFhrpGroupsRetrieveRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsRetrieve(ctx context.Context, id int32) ApiIpamFhrpGroupsRetrieveRequest {
	return ApiIpamFhrpGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsRetrieveExecute(r ApiIpamFhrpGroupsRetrieveRequest) (*FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	fHRPGroupRequest *FHRPGroupRequest
}

func (r ApiIpamFhrpGroupsUpdateRequest) FHRPGroupRequest(fHRPGroupRequest FHRPGroupRequest) ApiIpamFhrpGroupsUpdateRequest {
	r.fHRPGroupRequest = &fHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsUpdateRequest) Execute() (*FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsUpdateExecute(r)
}

/*
IpamFhrpGroupsUpdate Method for IpamFhrpGroupsUpdate

Put a FHRP group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this FHRP group.
 @return ApiIpamFhrpGroupsUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupsUpdateRequest {
	return ApiIpamFhrpGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsUpdateExecute(r ApiIpamFhrpGroupsUpdateRequest) (*FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	iPAddressRequest *[]IPAddressRequest
}

func (r ApiIpamIpAddressesBulkDestroyRequest) IPAddressRequest(iPAddressRequest []IPAddressRequest) ApiIpamIpAddressesBulkDestroyRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamIpAddressesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkDestroyExecute(r)
}

/*
IpamIpAddressesBulkDestroy Method for IpamIpAddressesBulkDestroy

Delete a list of IP address objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamIpAddressesBulkDestroy(ctx context.Context) ApiIpamIpAddressesBulkDestroyRequest {
	return ApiIpamIpAddressesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpAddressesBulkDestroyExecute(r ApiIpamIpAddressesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return nil, reportError("iPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	iPAddressRequest *[]IPAddressRequest
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IPAddressRequest(iPAddressRequest []IPAddressRequest) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Execute() ([]IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkPartialUpdateExecute(r)
}

/*
IpamIpAddressesBulkPartialUpdate Method for IpamIpAddressesBulkPartialUpdate

Patch a list of IP address objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesBulkPartialUpdate(ctx context.Context) ApiIpamIpAddressesBulkPartialUpdateRequest {
	return ApiIpamIpAddressesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPAddress
func (a *IpamAPIService) IpamIpAddressesBulkPartialUpdateExecute(r ApiIpamIpAddressesBulkPartialUpdateRequest) ([]IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	iPAddressRequest *[]IPAddressRequest
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IPAddressRequest(iPAddressRequest []IPAddressRequest) ApiIpamIpAddressesBulkUpdateRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) Execute() ([]IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkUpdateExecute(r)
}

/*
IpamIpAddressesBulkUpdate Method for IpamIpAddressesBulkUpdate

Put a list of IP address objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesBulkUpdate(ctx context.Context) ApiIpamIpAddressesBulkUpdateRequest {
	return ApiIpamIpAddressesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPAddress
func (a *IpamAPIService) IpamIpAddressesBulkUpdateExecute(r ApiIpamIpAddressesBulkUpdateRequest) ([]IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	writableIPAddressRequest *WritableIPAddressRequest
}

func (r ApiIpamIpAddressesCreateRequest) WritableIPAddressRequest(writableIPAddressRequest WritableIPAddressRequest) ApiIpamIpAddressesCreateRequest {
	r.writableIPAddressRequest = &writableIPAddressRequest
	return r
}

func (r ApiIpamIpAddressesCreateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesCreateExecute(r)
}

/*
IpamIpAddressesCreate Method for IpamIpAddressesCreate

Post a list of IP address objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesCreateRequest
*/
func (a *IpamAPIService) IpamIpAddressesCreate(ctx context.Context) ApiIpamIpAddressesCreateRequest {
	return ApiIpamIpAddressesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamAPIService) IpamIpAddressesCreateExecute(r ApiIpamIpAddressesCreateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamIpAddressesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressesDestroyExecute(r)
}

/*
IpamIpAddressesDestroy Method for IpamIpAddressesDestroy

Delete a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP address.
 @return ApiIpamIpAddressesDestroyRequest
*/
func (a *IpamAPIService) IpamIpAddressesDestroy(ctx context.Context, id int32) ApiIpamIpAddressesDestroyRequest {
	return ApiIpamIpAddressesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpAddressesDestroyExecute(r ApiIpamIpAddressesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressesListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	address *[]string
	assigned *bool
	assignedObjectId *[]int32
	assignedObjectIdEmpty *bool
	assignedObjectIdGt *[]int32
	assignedObjectIdGte *[]int32
	assignedObjectIdLt *[]int32
	assignedObjectIdLte *[]int32
	assignedObjectIdN *[]int32
	assignedObjectType *int32
	assignedObjectTypeN *int32
	assignedToInterface *bool
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	device *[]string
	deviceId *[]int32
	dnsName *[]string
	dnsNameEmpty *bool
	dnsNameIc *[]string
	dnsNameIe *[]string
	dnsNameIew *[]string
	dnsNameIsw *[]string
	dnsNameN *[]string
	dnsNameNic *[]string
	dnsNameNie *[]string
	dnsNameNiew *[]string
	dnsNameNisw *[]string
	family *float32
	fhrpgroupId *[]int32
	fhrpgroupIdN *[]int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	interface_ *[]string
	interfaceN *[]string
	interfaceId *[]int32
	interfaceIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	maskLength *[]int32
	maskLengthGte *float32
	maskLengthLte *float32
	modifiedByRequest *string
	natInsideId *[]int32
	natInsideIdN *[]int32
	offset *int32
	ordering *string
	parent *[]string
	presentInVrf *string
	presentInVrfId *string
	q *string
	role *[]*string
	roleEmpty *bool
	roleIc *[]*string
	roleIe *[]*string
	roleIew *[]*string
	roleIsw *[]*string
	roleN *[]*string
	roleNic *[]*string
	roleNie *[]*string
	roleNiew *[]*string
	roleNisw *[]*string
	serviceId *[]int32
	serviceIdN *[]int32
	status *[]string
	statusEmpty *bool
	statusIc *[]string
	statusIe *[]string
	statusIew *[]string
	statusIsw *[]string
	statusN *[]string
	statusNic *[]string
	statusNie *[]string
	statusNiew *[]string
	statusNisw *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*int32
	tenantIdN *[]*int32
	updatedByRequest *string
	virtualMachine *[]string
	virtualMachineId *[]int32
	vminterface *[]string
	vminterfaceN *[]string
	vminterfaceId *[]int32
	vminterfaceIdN *[]int32
	vrf *[]*string
	vrfN *[]*string
	vrfId *[]*int32
	vrfIdN *[]*int32
}

func (r ApiIpamIpAddressesListRequest) Address(address []string) ApiIpamIpAddressesListRequest {
	r.address = &address
	return r
}

// Is assigned
func (r ApiIpamIpAddressesListRequest) Assigned(assigned bool) ApiIpamIpAddressesListRequest {
	r.assigned = &assigned
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectId(assignedObjectId []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectId = &assignedObjectId
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdEmpty(assignedObjectIdEmpty bool) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdEmpty = &assignedObjectIdEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdGt(assignedObjectIdGt []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdGt = &assignedObjectIdGt
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdGte(assignedObjectIdGte []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdGte = &assignedObjectIdGte
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdLt(assignedObjectIdLt []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdLt = &assignedObjectIdLt
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdLte(assignedObjectIdLte []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdLte = &assignedObjectIdLte
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdN(assignedObjectIdN []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdN = &assignedObjectIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectType(assignedObjectType int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectType = &assignedObjectType
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectTypeN(assignedObjectTypeN int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectTypeN = &assignedObjectTypeN
	return r
}

// Is assigned to an interface
func (r ApiIpamIpAddressesListRequest) AssignedToInterface(assignedToInterface bool) ApiIpamIpAddressesListRequest {
	r.assignedToInterface = &assignedToInterface
	return r
}

func (r ApiIpamIpAddressesListRequest) Created(created []time.Time) ApiIpamIpAddressesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamIpAddressesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedGt(createdGt []time.Time) ApiIpamIpAddressesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedGte(createdGte []time.Time) ApiIpamIpAddressesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedLt(createdLt []time.Time) ApiIpamIpAddressesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedLte(createdLte []time.Time) ApiIpamIpAddressesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedN(createdN []time.Time) ApiIpamIpAddressesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedByRequest(createdByRequest string) ApiIpamIpAddressesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamIpAddressesListRequest) Description(description []string) ApiIpamIpAddressesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamIpAddressesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIc(descriptionIc []string) ApiIpamIpAddressesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIe(descriptionIe []string) ApiIpamIpAddressesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIew(descriptionIew []string) ApiIpamIpAddressesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamIpAddressesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionN(descriptionN []string) ApiIpamIpAddressesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNic(descriptionNic []string) ApiIpamIpAddressesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNie(descriptionNie []string) ApiIpamIpAddressesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamIpAddressesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamIpAddressesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) Device(device []string) ApiIpamIpAddressesListRequest {
	r.device = &device
	return r
}

func (r ApiIpamIpAddressesListRequest) DeviceId(deviceId []int32) ApiIpamIpAddressesListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsName(dnsName []string) ApiIpamIpAddressesListRequest {
	r.dnsName = &dnsName
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameEmpty(dnsNameEmpty bool) ApiIpamIpAddressesListRequest {
	r.dnsNameEmpty = &dnsNameEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIc(dnsNameIc []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIc = &dnsNameIc
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIe(dnsNameIe []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIe = &dnsNameIe
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIew(dnsNameIew []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIew = &dnsNameIew
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIsw(dnsNameIsw []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIsw = &dnsNameIsw
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameN(dnsNameN []string) ApiIpamIpAddressesListRequest {
	r.dnsNameN = &dnsNameN
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNic(dnsNameNic []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNic = &dnsNameNic
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNie(dnsNameNie []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNie = &dnsNameNie
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNiew(dnsNameNiew []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNiew = &dnsNameNiew
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNisw(dnsNameNisw []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNisw = &dnsNameNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) Family(family float32) ApiIpamIpAddressesListRequest {
	r.family = &family
	return r
}

// FHRP group (ID)
func (r ApiIpamIpAddressesListRequest) FhrpgroupId(fhrpgroupId []int32) ApiIpamIpAddressesListRequest {
	r.fhrpgroupId = &fhrpgroupId
	return r
}

// FHRP group (ID)
func (r ApiIpamIpAddressesListRequest) FhrpgroupIdN(fhrpgroupIdN []int32) ApiIpamIpAddressesListRequest {
	r.fhrpgroupIdN = &fhrpgroupIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) Id(id []int32) ApiIpamIpAddressesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamIpAddressesListRequest) IdEmpty(idEmpty bool) ApiIpamIpAddressesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) IdGt(idGt []int32) ApiIpamIpAddressesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamIpAddressesListRequest) IdGte(idGte []int32) ApiIpamIpAddressesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamIpAddressesListRequest) IdLt(idLt []int32) ApiIpamIpAddressesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamIpAddressesListRequest) IdLte(idLte []int32) ApiIpamIpAddressesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamIpAddressesListRequest) IdN(idN []int32) ApiIpamIpAddressesListRequest {
	r.idN = &idN
	return r
}

// Interface (name)
func (r ApiIpamIpAddressesListRequest) Interface_(interface_ []string) ApiIpamIpAddressesListRequest {
	r.interface_ = &interface_
	return r
}

// Interface (name)
func (r ApiIpamIpAddressesListRequest) InterfaceN(interfaceN []string) ApiIpamIpAddressesListRequest {
	r.interfaceN = &interfaceN
	return r
}

// Interface (ID)
func (r ApiIpamIpAddressesListRequest) InterfaceId(interfaceId []int32) ApiIpamIpAddressesListRequest {
	r.interfaceId = &interfaceId
	return r
}

// Interface (ID)
func (r ApiIpamIpAddressesListRequest) InterfaceIdN(interfaceIdN []int32) ApiIpamIpAddressesListRequest {
	r.interfaceIdN = &interfaceIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamIpAddressesListRequest) Limit(limit int32) ApiIpamIpAddressesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLength(maskLength []int32) ApiIpamIpAddressesListRequest {
	r.maskLength = &maskLength
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLengthGte(maskLengthGte float32) ApiIpamIpAddressesListRequest {
	r.maskLengthGte = &maskLengthGte
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLengthLte(maskLengthLte float32) ApiIpamIpAddressesListRequest {
	r.maskLengthLte = &maskLengthLte
	return r
}

func (r ApiIpamIpAddressesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamIpAddressesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// NAT inside IP address (ID)
func (r ApiIpamIpAddressesListRequest) NatInsideId(natInsideId []int32) ApiIpamIpAddressesListRequest {
	r.natInsideId = &natInsideId
	return r
}

// NAT inside IP address (ID)
func (r ApiIpamIpAddressesListRequest) NatInsideIdN(natInsideIdN []int32) ApiIpamIpAddressesListRequest {
	r.natInsideIdN = &natInsideIdN
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpAddressesListRequest) Offset(offset int32) ApiIpamIpAddressesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamIpAddressesListRequest) Ordering(ordering string) ApiIpamIpAddressesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamIpAddressesListRequest) Parent(parent []string) ApiIpamIpAddressesListRequest {
	r.parent = &parent
	return r
}

func (r ApiIpamIpAddressesListRequest) PresentInVrf(presentInVrf string) ApiIpamIpAddressesListRequest {
	r.presentInVrf = &presentInVrf
	return r
}

func (r ApiIpamIpAddressesListRequest) PresentInVrfId(presentInVrfId string) ApiIpamIpAddressesListRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

// Search
func (r ApiIpamIpAddressesListRequest) Q(q string) ApiIpamIpAddressesListRequest {
	r.q = &q
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) Role(role []*string) ApiIpamIpAddressesListRequest {
	r.role = &role
	return r
}

func (r ApiIpamIpAddressesListRequest) RoleEmpty(roleEmpty bool) ApiIpamIpAddressesListRequest {
	r.roleEmpty = &roleEmpty
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) RoleIc(roleIc []*string) ApiIpamIpAddressesListRequest {
	r.roleIc = &roleIc
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) RoleIe(roleIe []*string) ApiIpamIpAddressesListRequest {
	r.roleIe = &roleIe
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) RoleIew(roleIew []*string) ApiIpamIpAddressesListRequest {
	r.roleIew = &roleIew
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) RoleIsw(roleIsw []*string) ApiIpamIpAddressesListRequest {
	r.roleIsw = &roleIsw
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) RoleN(roleN []*string) ApiIpamIpAddressesListRequest {
	r.roleN = &roleN
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) RoleNic(roleNic []*string) ApiIpamIpAddressesListRequest {
	r.roleNic = &roleNic
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) RoleNie(roleNie []*string) ApiIpamIpAddressesListRequest {
	r.roleNie = &roleNie
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) RoleNiew(roleNiew []*string) ApiIpamIpAddressesListRequest {
	r.roleNiew = &roleNiew
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) RoleNisw(roleNisw []*string) ApiIpamIpAddressesListRequest {
	r.roleNisw = &roleNisw
	return r
}

// Service (ID)
func (r ApiIpamIpAddressesListRequest) ServiceId(serviceId []int32) ApiIpamIpAddressesListRequest {
	r.serviceId = &serviceId
	return r
}

// Service (ID)
func (r ApiIpamIpAddressesListRequest) ServiceIdN(serviceIdN []int32) ApiIpamIpAddressesListRequest {
	r.serviceIdN = &serviceIdN
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) Status(status []string) ApiIpamIpAddressesListRequest {
	r.status = &status
	return r
}

func (r ApiIpamIpAddressesListRequest) StatusEmpty(statusEmpty bool) ApiIpamIpAddressesListRequest {
	r.statusEmpty = &statusEmpty
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) StatusIc(statusIc []string) ApiIpamIpAddressesListRequest {
	r.statusIc = &statusIc
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) StatusIe(statusIe []string) ApiIpamIpAddressesListRequest {
	r.statusIe = &statusIe
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) StatusIew(statusIew []string) ApiIpamIpAddressesListRequest {
	r.statusIew = &statusIew
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) StatusIsw(statusIsw []string) ApiIpamIpAddressesListRequest {
	r.statusIsw = &statusIsw
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) StatusN(statusN []string) ApiIpamIpAddressesListRequest {
	r.statusN = &statusN
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) StatusNic(statusNic []string) ApiIpamIpAddressesListRequest {
	r.statusNic = &statusNic
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) StatusNie(statusNie []string) ApiIpamIpAddressesListRequest {
	r.statusNie = &statusNie
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) StatusNiew(statusNiew []string) ApiIpamIpAddressesListRequest {
	r.statusNiew = &statusNiew
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) StatusNisw(statusNisw []string) ApiIpamIpAddressesListRequest {
	r.statusNisw = &statusNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) Tag(tag []string) ApiIpamIpAddressesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamIpAddressesListRequest) TagN(tagN []string) ApiIpamIpAddressesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamIpAddressesListRequest) Tenant(tenant []string) ApiIpamIpAddressesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamIpAddressesListRequest) TenantN(tenantN []string) ApiIpamIpAddressesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroup(tenantGroup []string) ApiIpamIpAddressesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamIpAddressesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamIpAddressesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamIpAddressesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamIpAddressesListRequest) TenantId(tenantId []*int32) ApiIpamIpAddressesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamIpAddressesListRequest) TenantIdN(tenantIdN []*int32) ApiIpamIpAddressesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamIpAddressesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamIpAddressesListRequest) VirtualMachine(virtualMachine []string) ApiIpamIpAddressesListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

func (r ApiIpamIpAddressesListRequest) VirtualMachineId(virtualMachineId []int32) ApiIpamIpAddressesListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

// VM interface (name)
func (r ApiIpamIpAddressesListRequest) Vminterface(vminterface []string) ApiIpamIpAddressesListRequest {
	r.vminterface = &vminterface
	return r
}

// VM interface (name)
func (r ApiIpamIpAddressesListRequest) VminterfaceN(vminterfaceN []string) ApiIpamIpAddressesListRequest {
	r.vminterfaceN = &vminterfaceN
	return r
}

// VM interface (ID)
func (r ApiIpamIpAddressesListRequest) VminterfaceId(vminterfaceId []int32) ApiIpamIpAddressesListRequest {
	r.vminterfaceId = &vminterfaceId
	return r
}

// VM interface (ID)
func (r ApiIpamIpAddressesListRequest) VminterfaceIdN(vminterfaceIdN []int32) ApiIpamIpAddressesListRequest {
	r.vminterfaceIdN = &vminterfaceIdN
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesListRequest) Vrf(vrf []*string) ApiIpamIpAddressesListRequest {
	r.vrf = &vrf
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesListRequest) VrfN(vrfN []*string) ApiIpamIpAddressesListRequest {
	r.vrfN = &vrfN
	return r
}

// VRF
func (r ApiIpamIpAddressesListRequest) VrfId(vrfId []*int32) ApiIpamIpAddressesListRequest {
	r.vrfId = &vrfId
	return r
}

// VRF
func (r ApiIpamIpAddressesListRequest) VrfIdN(vrfIdN []*int32) ApiIpamIpAddressesListRequest {
	r.vrfIdN = &vrfIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) Execute() (*PaginatedIPAddressList, *http.Response, error) {
	return r.ApiService.IpamIpAddressesListExecute(r)
}

/*
IpamIpAddressesList Method for IpamIpAddressesList

Get a list of IP address objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesListRequest
*/
func (a *IpamAPIService) IpamIpAddressesList(ctx context.Context) ApiIpamIpAddressesListRequest {
	return ApiIpamIpAddressesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIPAddressList
func (a *IpamAPIService) IpamIpAddressesListExecute(r ApiIpamIpAddressesListRequest) (*PaginatedIPAddressList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIPAddressList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		t := *r.address
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "address", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "address", t, "form", "multi")
		}
	}
	if r.assigned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned", r.assigned, "form", "")
	}
	if r.assignedObjectId != nil {
		t := *r.assignedObjectId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id", t, "form", "multi")
		}
	}
	if r.assignedObjectIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__empty", r.assignedObjectIdEmpty, "form", "")
	}
	if r.assignedObjectIdGt != nil {
		t := *r.assignedObjectIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gt", t, "form", "multi")
		}
	}
	if r.assignedObjectIdGte != nil {
		t := *r.assignedObjectIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gte", t, "form", "multi")
		}
	}
	if r.assignedObjectIdLt != nil {
		t := *r.assignedObjectIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lt", t, "form", "multi")
		}
	}
	if r.assignedObjectIdLte != nil {
		t := *r.assignedObjectIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lte", t, "form", "multi")
		}
	}
	if r.assignedObjectIdN != nil {
		t := *r.assignedObjectIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__n", t, "form", "multi")
		}
	}
	if r.assignedObjectType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_type", r.assignedObjectType, "form", "")
	}
	if r.assignedObjectTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_type__n", r.assignedObjectTypeN, "form", "")
	}
	if r.assignedToInterface != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_to_interface", r.assignedToInterface, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "form", "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "form", "multi")
		}
	}
	if r.dnsName != nil {
		t := *r.dnsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name", t, "form", "multi")
		}
	}
	if r.dnsNameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__empty", r.dnsNameEmpty, "form", "")
	}
	if r.dnsNameIc != nil {
		t := *r.dnsNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ic", t, "form", "multi")
		}
	}
	if r.dnsNameIe != nil {
		t := *r.dnsNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ie", t, "form", "multi")
		}
	}
	if r.dnsNameIew != nil {
		t := *r.dnsNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__iew", t, "form", "multi")
		}
	}
	if r.dnsNameIsw != nil {
		t := *r.dnsNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__isw", t, "form", "multi")
		}
	}
	if r.dnsNameN != nil {
		t := *r.dnsNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__n", t, "form", "multi")
		}
	}
	if r.dnsNameNic != nil {
		t := *r.dnsNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nic", t, "form", "multi")
		}
	}
	if r.dnsNameNie != nil {
		t := *r.dnsNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nie", t, "form", "multi")
		}
	}
	if r.dnsNameNiew != nil {
		t := *r.dnsNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__niew", t, "form", "multi")
		}
	}
	if r.dnsNameNisw != nil {
		t := *r.dnsNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nisw", t, "form", "multi")
		}
	}
	if r.family != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "family", r.family, "form", "")
	}
	if r.fhrpgroupId != nil {
		t := *r.fhrpgroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fhrpgroup_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fhrpgroup_id", t, "form", "multi")
		}
	}
	if r.fhrpgroupIdN != nil {
		t := *r.fhrpgroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fhrpgroup_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fhrpgroup_id__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.interface_ != nil {
		t := *r.interface_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface", t, "form", "multi")
		}
	}
	if r.interfaceN != nil {
		t := *r.interfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", t, "form", "multi")
		}
	}
	if r.interfaceId != nil {
		t := *r.interfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", t, "form", "multi")
		}
	}
	if r.interfaceIdN != nil {
		t := *r.interfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.maskLength != nil {
		t := *r.maskLength
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length", t, "form", "multi")
		}
	}
	if r.maskLengthGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__gte", r.maskLengthGte, "form", "")
	}
	if r.maskLengthLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__lte", r.maskLengthLte, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.natInsideId != nil {
		t := *r.natInsideId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside_id", t, "form", "multi")
		}
	}
	if r.natInsideIdN != nil {
		t := *r.natInsideIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside_id__n", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.parent != nil {
		t := *r.parent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent", t, "form", "multi")
		}
	}
	if r.presentInVrf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf", r.presentInVrf, "form", "")
	}
	if r.presentInVrfId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf_id", r.presentInVrfId, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "form", "multi")
		}
	}
	if r.roleEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role__empty", r.roleEmpty, "form", "")
	}
	if r.roleIc != nil {
		t := *r.roleIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__ic", t, "form", "multi")
		}
	}
	if r.roleIe != nil {
		t := *r.roleIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__ie", t, "form", "multi")
		}
	}
	if r.roleIew != nil {
		t := *r.roleIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__iew", t, "form", "multi")
		}
	}
	if r.roleIsw != nil {
		t := *r.roleIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__isw", t, "form", "multi")
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "form", "multi")
		}
	}
	if r.roleNic != nil {
		t := *r.roleNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__nic", t, "form", "multi")
		}
	}
	if r.roleNie != nil {
		t := *r.roleNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__nie", t, "form", "multi")
		}
	}
	if r.roleNiew != nil {
		t := *r.roleNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__niew", t, "form", "multi")
		}
	}
	if r.roleNisw != nil {
		t := *r.roleNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__nisw", t, "form", "multi")
		}
	}
	if r.serviceId != nil {
		t := *r.serviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_id", t, "form", "multi")
		}
	}
	if r.serviceIdN != nil {
		t := *r.serviceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_id__n", t, "form", "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.statusEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__empty", r.statusEmpty, "form", "")
	}
	if r.statusIc != nil {
		t := *r.statusIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__ic", t, "form", "multi")
		}
	}
	if r.statusIe != nil {
		t := *r.statusIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__ie", t, "form", "multi")
		}
	}
	if r.statusIew != nil {
		t := *r.statusIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__iew", t, "form", "multi")
		}
	}
	if r.statusIsw != nil {
		t := *r.statusIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__isw", t, "form", "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "form", "multi")
		}
	}
	if r.statusNic != nil {
		t := *r.statusNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nic", t, "form", "multi")
		}
	}
	if r.statusNie != nil {
		t := *r.statusNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nie", t, "form", "multi")
		}
	}
	if r.statusNiew != nil {
		t := *r.statusNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__niew", t, "form", "multi")
		}
	}
	if r.statusNisw != nil {
		t := *r.statusNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "form", "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", t, "form", "multi")
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", t, "form", "multi")
		}
	}
	if r.vminterface != nil {
		t := *r.vminterface
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface", t, "form", "multi")
		}
	}
	if r.vminterfaceN != nil {
		t := *r.vminterfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface__n", t, "form", "multi")
		}
	}
	if r.vminterfaceId != nil {
		t := *r.vminterfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id", t, "form", "multi")
		}
	}
	if r.vminterfaceIdN != nil {
		t := *r.vminterfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id__n", t, "form", "multi")
		}
	}
	if r.vrf != nil {
		t := *r.vrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", t, "form", "multi")
		}
	}
	if r.vrfN != nil {
		t := *r.vrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", t, "form", "multi")
		}
	}
	if r.vrfId != nil {
		t := *r.vrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", t, "form", "multi")
		}
	}
	if r.vrfIdN != nil {
		t := *r.vrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedWritableIPAddressRequest *PatchedWritableIPAddressRequest
}

func (r ApiIpamIpAddressesPartialUpdateRequest) PatchedWritableIPAddressRequest(patchedWritableIPAddressRequest PatchedWritableIPAddressRequest) ApiIpamIpAddressesPartialUpdateRequest {
	r.patchedWritableIPAddressRequest = &patchedWritableIPAddressRequest
	return r
}

func (r ApiIpamIpAddressesPartialUpdateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesPartialUpdateExecute(r)
}

/*
IpamIpAddressesPartialUpdate Method for IpamIpAddressesPartialUpdate

Patch a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP address.
 @return ApiIpamIpAddressesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesPartialUpdate(ctx context.Context, id int32) ApiIpamIpAddressesPartialUpdateRequest {
	return ApiIpamIpAddressesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamAPIService) IpamIpAddressesPartialUpdateExecute(r ApiIpamIpAddressesPartialUpdateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableIPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamIpAddressesRetrieveRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesRetrieveExecute(r)
}

/*
IpamIpAddressesRetrieve Method for IpamIpAddressesRetrieve

Get a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP address.
 @return ApiIpamIpAddressesRetrieveRequest
*/
func (a *IpamAPIService) IpamIpAddressesRetrieve(ctx context.Context, id int32) ApiIpamIpAddressesRetrieveRequest {
	return ApiIpamIpAddressesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamAPIService) IpamIpAddressesRetrieveExecute(r ApiIpamIpAddressesRetrieveRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	writableIPAddressRequest *WritableIPAddressRequest
}

func (r ApiIpamIpAddressesUpdateRequest) WritableIPAddressRequest(writableIPAddressRequest WritableIPAddressRequest) ApiIpamIpAddressesUpdateRequest {
	r.writableIPAddressRequest = &writableIPAddressRequest
	return r
}

func (r ApiIpamIpAddressesUpdateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesUpdateExecute(r)
}

/*
IpamIpAddressesUpdate Method for IpamIpAddressesUpdate

Put a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP address.
 @return ApiIpamIpAddressesUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesUpdate(ctx context.Context, id int32) ApiIpamIpAddressesUpdateRequest {
	return ApiIpamIpAddressesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddress
func (a *IpamAPIService) IpamIpAddressesUpdateExecute(r ApiIpamIpAddressesUpdateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesAvailableIpsCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	iPAddressRequest *[]IPAddressRequest
}

func (r ApiIpamIpRangesAvailableIpsCreateRequest) IPAddressRequest(iPAddressRequest []IPAddressRequest) ApiIpamIpRangesAvailableIpsCreateRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamIpRangesAvailableIpsCreateRequest) Execute() ([]IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpRangesAvailableIpsCreateExecute(r)
}

/*
IpamIpRangesAvailableIpsCreate Method for IpamIpRangesAvailableIpsCreate

Post a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIpamIpRangesAvailableIpsCreateRequest
*/
func (a *IpamAPIService) IpamIpRangesAvailableIpsCreate(ctx context.Context, id int32) ApiIpamIpRangesAvailableIpsCreateRequest {
	return ApiIpamIpRangesAvailableIpsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []IPAddress
func (a *IpamAPIService) IpamIpRangesAvailableIpsCreateExecute(r ApiIpamIpRangesAvailableIpsCreateRequest) ([]IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesAvailableIpsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesAvailableIpsListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamIpRangesAvailableIpsListRequest) Execute() ([]AvailableIP, *http.Response, error) {
	return r.ApiService.IpamIpRangesAvailableIpsListExecute(r)
}

/*
IpamIpRangesAvailableIpsList Method for IpamIpRangesAvailableIpsList

Get a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIpamIpRangesAvailableIpsListRequest
*/
func (a *IpamAPIService) IpamIpRangesAvailableIpsList(ctx context.Context, id int32) ApiIpamIpRangesAvailableIpsListRequest {
	return ApiIpamIpRangesAvailableIpsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []AvailableIP
func (a *IpamAPIService) IpamIpRangesAvailableIpsListExecute(r ApiIpamIpRangesAvailableIpsListRequest) ([]AvailableIP, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AvailableIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesAvailableIpsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	iPRangeRequest *[]IPRangeRequest
}

func (r ApiIpamIpRangesBulkDestroyRequest) IPRangeRequest(iPRangeRequest []IPRangeRequest) ApiIpamIpRangesBulkDestroyRequest {
	r.iPRangeRequest = &iPRangeRequest
	return r
}

func (r ApiIpamIpRangesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpRangesBulkDestroyExecute(r)
}

/*
IpamIpRangesBulkDestroy Method for IpamIpRangesBulkDestroy

Delete a list of IP range objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpRangesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamIpRangesBulkDestroy(ctx context.Context) ApiIpamIpRangesBulkDestroyRequest {
	return ApiIpamIpRangesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpRangesBulkDestroyExecute(r ApiIpamIpRangesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPRangeRequest == nil {
		return nil, reportError("iPRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpRangesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	iPRangeRequest *[]IPRangeRequest
}

func (r ApiIpamIpRangesBulkPartialUpdateRequest) IPRangeRequest(iPRangeRequest []IPRangeRequest) ApiIpamIpRangesBulkPartialUpdateRequest {
	r.iPRangeRequest = &iPRangeRequest
	return r
}

func (r ApiIpamIpRangesBulkPartialUpdateRequest) Execute() ([]IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesBulkPartialUpdateExecute(r)
}

/*
IpamIpRangesBulkPartialUpdate Method for IpamIpRangesBulkPartialUpdate

Patch a list of IP range objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpRangesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpRangesBulkPartialUpdate(ctx context.Context) ApiIpamIpRangesBulkPartialUpdateRequest {
	return ApiIpamIpRangesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPRange
func (a *IpamAPIService) IpamIpRangesBulkPartialUpdateExecute(r ApiIpamIpRangesBulkPartialUpdateRequest) ([]IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPRangeRequest == nil {
		return localVarReturnValue, nil, reportError("iPRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	iPRangeRequest *[]IPRangeRequest
}

func (r ApiIpamIpRangesBulkUpdateRequest) IPRangeRequest(iPRangeRequest []IPRangeRequest) ApiIpamIpRangesBulkUpdateRequest {
	r.iPRangeRequest = &iPRangeRequest
	return r
}

func (r ApiIpamIpRangesBulkUpdateRequest) Execute() ([]IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesBulkUpdateExecute(r)
}

/*
IpamIpRangesBulkUpdate Method for IpamIpRangesBulkUpdate

Put a list of IP range objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpRangesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamIpRangesBulkUpdate(ctx context.Context) ApiIpamIpRangesBulkUpdateRequest {
	return ApiIpamIpRangesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IPRange
func (a *IpamAPIService) IpamIpRangesBulkUpdateExecute(r ApiIpamIpRangesBulkUpdateRequest) ([]IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPRangeRequest == nil {
		return localVarReturnValue, nil, reportError("iPRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	writableIPRangeRequest *WritableIPRangeRequest
}

func (r ApiIpamIpRangesCreateRequest) WritableIPRangeRequest(writableIPRangeRequest WritableIPRangeRequest) ApiIpamIpRangesCreateRequest {
	r.writableIPRangeRequest = &writableIPRangeRequest
	return r
}

func (r ApiIpamIpRangesCreateRequest) Execute() (*IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesCreateExecute(r)
}

/*
IpamIpRangesCreate Method for IpamIpRangesCreate

Post a list of IP range objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpRangesCreateRequest
*/
func (a *IpamAPIService) IpamIpRangesCreate(ctx context.Context) ApiIpamIpRangesCreateRequest {
	return ApiIpamIpRangesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPRange
func (a *IpamAPIService) IpamIpRangesCreateExecute(r ApiIpamIpRangesCreateRequest) (*IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPRangeRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamIpRangesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpRangesDestroyExecute(r)
}

/*
IpamIpRangesDestroy Method for IpamIpRangesDestroy

Delete a IP range object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP range.
 @return ApiIpamIpRangesDestroyRequest
*/
func (a *IpamAPIService) IpamIpRangesDestroy(ctx context.Context, id int32) ApiIpamIpRangesDestroyRequest {
	return ApiIpamIpRangesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpRangesDestroyExecute(r ApiIpamIpRangesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpRangesListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	contains *string
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	endAddress *[]string
	family *float32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	markUtilized *bool
	modifiedByRequest *string
	offset *int32
	ordering *string
	parent *[]string
	q *string
	role *[]string
	roleN *[]string
	roleId *[]*int32
	roleIdN *[]*int32
	size *[]int32
	sizeEmpty *bool
	sizeGt *[]int32
	sizeGte *[]int32
	sizeLt *[]int32
	sizeLte *[]int32
	sizeN *[]int32
	startAddress *[]string
	status *[]string
	statusEmpty *bool
	statusIc *[]string
	statusIe *[]string
	statusIew *[]string
	statusIsw *[]string
	statusN *[]string
	statusNic *[]string
	statusNie *[]string
	statusNiew *[]string
	statusNisw *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*int32
	tenantIdN *[]*int32
	updatedByRequest *string
	vrf *[]*string
	vrfN *[]*string
	vrfId *[]*int32
	vrfIdN *[]*int32
}

// Ranges which contain this prefix or IP
func (r ApiIpamIpRangesListRequest) Contains(contains string) ApiIpamIpRangesListRequest {
	r.contains = &contains
	return r
}

func (r ApiIpamIpRangesListRequest) Created(created []time.Time) ApiIpamIpRangesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamIpRangesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedGt(createdGt []time.Time) ApiIpamIpRangesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedGte(createdGte []time.Time) ApiIpamIpRangesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedLt(createdLt []time.Time) ApiIpamIpRangesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedLte(createdLte []time.Time) ApiIpamIpRangesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedN(createdN []time.Time) ApiIpamIpRangesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedByRequest(createdByRequest string) ApiIpamIpRangesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamIpRangesListRequest) Description(description []string) ApiIpamIpRangesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamIpRangesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionIc(descriptionIc []string) ApiIpamIpRangesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionIe(descriptionIe []string) ApiIpamIpRangesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionIew(descriptionIew []string) ApiIpamIpRangesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamIpRangesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionN(descriptionN []string) ApiIpamIpRangesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionNic(descriptionNic []string) ApiIpamIpRangesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionNie(descriptionNie []string) ApiIpamIpRangesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamIpRangesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamIpRangesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamIpRangesListRequest) EndAddress(endAddress []string) ApiIpamIpRangesListRequest {
	r.endAddress = &endAddress
	return r
}

func (r ApiIpamIpRangesListRequest) Family(family float32) ApiIpamIpRangesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamIpRangesListRequest) Id(id []int32) ApiIpamIpRangesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamIpRangesListRequest) IdEmpty(idEmpty bool) ApiIpamIpRangesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamIpRangesListRequest) IdGt(idGt []int32) ApiIpamIpRangesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamIpRangesListRequest) IdGte(idGte []int32) ApiIpamIpRangesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamIpRangesListRequest) IdLt(idLt []int32) ApiIpamIpRangesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamIpRangesListRequest) IdLte(idLte []int32) ApiIpamIpRangesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamIpRangesListRequest) IdN(idN []int32) ApiIpamIpRangesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamIpRangesListRequest) Limit(limit int32) ApiIpamIpRangesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamIpRangesListRequest) MarkUtilized(markUtilized bool) ApiIpamIpRangesListRequest {
	r.markUtilized = &markUtilized
	return r
}

func (r ApiIpamIpRangesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamIpRangesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpRangesListRequest) Offset(offset int32) ApiIpamIpRangesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamIpRangesListRequest) Ordering(ordering string) ApiIpamIpRangesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamIpRangesListRequest) Parent(parent []string) ApiIpamIpRangesListRequest {
	r.parent = &parent
	return r
}

// Search
func (r ApiIpamIpRangesListRequest) Q(q string) ApiIpamIpRangesListRequest {
	r.q = &q
	return r
}

// Role (slug)
func (r ApiIpamIpRangesListRequest) Role(role []string) ApiIpamIpRangesListRequest {
	r.role = &role
	return r
}

// Role (slug)
func (r ApiIpamIpRangesListRequest) RoleN(roleN []string) ApiIpamIpRangesListRequest {
	r.roleN = &roleN
	return r
}

// Role (ID)
func (r ApiIpamIpRangesListRequest) RoleId(roleId []*int32) ApiIpamIpRangesListRequest {
	r.roleId = &roleId
	return r
}

// Role (ID)
func (r ApiIpamIpRangesListRequest) RoleIdN(roleIdN []*int32) ApiIpamIpRangesListRequest {
	r.roleIdN = &roleIdN
	return r
}

func (r ApiIpamIpRangesListRequest) Size(size []int32) ApiIpamIpRangesListRequest {
	r.size = &size
	return r
}

func (r ApiIpamIpRangesListRequest) SizeEmpty(sizeEmpty bool) ApiIpamIpRangesListRequest {
	r.sizeEmpty = &sizeEmpty
	return r
}

func (r ApiIpamIpRangesListRequest) SizeGt(sizeGt []int32) ApiIpamIpRangesListRequest {
	r.sizeGt = &sizeGt
	return r
}

func (r ApiIpamIpRangesListRequest) SizeGte(sizeGte []int32) ApiIpamIpRangesListRequest {
	r.sizeGte = &sizeGte
	return r
}

func (r ApiIpamIpRangesListRequest) SizeLt(sizeLt []int32) ApiIpamIpRangesListRequest {
	r.sizeLt = &sizeLt
	return r
}

func (r ApiIpamIpRangesListRequest) SizeLte(sizeLte []int32) ApiIpamIpRangesListRequest {
	r.sizeLte = &sizeLte
	return r
}

func (r ApiIpamIpRangesListRequest) SizeN(sizeN []int32) ApiIpamIpRangesListRequest {
	r.sizeN = &sizeN
	return r
}

func (r ApiIpamIpRangesListRequest) StartAddress(startAddress []string) ApiIpamIpRangesListRequest {
	r.startAddress = &startAddress
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) Status(status []string) ApiIpamIpRangesListRequest {
	r.status = &status
	return r
}

func (r ApiIpamIpRangesListRequest) StatusEmpty(statusEmpty bool) ApiIpamIpRangesListRequest {
	r.statusEmpty = &statusEmpty
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) StatusIc(statusIc []string) ApiIpamIpRangesListRequest {
	r.statusIc = &statusIc
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) StatusIe(statusIe []string) ApiIpamIpRangesListRequest {
	r.statusIe = &statusIe
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) StatusIew(statusIew []string) ApiIpamIpRangesListRequest {
	r.statusIew = &statusIew
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) StatusIsw(statusIsw []string) ApiIpamIpRangesListRequest {
	r.statusIsw = &statusIsw
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) StatusN(statusN []string) ApiIpamIpRangesListRequest {
	r.statusN = &statusN
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) StatusNic(statusNic []string) ApiIpamIpRangesListRequest {
	r.statusNic = &statusNic
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) StatusNie(statusNie []string) ApiIpamIpRangesListRequest {
	r.statusNie = &statusNie
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) StatusNiew(statusNiew []string) ApiIpamIpRangesListRequest {
	r.statusNiew = &statusNiew
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) StatusNisw(statusNisw []string) ApiIpamIpRangesListRequest {
	r.statusNisw = &statusNisw
	return r
}

func (r ApiIpamIpRangesListRequest) Tag(tag []string) ApiIpamIpRangesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamIpRangesListRequest) TagN(tagN []string) ApiIpamIpRangesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamIpRangesListRequest) Tenant(tenant []string) ApiIpamIpRangesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamIpRangesListRequest) TenantN(tenantN []string) ApiIpamIpRangesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamIpRangesListRequest) TenantGroup(tenantGroup []string) ApiIpamIpRangesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamIpRangesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamIpRangesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamIpRangesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamIpRangesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamIpRangesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamIpRangesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamIpRangesListRequest) TenantId(tenantId []*int32) ApiIpamIpRangesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamIpRangesListRequest) TenantIdN(tenantIdN []*int32) ApiIpamIpRangesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamIpRangesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamIpRangesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

// VRF (RD)
func (r ApiIpamIpRangesListRequest) Vrf(vrf []*string) ApiIpamIpRangesListRequest {
	r.vrf = &vrf
	return r
}

// VRF (RD)
func (r ApiIpamIpRangesListRequest) VrfN(vrfN []*string) ApiIpamIpRangesListRequest {
	r.vrfN = &vrfN
	return r
}

// VRF
func (r ApiIpamIpRangesListRequest) VrfId(vrfId []*int32) ApiIpamIpRangesListRequest {
	r.vrfId = &vrfId
	return r
}

// VRF
func (r ApiIpamIpRangesListRequest) VrfIdN(vrfIdN []*int32) ApiIpamIpRangesListRequest {
	r.vrfIdN = &vrfIdN
	return r
}

func (r ApiIpamIpRangesListRequest) Execute() (*PaginatedIPRangeList, *http.Response, error) {
	return r.ApiService.IpamIpRangesListExecute(r)
}

/*
IpamIpRangesList Method for IpamIpRangesList

Get a list of IP range objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpRangesListRequest
*/
func (a *IpamAPIService) IpamIpRangesList(ctx context.Context) ApiIpamIpRangesListRequest {
	return ApiIpamIpRangesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIPRangeList
func (a *IpamAPIService) IpamIpRangesListExecute(r ApiIpamIpRangesListRequest) (*PaginatedIPRangeList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIPRangeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.endAddress != nil {
		t := *r.endAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end_address", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end_address", t, "form", "multi")
		}
	}
	if r.family != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "family", r.family, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.markUtilized != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mark_utilized", r.markUtilized, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.parent != nil {
		t := *r.parent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "form", "multi")
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "form", "multi")
		}
	}
	if r.roleId != nil {
		t := *r.roleId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", t, "form", "multi")
		}
	}
	if r.roleIdN != nil {
		t := *r.roleIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", t, "form", "multi")
		}
	}
	if r.size != nil {
		t := *r.size
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size", t, "form", "multi")
		}
	}
	if r.sizeEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size__empty", r.sizeEmpty, "form", "")
	}
	if r.sizeGt != nil {
		t := *r.sizeGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size__gt", t, "form", "multi")
		}
	}
	if r.sizeGte != nil {
		t := *r.sizeGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size__gte", t, "form", "multi")
		}
	}
	if r.sizeLt != nil {
		t := *r.sizeLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size__lt", t, "form", "multi")
		}
	}
	if r.sizeLte != nil {
		t := *r.sizeLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size__lte", t, "form", "multi")
		}
	}
	if r.sizeN != nil {
		t := *r.sizeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size__n", t, "form", "multi")
		}
	}
	if r.startAddress != nil {
		t := *r.startAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start_address", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start_address", t, "form", "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.statusEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__empty", r.statusEmpty, "form", "")
	}
	if r.statusIc != nil {
		t := *r.statusIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__ic", t, "form", "multi")
		}
	}
	if r.statusIe != nil {
		t := *r.statusIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__ie", t, "form", "multi")
		}
	}
	if r.statusIew != nil {
		t := *r.statusIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__iew", t, "form", "multi")
		}
	}
	if r.statusIsw != nil {
		t := *r.statusIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__isw", t, "form", "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "form", "multi")
		}
	}
	if r.statusNic != nil {
		t := *r.statusNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nic", t, "form", "multi")
		}
	}
	if r.statusNie != nil {
		t := *r.statusNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nie", t, "form", "multi")
		}
	}
	if r.statusNiew != nil {
		t := *r.statusNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__niew", t, "form", "multi")
		}
	}
	if r.statusNisw != nil {
		t := *r.statusNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "form", "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	if r.vrf != nil {
		t := *r.vrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", t, "form", "multi")
		}
	}
	if r.vrfN != nil {
		t := *r.vrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", t, "form", "multi")
		}
	}
	if r.vrfId != nil {
		t := *r.vrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", t, "form", "multi")
		}
	}
	if r.vrfIdN != nil {
		t := *r.vrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedWritableIPRangeRequest *PatchedWritableIPRangeRequest
}

func (r ApiIpamIpRangesPartialUpdateRequest) PatchedWritableIPRangeRequest(patchedWritableIPRangeRequest PatchedWritableIPRangeRequest) ApiIpamIpRangesPartialUpdateRequest {
	r.patchedWritableIPRangeRequest = &patchedWritableIPRangeRequest
	return r
}

func (r ApiIpamIpRangesPartialUpdateRequest) Execute() (*IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesPartialUpdateExecute(r)
}

/*
IpamIpRangesPartialUpdate Method for IpamIpRangesPartialUpdate

Patch a IP range object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP range.
 @return ApiIpamIpRangesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpRangesPartialUpdate(ctx context.Context, id int32) ApiIpamIpRangesPartialUpdateRequest {
	return ApiIpamIpRangesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPRange
func (a *IpamAPIService) IpamIpRangesPartialUpdateExecute(r ApiIpamIpRangesPartialUpdateRequest) (*IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableIPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamIpRangesRetrieveRequest) Execute() (*IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesRetrieveExecute(r)
}

/*
IpamIpRangesRetrieve Method for IpamIpRangesRetrieve

Get a IP range object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP range.
 @return ApiIpamIpRangesRetrieveRequest
*/
func (a *IpamAPIService) IpamIpRangesRetrieve(ctx context.Context, id int32) ApiIpamIpRangesRetrieveRequest {
	return ApiIpamIpRangesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPRange
func (a *IpamAPIService) IpamIpRangesRetrieveExecute(r ApiIpamIpRangesRetrieveRequest) (*IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	writableIPRangeRequest *WritableIPRangeRequest
}

func (r ApiIpamIpRangesUpdateRequest) WritableIPRangeRequest(writableIPRangeRequest WritableIPRangeRequest) ApiIpamIpRangesUpdateRequest {
	r.writableIPRangeRequest = &writableIPRangeRequest
	return r
}

func (r ApiIpamIpRangesUpdateRequest) Execute() (*IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesUpdateExecute(r)
}

/*
IpamIpRangesUpdate Method for IpamIpRangesUpdate

Put a IP range object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this IP range.
 @return ApiIpamIpRangesUpdateRequest
*/
func (a *IpamAPIService) IpamIpRangesUpdate(ctx context.Context, id int32) ApiIpamIpRangesUpdateRequest {
	return ApiIpamIpRangesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPRange
func (a *IpamAPIService) IpamIpRangesUpdateExecute(r ApiIpamIpRangesUpdateRequest) (*IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPRangeRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailableIpsCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	iPAddressRequest *[]IPAddressRequest
}

func (r ApiIpamPrefixesAvailableIpsCreateRequest) IPAddressRequest(iPAddressRequest []IPAddressRequest) ApiIpamPrefixesAvailableIpsCreateRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamPrefixesAvailableIpsCreateRequest) Execute() ([]IPAddress, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailableIpsCreateExecute(r)
}

/*
IpamPrefixesAvailableIpsCreate Method for IpamPrefixesAvailableIpsCreate

Post a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIpamPrefixesAvailableIpsCreateRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailableIpsCreate(ctx context.Context, id int32) ApiIpamPrefixesAvailableIpsCreateRequest {
	return ApiIpamPrefixesAvailableIpsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []IPAddress
func (a *IpamAPIService) IpamPrefixesAvailableIpsCreateExecute(r ApiIpamPrefixesAvailableIpsCreateRequest) ([]IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailableIpsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailableIpsListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamPrefixesAvailableIpsListRequest) Execute() ([]AvailableIP, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailableIpsListExecute(r)
}

/*
IpamPrefixesAvailableIpsList Method for IpamPrefixesAvailableIpsList

Get a IP address object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIpamPrefixesAvailableIpsListRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailableIpsList(ctx context.Context, id int32) ApiIpamPrefixesAvailableIpsListRequest {
	return ApiIpamPrefixesAvailableIpsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []AvailableIP
func (a *IpamAPIService) IpamPrefixesAvailableIpsListExecute(r ApiIpamPrefixesAvailableIpsListRequest) ([]AvailableIP, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AvailableIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailableIpsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailablePrefixesCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	prefixRequest *[]PrefixRequest
}

func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) PrefixRequest(prefixRequest []PrefixRequest) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	r.prefixRequest = &prefixRequest
	return r
}

func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) Execute() ([]Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailablePrefixesCreateExecute(r)
}

/*
IpamPrefixesAvailablePrefixesCreate Method for IpamPrefixesAvailablePrefixesCreate

Post a prefix object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIpamPrefixesAvailablePrefixesCreateRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesCreate(ctx context.Context, id int32) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	return ApiIpamPrefixesAvailablePrefixesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []Prefix
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesCreateExecute(r ApiIpamPrefixesAvailablePrefixesCreateRequest) ([]Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailablePrefixesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/available-prefixes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixRequest == nil {
		return localVarReturnValue, nil, reportError("prefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailablePrefixesListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamPrefixesAvailablePrefixesListRequest) Execute() ([]AvailablePrefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailablePrefixesListExecute(r)
}

/*
IpamPrefixesAvailablePrefixesList Method for IpamPrefixesAvailablePrefixesList

Get a prefix object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIpamPrefixesAvailablePrefixesListRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesList(ctx context.Context, id int32) ApiIpamPrefixesAvailablePrefixesListRequest {
	return ApiIpamPrefixesAvailablePrefixesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []AvailablePrefix
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesListExecute(r ApiIpamPrefixesAvailablePrefixesListRequest) ([]AvailablePrefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AvailablePrefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailablePrefixesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/available-prefixes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	prefixRequest *[]PrefixRequest
}

func (r ApiIpamPrefixesBulkDestroyRequest) PrefixRequest(prefixRequest []PrefixRequest) ApiIpamPrefixesBulkDestroyRequest {
	r.prefixRequest = &prefixRequest
	return r
}

func (r ApiIpamPrefixesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixesBulkDestroyExecute(r)
}

/*
IpamPrefixesBulkDestroy Method for IpamPrefixesBulkDestroy

Delete a list of prefix objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamPrefixesBulkDestroy(ctx context.Context) ApiIpamPrefixesBulkDestroyRequest {
	return ApiIpamPrefixesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamPrefixesBulkDestroyExecute(r ApiIpamPrefixesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixRequest == nil {
		return nil, reportError("prefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	prefixRequest *[]PrefixRequest
}

func (r ApiIpamPrefixesBulkPartialUpdateRequest) PrefixRequest(prefixRequest []PrefixRequest) ApiIpamPrefixesBulkPartialUpdateRequest {
	r.prefixRequest = &prefixRequest
	return r
}

func (r ApiIpamPrefixesBulkPartialUpdateRequest) Execute() ([]Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesBulkPartialUpdateExecute(r)
}

/*
IpamPrefixesBulkPartialUpdate Method for IpamPrefixesBulkPartialUpdate

Patch a list of prefix objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesBulkPartialUpdate(ctx context.Context) ApiIpamPrefixesBulkPartialUpdateRequest {
	return ApiIpamPrefixesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Prefix
func (a *IpamAPIService) IpamPrefixesBulkPartialUpdateExecute(r ApiIpamPrefixesBulkPartialUpdateRequest) ([]Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixRequest == nil {
		return localVarReturnValue, nil, reportError("prefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	prefixRequest *[]PrefixRequest
}

func (r ApiIpamPrefixesBulkUpdateRequest) PrefixRequest(prefixRequest []PrefixRequest) ApiIpamPrefixesBulkUpdateRequest {
	r.prefixRequest = &prefixRequest
	return r
}

func (r ApiIpamPrefixesBulkUpdateRequest) Execute() ([]Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesBulkUpdateExecute(r)
}

/*
IpamPrefixesBulkUpdate Method for IpamPrefixesBulkUpdate

Put a list of prefix objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesBulkUpdate(ctx context.Context) ApiIpamPrefixesBulkUpdateRequest {
	return ApiIpamPrefixesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Prefix
func (a *IpamAPIService) IpamPrefixesBulkUpdateExecute(r ApiIpamPrefixesBulkUpdateRequest) ([]Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixRequest == nil {
		return localVarReturnValue, nil, reportError("prefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	writablePrefixRequest *WritablePrefixRequest
}

func (r ApiIpamPrefixesCreateRequest) WritablePrefixRequest(writablePrefixRequest WritablePrefixRequest) ApiIpamPrefixesCreateRequest {
	r.writablePrefixRequest = &writablePrefixRequest
	return r
}

func (r ApiIpamPrefixesCreateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesCreateExecute(r)
}

/*
IpamPrefixesCreate Method for IpamPrefixesCreate

Post a list of prefix objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesCreateRequest
*/
func (a *IpamAPIService) IpamPrefixesCreate(ctx context.Context) ApiIpamPrefixesCreateRequest {
	return ApiIpamPrefixesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamAPIService) IpamPrefixesCreateExecute(r ApiIpamPrefixesCreateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePrefixRequest == nil {
		return localVarReturnValue, nil, reportError("writablePrefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePrefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamPrefixesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixesDestroyExecute(r)
}

/*
IpamPrefixesDestroy Method for IpamPrefixesDestroy

Delete a prefix object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesDestroyRequest
*/
func (a *IpamAPIService) IpamPrefixesDestroy(ctx context.Context, id int32) ApiIpamPrefixesDestroyRequest {
	return ApiIpamPrefixesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamPrefixesDestroyExecute(r ApiIpamPrefixesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixesListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	children *[]int32
	childrenEmpty *[]int32
	childrenGt *[]int32
	childrenGte *[]int32
	childrenLt *[]int32
	childrenLte *[]int32
	childrenN *[]int32
	contains *string
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	depth *[]int32
	depthEmpty *[]int32
	depthGt *[]int32
	depthGte *[]int32
	depthLt *[]int32
	depthLte *[]int32
	depthN *[]int32
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	family *float32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	isPool *bool
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *[]string
	locationN *[]string
	locationId *[]string
	locationIdN *[]string
	markUtilized *bool
	maskLength *[]int32
	maskLengthGte *float32
	maskLengthLte *float32
	modifiedByRequest *string
	offset *int32
	ordering *string
	prefix *[]string
	presentInVrf *string
	presentInVrfId *string
	q *string
	region *[]string
	regionN *[]string
	regionId *[]string
	regionIdN *[]string
	role *[]string
	roleN *[]string
	roleId *[]*int32
	roleIdN *[]*int32
	scopeId *[]int32
	scopeIdEmpty *bool
	scopeIdGt *[]int32
	scopeIdGte *[]int32
	scopeIdLt *[]int32
	scopeIdLte *[]int32
	scopeIdN *[]int32
	scopeType *string
	scopeTypeN *string
	site *[]string
	siteN *[]string
	siteGroup *[]string
	siteGroupN *[]string
	siteGroupId *[]string
	siteGroupIdN *[]string
	siteId *[]int32
	siteIdN *[]int32
	status *[]string
	statusEmpty *bool
	statusIc *[]string
	statusIe *[]string
	statusIew *[]string
	statusIsw *[]string
	statusN *[]string
	statusNic *[]string
	statusNie *[]string
	statusNiew *[]string
	statusNisw *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*int32
	tenantIdN *[]*int32
	updatedByRequest *string
	vlanId *[]*int32
	vlanIdN *[]*int32
	vlanVid *int32
	vlanVidEmpty *int32
	vlanVidGt *int32
	vlanVidGte *int32
	vlanVidLt *int32
	vlanVidLte *int32
	vlanVidN *int32
	vrf *[]*string
	vrfN *[]*string
	vrfId *[]*int32
	vrfIdN *[]*int32
	within *string
	withinInclude *string
}

func (r ApiIpamPrefixesListRequest) Children(children []int32) ApiIpamPrefixesListRequest {
	r.children = &children
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenEmpty(childrenEmpty []int32) ApiIpamPrefixesListRequest {
	r.childrenEmpty = &childrenEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenGt(childrenGt []int32) ApiIpamPrefixesListRequest {
	r.childrenGt = &childrenGt
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenGte(childrenGte []int32) ApiIpamPrefixesListRequest {
	r.childrenGte = &childrenGte
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenLt(childrenLt []int32) ApiIpamPrefixesListRequest {
	r.childrenLt = &childrenLt
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenLte(childrenLte []int32) ApiIpamPrefixesListRequest {
	r.childrenLte = &childrenLte
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenN(childrenN []int32) ApiIpamPrefixesListRequest {
	r.childrenN = &childrenN
	return r
}

// Prefixes which contain this prefix or IP
func (r ApiIpamPrefixesListRequest) Contains(contains string) ApiIpamPrefixesListRequest {
	r.contains = &contains
	return r
}

func (r ApiIpamPrefixesListRequest) Created(created []time.Time) ApiIpamPrefixesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamPrefixesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedGt(createdGt []time.Time) ApiIpamPrefixesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedGte(createdGte []time.Time) ApiIpamPrefixesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedLt(createdLt []time.Time) ApiIpamPrefixesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedLte(createdLte []time.Time) ApiIpamPrefixesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedN(createdN []time.Time) ApiIpamPrefixesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedByRequest(createdByRequest string) ApiIpamPrefixesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamPrefixesListRequest) Depth(depth []int32) ApiIpamPrefixesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamPrefixesListRequest) DepthEmpty(depthEmpty []int32) ApiIpamPrefixesListRequest {
	r.depthEmpty = &depthEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) DepthGt(depthGt []int32) ApiIpamPrefixesListRequest {
	r.depthGt = &depthGt
	return r
}

func (r ApiIpamPrefixesListRequest) DepthGte(depthGte []int32) ApiIpamPrefixesListRequest {
	r.depthGte = &depthGte
	return r
}

func (r ApiIpamPrefixesListRequest) DepthLt(depthLt []int32) ApiIpamPrefixesListRequest {
	r.depthLt = &depthLt
	return r
}

func (r ApiIpamPrefixesListRequest) DepthLte(depthLte []int32) ApiIpamPrefixesListRequest {
	r.depthLte = &depthLte
	return r
}

func (r ApiIpamPrefixesListRequest) DepthN(depthN []int32) ApiIpamPrefixesListRequest {
	r.depthN = &depthN
	return r
}

func (r ApiIpamPrefixesListRequest) Description(description []string) ApiIpamPrefixesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamPrefixesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionIc(descriptionIc []string) ApiIpamPrefixesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionIe(descriptionIe []string) ApiIpamPrefixesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionIew(descriptionIew []string) ApiIpamPrefixesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamPrefixesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionN(descriptionN []string) ApiIpamPrefixesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionNic(descriptionNic []string) ApiIpamPrefixesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionNie(descriptionNie []string) ApiIpamPrefixesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamPrefixesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamPrefixesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamPrefixesListRequest) Family(family float32) ApiIpamPrefixesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamPrefixesListRequest) Id(id []int32) ApiIpamPrefixesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamPrefixesListRequest) IdEmpty(idEmpty bool) ApiIpamPrefixesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) IdGt(idGt []int32) ApiIpamPrefixesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamPrefixesListRequest) IdGte(idGte []int32) ApiIpamPrefixesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamPrefixesListRequest) IdLt(idLt []int32) ApiIpamPrefixesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamPrefixesListRequest) IdLte(idLte []int32) ApiIpamPrefixesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamPrefixesListRequest) IdN(idN []int32) ApiIpamPrefixesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamPrefixesListRequest) IsPool(isPool bool) ApiIpamPrefixesListRequest {
	r.isPool = &isPool
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixesListRequest) Limit(limit int32) ApiIpamPrefixesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamPrefixesListRequest) Location(location []string) ApiIpamPrefixesListRequest {
	r.location = &location
	return r
}

func (r ApiIpamPrefixesListRequest) LocationN(locationN []string) ApiIpamPrefixesListRequest {
	r.locationN = &locationN
	return r
}

func (r ApiIpamPrefixesListRequest) LocationId(locationId []string) ApiIpamPrefixesListRequest {
	r.locationId = &locationId
	return r
}

func (r ApiIpamPrefixesListRequest) LocationIdN(locationIdN []string) ApiIpamPrefixesListRequest {
	r.locationIdN = &locationIdN
	return r
}

func (r ApiIpamPrefixesListRequest) MarkUtilized(markUtilized bool) ApiIpamPrefixesListRequest {
	r.markUtilized = &markUtilized
	return r
}

func (r ApiIpamPrefixesListRequest) MaskLength(maskLength []int32) ApiIpamPrefixesListRequest {
	r.maskLength = &maskLength
	return r
}

func (r ApiIpamPrefixesListRequest) MaskLengthGte(maskLengthGte float32) ApiIpamPrefixesListRequest {
	r.maskLengthGte = &maskLengthGte
	return r
}

func (r ApiIpamPrefixesListRequest) MaskLengthLte(maskLengthLte float32) ApiIpamPrefixesListRequest {
	r.maskLengthLte = &maskLengthLte
	return r
}

func (r ApiIpamPrefixesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamPrefixesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesListRequest) Offset(offset int32) ApiIpamPrefixesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamPrefixesListRequest) Ordering(ordering string) ApiIpamPrefixesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamPrefixesListRequest) Prefix(prefix []string) ApiIpamPrefixesListRequest {
	r.prefix = &prefix
	return r
}

func (r ApiIpamPrefixesListRequest) PresentInVrf(presentInVrf string) ApiIpamPrefixesListRequest {
	r.presentInVrf = &presentInVrf
	return r
}

func (r ApiIpamPrefixesListRequest) PresentInVrfId(presentInVrfId string) ApiIpamPrefixesListRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

// Search
func (r ApiIpamPrefixesListRequest) Q(q string) ApiIpamPrefixesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamPrefixesListRequest) Region(region []string) ApiIpamPrefixesListRequest {
	r.region = &region
	return r
}

func (r ApiIpamPrefixesListRequest) RegionN(regionN []string) ApiIpamPrefixesListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiIpamPrefixesListRequest) RegionId(regionId []string) ApiIpamPrefixesListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiIpamPrefixesListRequest) RegionIdN(regionIdN []string) ApiIpamPrefixesListRequest {
	r.regionIdN = &regionIdN
	return r
}

// Role (slug)
func (r ApiIpamPrefixesListRequest) Role(role []string) ApiIpamPrefixesListRequest {
	r.role = &role
	return r
}

// Role (slug)
func (r ApiIpamPrefixesListRequest) RoleN(roleN []string) ApiIpamPrefixesListRequest {
	r.roleN = &roleN
	return r
}

// Role (ID)
func (r ApiIpamPrefixesListRequest) RoleId(roleId []*int32) ApiIpamPrefixesListRequest {
	r.roleId = &roleId
	return r
}

// Role (ID)
func (r ApiIpamPrefixesListRequest) RoleIdN(roleIdN []*int32) ApiIpamPrefixesListRequest {
	r.roleIdN = &roleIdN
	return r
}

func (r ApiIpamPrefixesListRequest) ScopeId(scopeId []int32) ApiIpamPrefixesListRequest {
	r.scopeId = &scopeId
	return r
}

func (r ApiIpamPrefixesListRequest) ScopeIdEmpty(scopeIdEmpty bool) ApiIpamPrefixesListRequest {
	r.scopeIdEmpty = &scopeIdEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) ScopeIdGt(scopeIdGt []int32) ApiIpamPrefixesListRequest {
	r.scopeIdGt = &scopeIdGt
	return r
}

func (r ApiIpamPrefixesListRequest) ScopeIdGte(scopeIdGte []int32) ApiIpamPrefixesListRequest {
	r.scopeIdGte = &scopeIdGte
	return r
}

func (r ApiIpamPrefixesListRequest) ScopeIdLt(scopeIdLt []int32) ApiIpamPrefixesListRequest {
	r.scopeIdLt = &scopeIdLt
	return r
}

func (r ApiIpamPrefixesListRequest) ScopeIdLte(scopeIdLte []int32) ApiIpamPrefixesListRequest {
	r.scopeIdLte = &scopeIdLte
	return r
}

func (r ApiIpamPrefixesListRequest) ScopeIdN(scopeIdN []int32) ApiIpamPrefixesListRequest {
	r.scopeIdN = &scopeIdN
	return r
}

func (r ApiIpamPrefixesListRequest) ScopeType(scopeType string) ApiIpamPrefixesListRequest {
	r.scopeType = &scopeType
	return r
}

func (r ApiIpamPrefixesListRequest) ScopeTypeN(scopeTypeN string) ApiIpamPrefixesListRequest {
	r.scopeTypeN = &scopeTypeN
	return r
}

// Site (slug)
func (r ApiIpamPrefixesListRequest) Site(site []string) ApiIpamPrefixesListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiIpamPrefixesListRequest) SiteN(siteN []string) ApiIpamPrefixesListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroup(siteGroup []string) ApiIpamPrefixesListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroupN(siteGroupN []string) ApiIpamPrefixesListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroupId(siteGroupId []string) ApiIpamPrefixesListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroupIdN(siteGroupIdN []string) ApiIpamPrefixesListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

// Site (ID)
func (r ApiIpamPrefixesListRequest) SiteId(siteId []int32) ApiIpamPrefixesListRequest {
	r.siteId = &siteId
	return r
}

// Site (ID)
func (r ApiIpamPrefixesListRequest) SiteIdN(siteIdN []int32) ApiIpamPrefixesListRequest {
	r.siteIdN = &siteIdN
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) Status(status []string) ApiIpamPrefixesListRequest {
	r.status = &status
	return r
}

func (r ApiIpamPrefixesListRequest) StatusEmpty(statusEmpty bool) ApiIpamPrefixesListRequest {
	r.statusEmpty = &statusEmpty
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) StatusIc(statusIc []string) ApiIpamPrefixesListRequest {
	r.statusIc = &statusIc
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) StatusIe(statusIe []string) ApiIpamPrefixesListRequest {
	r.statusIe = &statusIe
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) StatusIew(statusIew []string) ApiIpamPrefixesListRequest {
	r.statusIew = &statusIew
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) StatusIsw(statusIsw []string) ApiIpamPrefixesListRequest {
	r.statusIsw = &statusIsw
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) StatusN(statusN []string) ApiIpamPrefixesListRequest {
	r.statusN = &statusN
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) StatusNic(statusNic []string) ApiIpamPrefixesListRequest {
	r.statusNic = &statusNic
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) StatusNie(statusNie []string) ApiIpamPrefixesListRequest {
	r.statusNie = &statusNie
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) StatusNiew(statusNiew []string) ApiIpamPrefixesListRequest {
	r.statusNiew = &statusNiew
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) StatusNisw(statusNisw []string) ApiIpamPrefixesListRequest {
	r.statusNisw = &statusNisw
	return r
}

func (r ApiIpamPrefixesListRequest) Tag(tag []string) ApiIpamPrefixesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamPrefixesListRequest) TagN(tagN []string) ApiIpamPrefixesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamPrefixesListRequest) Tenant(tenant []string) ApiIpamPrefixesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamPrefixesListRequest) TenantN(tenantN []string) ApiIpamPrefixesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroup(tenantGroup []string) ApiIpamPrefixesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamPrefixesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamPrefixesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamPrefixesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamPrefixesListRequest) TenantId(tenantId []*int32) ApiIpamPrefixesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamPrefixesListRequest) TenantIdN(tenantIdN []*int32) ApiIpamPrefixesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamPrefixesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamPrefixesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

// VLAN (ID)
func (r ApiIpamPrefixesListRequest) VlanId(vlanId []*int32) ApiIpamPrefixesListRequest {
	r.vlanId = &vlanId
	return r
}

// VLAN (ID)
func (r ApiIpamPrefixesListRequest) VlanIdN(vlanIdN []*int32) ApiIpamPrefixesListRequest {
	r.vlanIdN = &vlanIdN
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVid(vlanVid int32) ApiIpamPrefixesListRequest {
	r.vlanVid = &vlanVid
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidEmpty(vlanVidEmpty int32) ApiIpamPrefixesListRequest {
	r.vlanVidEmpty = &vlanVidEmpty
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidGt(vlanVidGt int32) ApiIpamPrefixesListRequest {
	r.vlanVidGt = &vlanVidGt
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidGte(vlanVidGte int32) ApiIpamPrefixesListRequest {
	r.vlanVidGte = &vlanVidGte
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidLt(vlanVidLt int32) ApiIpamPrefixesListRequest {
	r.vlanVidLt = &vlanVidLt
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidLte(vlanVidLte int32) ApiIpamPrefixesListRequest {
	r.vlanVidLte = &vlanVidLte
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidN(vlanVidN int32) ApiIpamPrefixesListRequest {
	r.vlanVidN = &vlanVidN
	return r
}

// VRF (RD)
func (r ApiIpamPrefixesListRequest) Vrf(vrf []*string) ApiIpamPrefixesListRequest {
	r.vrf = &vrf
	return r
}

// VRF (RD)
func (r ApiIpamPrefixesListRequest) VrfN(vrfN []*string) ApiIpamPrefixesListRequest {
	r.vrfN = &vrfN
	return r
}

// VRF
func (r ApiIpamPrefixesListRequest) VrfId(vrfId []*int32) ApiIpamPrefixesListRequest {
	r.vrfId = &vrfId
	return r
}

// VRF
func (r ApiIpamPrefixesListRequest) VrfIdN(vrfIdN []*int32) ApiIpamPrefixesListRequest {
	r.vrfIdN = &vrfIdN
	return r
}

// Within prefix
func (r ApiIpamPrefixesListRequest) Within(within string) ApiIpamPrefixesListRequest {
	r.within = &within
	return r
}

// Within and including prefix
func (r ApiIpamPrefixesListRequest) WithinInclude(withinInclude string) ApiIpamPrefixesListRequest {
	r.withinInclude = &withinInclude
	return r
}

func (r ApiIpamPrefixesListRequest) Execute() (*PaginatedPrefixList, *http.Response, error) {
	return r.ApiService.IpamPrefixesListExecute(r)
}

/*
IpamPrefixesList Method for IpamPrefixesList

Get a list of prefix objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesListRequest
*/
func (a *IpamAPIService) IpamPrefixesList(ctx context.Context) ApiIpamPrefixesListRequest {
	return ApiIpamPrefixesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPrefixList
func (a *IpamAPIService) IpamPrefixesListExecute(r ApiIpamPrefixesListRequest) (*PaginatedPrefixList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPrefixList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.children != nil {
		t := *r.children
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children", t, "form", "multi")
		}
	}
	if r.childrenEmpty != nil {
		t := *r.childrenEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__empty", t, "form", "multi")
		}
	}
	if r.childrenGt != nil {
		t := *r.childrenGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__gt", t, "form", "multi")
		}
	}
	if r.childrenGte != nil {
		t := *r.childrenGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__gte", t, "form", "multi")
		}
	}
	if r.childrenLt != nil {
		t := *r.childrenLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__lt", t, "form", "multi")
		}
	}
	if r.childrenLte != nil {
		t := *r.childrenLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__lte", t, "form", "multi")
		}
	}
	if r.childrenN != nil {
		t := *r.childrenN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__n", t, "form", "multi")
		}
	}
	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.depth != nil {
		t := *r.depth
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth", t, "form", "multi")
		}
	}
	if r.depthEmpty != nil {
		t := *r.depthEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__empty", t, "form", "multi")
		}
	}
	if r.depthGt != nil {
		t := *r.depthGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__gt", t, "form", "multi")
		}
	}
	if r.depthGte != nil {
		t := *r.depthGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__gte", t, "form", "multi")
		}
	}
	if r.depthLt != nil {
		t := *r.depthLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__lt", t, "form", "multi")
		}
	}
	if r.depthLte != nil {
		t := *r.depthLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__lte", t, "form", "multi")
		}
	}
	if r.depthN != nil {
		t := *r.depthN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__n", t, "form", "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.family != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "family", r.family, "form", "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.isPool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_pool", r.isPool, "form", "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location", t, "form", "multi")
		}
	}
	if r.locationN != nil {
		t := *r.locationN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location__n", t, "form", "multi")
		}
	}
	if r.locationId != nil {
		t := *r.locationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location_id", t, "form", "multi")
		}
	}
	if r.locationIdN != nil {
		t := *r.locationIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "location_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "location_id__n", t, "form", "multi")
		}
	}
	if r.markUtilized != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mark_utilized", r.markUtilized, "form", "")
	}
	if r.maskLength != nil {
		t := *r.maskLength
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length", t, "form", "multi")
		}
	}
	if r.maskLengthGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__gte", r.maskLengthGte, "form", "")
	}
	if r.maskLengthLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__lte", r.maskLengthLte, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.prefix != nil {
		t := *r.prefix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", t, "form", "multi")
		}
	}
	if r.presentInVrf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf", r.presentInVrf, "form", "")
	}
	if r.presentInVrfId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf_id", r.presentInVrfId, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.region != nil {
		t := *r.region
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region", t, "form", "multi")
		}
	}
	if r.regionN != nil {
		t := *r.regionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region__n", t, "form", "multi")
		}
	}
	if r.regionId != nil {
		t := *r.regionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region_id", t, "form", "multi")
		}
	}
	if r.regionIdN != nil {
		t := *r.regionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region_id__n", t, "form", "multi")
		}
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "form", "multi")
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "form", "multi")
		}
	}
	if r.roleId != nil {
		t := *r.roleId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", t, "form", "multi")
		}
	}
	if r.roleIdN != nil {
		t := *r.roleIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", t, "form", "multi")
		}
	}
	if r.scopeId != nil {
		t := *r.scopeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id", t, "form", "multi")
		}
	}
	if r.scopeIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__empty", r.scopeIdEmpty, "form", "")
	}
	if r.scopeIdGt != nil {
		t := *r.scopeIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gt", t, "form", "multi")
		}
	}
	if r.scopeIdGte != nil {
		t := *r.scopeIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gte", t, "form", "multi")
		}
	}
	if r.scopeIdLt != nil {
		t := *r.scopeIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lt", t, "form", "multi")
		}
	}
	if r.scopeIdLte != nil {
		t := *r.scopeIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lte", t, "form", "multi")
		}
	}
	if r.scopeIdN != nil {
		t := *r.scopeIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__n", t, "form", "multi")
		}
	}
	if r.scopeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope_type", r.scopeType, "form", "")
	}
	if r.scopeTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope_type__n", r.scopeTypeN, "form", "")
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site", t, "form", "multi")
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", t, "form", "multi")
		}
	}
	if r.siteGroup != nil {
		t := *r.siteGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group", t, "form", "multi")
		}
	}
	if r.siteGroupN != nil {
		t := *r.siteGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group__n", t, "form", "multi")
		}
	}
	if r.siteGroupId != nil {
		t := *r.siteGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id", t, "form", "multi")
		}
	}
	if r.siteGroupIdN != nil {
		t := *r.siteGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id__n", t, "form", "multi")
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", t, "form", "multi")
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", t, "form", "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.statusEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__empty", r.statusEmpty, "form", "")
	}
	if r.statusIc != nil {
		t := *r.statusIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__ic", t, "form", "multi")
		}
	}
	if r.statusIe != nil {
		t := *r.statusIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__ie", t, "form", "multi")
		}
	}
	if r.statusIew != nil {
		t := *r.statusIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__iew", t, "form", "multi")
		}
	}
	if r.statusIsw != nil {
		t := *r.statusIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__isw", t, "form", "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "form", "multi")
		}
	}
	if r.statusNic != nil {
		t := *r.statusNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nic", t, "form", "multi")
		}
	}
	if r.statusNie != nil {
		t := *r.statusNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nie", t, "form", "multi")
		}
	}
	if r.statusNiew != nil {
		t := *r.statusNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__niew", t, "form", "multi")
		}
	}
	if r.statusNisw != nil {
		t := *r.statusNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "form", "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	if r.vlanId != nil {
		t := *r.vlanId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id", t, "form", "multi")
		}
	}
	if r.vlanIdN != nil {
		t := *r.vlanIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id__n", t, "form", "multi")
		}
	}
	if r.vlanVid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid", r.vlanVid, "form", "")
	}
	if r.vlanVidEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__empty", r.vlanVidEmpty, "form", "")
	}
	if r.vlanVidGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__gt", r.vlanVidGt, "form", "")
	}
	if r.vlanVidGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__gte", r.vlanVidGte, "form", "")
	}
	if r.vlanVidLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__lt", r.vlanVidLt, "form", "")
	}
	if r.vlanVidLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__lte", r.vlanVidLte, "form", "")
	}
	if r.vlanVidN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__n", r.vlanVidN, "form", "")
	}
	if r.vrf != nil {
		t := *r.vrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", t, "form", "multi")
		}
	}
	if r.vrfN != nil {
		t := *r.vrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", t, "form", "multi")
		}
	}
	if r.vrfId != nil {
		t := *r.vrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", t, "form", "multi")
		}
	}
	if r.vrfIdN != nil {
		t := *r.vrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", t, "form", "multi")
		}
	}
	if r.within != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "within", r.within, "form", "")
	}
	if r.withinInclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "within_include", r.withinInclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedWritablePrefixRequest *PatchedWritablePrefixRequest
}

func (r ApiIpamPrefixesPartialUpdateRequest) PatchedWritablePrefixRequest(patchedWritablePrefixRequest PatchedWritablePrefixRequest) ApiIpamPrefixesPartialUpdateRequest {
	r.patchedWritablePrefixRequest = &patchedWritablePrefixRequest
	return r
}

func (r ApiIpamPrefixesPartialUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesPartialUpdateExecute(r)
}

/*
IpamPrefixesPartialUpdate Method for IpamPrefixesPartialUpdate

Patch a prefix object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesPartialUpdate(ctx context.Context, id int32) ApiIpamPrefixesPartialUpdateRequest {
	return ApiIpamPrefixesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamAPIService) IpamPrefixesPartialUpdateExecute(r ApiIpamPrefixesPartialUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritablePrefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamPrefixesRetrieveRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesRetrieveExecute(r)
}

/*
IpamPrefixesRetrieve Method for IpamPrefixesRetrieve

Get a prefix object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesRetrieveRequest
*/
func (a *IpamAPIService) IpamPrefixesRetrieve(ctx context.Context, id int32) ApiIpamPrefixesRetrieveRequest {
	return ApiIpamPrefixesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamAPIService) IpamPrefixesRetrieveExecute(r ApiIpamPrefixesRetrieveRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	writablePrefixRequest *WritablePrefixRequest
}

func (r ApiIpamPrefixesUpdateRequest) WritablePrefixRequest(writablePrefixRequest WritablePrefixRequest) ApiIpamPrefixesUpdateRequest {
	r.writablePrefixRequest = &writablePrefixRequest
	return r
}

func (r ApiIpamPrefixesUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesUpdateExecute(r)
}

/*
IpamPrefixesUpdate Method for IpamPrefixesUpdate

Put a prefix object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this prefix.
 @return ApiIpamPrefixesUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesUpdate(ctx context.Context, id int32) ApiIpamPrefixesUpdateRequest {
	return ApiIpamPrefixesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamAPIService) IpamPrefixesUpdateExecute(r ApiIpamPrefixesUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePrefixRequest == nil {
		return localVarReturnValue, nil, reportError("writablePrefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePrefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	rIRRequest *[]RIRRequest
}

func (r ApiIpamRirsBulkDestroyRequest) RIRRequest(rIRRequest []RIRRequest) ApiIpamRirsBulkDestroyRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRirsBulkDestroyExecute(r)
}

/*
IpamRirsBulkDestroy Method for IpamRirsBulkDestroy

Delete a list of RIR objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamRirsBulkDestroy(ctx context.Context) ApiIpamRirsBulkDestroyRequest {
	return ApiIpamRirsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRirsBulkDestroyExecute(r ApiIpamRirsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return nil, reportError("rIRRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRirsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	rIRRequest *[]RIRRequest
}

func (r ApiIpamRirsBulkPartialUpdateRequest) RIRRequest(rIRRequest []RIRRequest) ApiIpamRirsBulkPartialUpdateRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsBulkPartialUpdateRequest) Execute() ([]RIR, *http.Response, error) {
	return r.ApiService.IpamRirsBulkPartialUpdateExecute(r)
}

/*
IpamRirsBulkPartialUpdate Method for IpamRirsBulkPartialUpdate

Patch a list of RIR objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRirsBulkPartialUpdate(ctx context.Context) ApiIpamRirsBulkPartialUpdateRequest {
	return ApiIpamRirsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RIR
func (a *IpamAPIService) IpamRirsBulkPartialUpdateExecute(r ApiIpamRirsBulkPartialUpdateRequest) ([]RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return localVarReturnValue, nil, reportError("rIRRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	rIRRequest *[]RIRRequest
}

func (r ApiIpamRirsBulkUpdateRequest) RIRRequest(rIRRequest []RIRRequest) ApiIpamRirsBulkUpdateRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsBulkUpdateRequest) Execute() ([]RIR, *http.Response, error) {
	return r.ApiService.IpamRirsBulkUpdateExecute(r)
}

/*
IpamRirsBulkUpdate Method for IpamRirsBulkUpdate

Put a list of RIR objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamRirsBulkUpdate(ctx context.Context) ApiIpamRirsBulkUpdateRequest {
	return ApiIpamRirsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RIR
func (a *IpamAPIService) IpamRirsBulkUpdateExecute(r ApiIpamRirsBulkUpdateRequest) ([]RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return localVarReturnValue, nil, reportError("rIRRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	rIRRequest *RIRRequest
}

func (r ApiIpamRirsCreateRequest) RIRRequest(rIRRequest RIRRequest) ApiIpamRirsCreateRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsCreateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsCreateExecute(r)
}

/*
IpamRirsCreate Method for IpamRirsCreate

Post a list of RIR objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsCreateRequest
*/
func (a *IpamAPIService) IpamRirsCreate(ctx context.Context) ApiIpamRirsCreateRequest {
	return ApiIpamRirsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamAPIService) IpamRirsCreateExecute(r ApiIpamRirsCreateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return localVarReturnValue, nil, reportError("rIRRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamRirsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRirsDestroyExecute(r)
}

/*
IpamRirsDestroy Method for IpamRirsDestroy

Delete a RIR object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this RIR.
 @return ApiIpamRirsDestroyRequest
*/
func (a *IpamAPIService) IpamRirsDestroy(ctx context.Context, id int32) ApiIpamRirsDestroyRequest {
	return ApiIpamRirsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRirsDestroyExecute(r ApiIpamRirsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRirsListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	isPrivate *bool
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	slug *[]string
	slugEmpty *bool
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNisw *[]string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiIpamRirsListRequest) Created(created []time.Time) ApiIpamRirsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRirsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamRirsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamRirsListRequest) CreatedGt(createdGt []time.Time) ApiIpamRirsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamRirsListRequest) CreatedGte(createdGte []time.Time) ApiIpamRirsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRirsListRequest) CreatedLt(createdLt []time.Time) ApiIpamRirsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamRirsListRequest) CreatedLte(createdLte []time.Time) ApiIpamRirsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRirsListRequest) CreatedN(createdN []time.Time) ApiIpamRirsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamRirsListRequest) CreatedByRequest(createdByRequest string) ApiIpamRirsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamRirsListRequest) Description(description []string) ApiIpamRirsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamRirsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamRirsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIc(descriptionIc []string) ApiIpamRirsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIe(descriptionIe []string) ApiIpamRirsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIew(descriptionIew []string) ApiIpamRirsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamRirsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamRirsListRequest) DescriptionN(descriptionN []string) ApiIpamRirsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNic(descriptionNic []string) ApiIpamRirsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNie(descriptionNie []string) ApiIpamRirsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamRirsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamRirsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamRirsListRequest) Id(id []int32) ApiIpamRirsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRirsListRequest) IdEmpty(idEmpty bool) ApiIpamRirsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamRirsListRequest) IdGt(idGt []int32) ApiIpamRirsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamRirsListRequest) IdGte(idGte []int32) ApiIpamRirsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamRirsListRequest) IdLt(idLt []int32) ApiIpamRirsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamRirsListRequest) IdLte(idLte []int32) ApiIpamRirsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamRirsListRequest) IdN(idN []int32) ApiIpamRirsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRirsListRequest) IsPrivate(isPrivate bool) ApiIpamRirsListRequest {
	r.isPrivate = &isPrivate
	return r
}

func (r ApiIpamRirsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamRirsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamRirsListRequest) Limit(limit int32) ApiIpamRirsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamRirsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamRirsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamRirsListRequest) Name(name []string) ApiIpamRirsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRirsListRequest) NameEmpty(nameEmpty bool) ApiIpamRirsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamRirsListRequest) NameIc(nameIc []string) ApiIpamRirsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRirsListRequest) NameIe(nameIe []string) ApiIpamRirsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRirsListRequest) NameIew(nameIew []string) ApiIpamRirsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRirsListRequest) NameIsw(nameIsw []string) ApiIpamRirsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRirsListRequest) NameN(nameN []string) ApiIpamRirsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRirsListRequest) NameNic(nameNic []string) ApiIpamRirsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRirsListRequest) NameNie(nameNie []string) ApiIpamRirsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRirsListRequest) NameNiew(nameNiew []string) ApiIpamRirsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRirsListRequest) NameNisw(nameNisw []string) ApiIpamRirsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRirsListRequest) Offset(offset int32) ApiIpamRirsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamRirsListRequest) Ordering(ordering string) ApiIpamRirsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamRirsListRequest) Q(q string) ApiIpamRirsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRirsListRequest) Slug(slug []string) ApiIpamRirsListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamRirsListRequest) SlugEmpty(slugEmpty bool) ApiIpamRirsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiIpamRirsListRequest) SlugIc(slugIc []string) ApiIpamRirsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamRirsListRequest) SlugIe(slugIe []string) ApiIpamRirsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamRirsListRequest) SlugIew(slugIew []string) ApiIpamRirsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamRirsListRequest) SlugIsw(slugIsw []string) ApiIpamRirsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamRirsListRequest) SlugN(slugN []string) ApiIpamRirsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamRirsListRequest) SlugNic(slugNic []string) ApiIpamRirsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamRirsListRequest) SlugNie(slugNie []string) ApiIpamRirsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamRirsListRequest) SlugNiew(slugNiew []string) ApiIpamRirsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamRirsListRequest) SlugNisw(slugNisw []string) ApiIpamRirsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamRirsListRequest) Tag(tag []string) ApiIpamRirsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamRirsListRequest) TagN(tagN []string) ApiIpamRirsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamRirsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamRirsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamRirsListRequest) Execute() (*PaginatedRIRList, *http.Response, error) {
	return r.ApiService.IpamRirsListExecute(r)
}

/*
IpamRirsList Method for IpamRirsList

Get a list of RIR objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsListRequest
*/
func (a *IpamAPIService) IpamRirsList(ctx context.Context) ApiIpamRirsListRequest {
	return ApiIpamRirsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRIRList
func (a *IpamAPIService) IpamRirsListExecute(r ApiIpamRirsListRequest) (*PaginatedRIRList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRIRList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.isPrivate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_private", r.isPrivate, "form", "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug", t, "form", "multi")
		}
	}
	if r.slugEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slug__empty", r.slugEmpty, "form", "")
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", t, "form", "multi")
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", t, "form", "multi")
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", t, "form", "multi")
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", t, "form", "multi")
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", t, "form", "multi")
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", t, "form", "multi")
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", t, "form", "multi")
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", t, "form", "multi")
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedRIRRequest *PatchedRIRRequest
}

func (r ApiIpamRirsPartialUpdateRequest) PatchedRIRRequest(patchedRIRRequest PatchedRIRRequest) ApiIpamRirsPartialUpdateRequest {
	r.patchedRIRRequest = &patchedRIRRequest
	return r
}

func (r ApiIpamRirsPartialUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsPartialUpdateExecute(r)
}

/*
IpamRirsPartialUpdate Method for IpamRirsPartialUpdate

Patch a RIR object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this RIR.
 @return ApiIpamRirsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRirsPartialUpdate(ctx context.Context, id int32) ApiIpamRirsPartialUpdateRequest {
	return ApiIpamRirsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamAPIService) IpamRirsPartialUpdateExecute(r ApiIpamRirsPartialUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamRirsRetrieveRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsRetrieveExecute(r)
}

/*
IpamRirsRetrieve Method for IpamRirsRetrieve

Get a RIR object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this RIR.
 @return ApiIpamRirsRetrieveRequest
*/
func (a *IpamAPIService) IpamRirsRetrieve(ctx context.Context, id int32) ApiIpamRirsRetrieveRequest {
	return ApiIpamRirsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamAPIService) IpamRirsRetrieveExecute(r ApiIpamRirsRetrieveRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	rIRRequest *RIRRequest
}

func (r ApiIpamRirsUpdateRequest) RIRRequest(rIRRequest RIRRequest) ApiIpamRirsUpdateRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsUpdateExecute(r)
}

/*
IpamRirsUpdate Method for IpamRirsUpdate

Put a RIR object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this RIR.
 @return ApiIpamRirsUpdateRequest
*/
func (a *IpamAPIService) IpamRirsUpdate(ctx context.Context, id int32) ApiIpamRirsUpdateRequest {
	return ApiIpamRirsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamAPIService) IpamRirsUpdateExecute(r ApiIpamRirsUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return localVarReturnValue, nil, reportError("rIRRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	roleRequest *[]RoleRequest
}

func (r ApiIpamRolesBulkDestroyRequest) RoleRequest(roleRequest []RoleRequest) ApiIpamRolesBulkDestroyRequest {
	r.roleRequest = &roleRequest
	return r
}

func (r ApiIpamRolesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRolesBulkDestroyExecute(r)
}

/*
IpamRolesBulkDestroy Method for IpamRolesBulkDestroy

Delete a list of role objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamRolesBulkDestroy(ctx context.Context) ApiIpamRolesBulkDestroyRequest {
	return ApiIpamRolesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRolesBulkDestroyExecute(r ApiIpamRolesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleRequest == nil {
		return nil, reportError("roleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRolesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	roleRequest *[]RoleRequest
}

func (r ApiIpamRolesBulkPartialUpdateRequest) RoleRequest(roleRequest []RoleRequest) ApiIpamRolesBulkPartialUpdateRequest {
	r.roleRequest = &roleRequest
	return r
}

func (r ApiIpamRolesBulkPartialUpdateRequest) Execute() ([]Role, *http.Response, error) {
	return r.ApiService.IpamRolesBulkPartialUpdateExecute(r)
}

/*
IpamRolesBulkPartialUpdate Method for IpamRolesBulkPartialUpdate

Patch a list of role objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRolesBulkPartialUpdate(ctx context.Context) ApiIpamRolesBulkPartialUpdateRequest {
	return ApiIpamRolesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Role
func (a *IpamAPIService) IpamRolesBulkPartialUpdateExecute(r ApiIpamRolesBulkPartialUpdateRequest) ([]Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleRequest == nil {
		return localVarReturnValue, nil, reportError("roleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	roleRequest *[]RoleRequest
}

func (r ApiIpamRolesBulkUpdateRequest) RoleRequest(roleRequest []RoleRequest) ApiIpamRolesBulkUpdateRequest {
	r.roleRequest = &roleRequest
	return r
}

func (r ApiIpamRolesBulkUpdateRequest) Execute() ([]Role, *http.Response, error) {
	return r.ApiService.IpamRolesBulkUpdateExecute(r)
}

/*
IpamRolesBulkUpdate Method for IpamRolesBulkUpdate

Put a list of role objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamRolesBulkUpdate(ctx context.Context) ApiIpamRolesBulkUpdateRequest {
	return ApiIpamRolesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Role
func (a *IpamAPIService) IpamRolesBulkUpdateExecute(r ApiIpamRolesBulkUpdateRequest) ([]Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleRequest == nil {
		return localVarReturnValue, nil, reportError("roleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	roleRequest *RoleRequest
}

func (r ApiIpamRolesCreateRequest) RoleRequest(roleRequest RoleRequest) ApiIpamRolesCreateRequest {
	r.roleRequest = &roleRequest
	return r
}

func (r ApiIpamRolesCreateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesCreateExecute(r)
}

/*
IpamRolesCreate Method for IpamRolesCreate

Post a list of role objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesCreateRequest
*/
func (a *IpamAPIService) IpamRolesCreate(ctx context.Context) ApiIpamRolesCreateRequest {
	return ApiIpamRolesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamAPIService) IpamRolesCreateExecute(r ApiIpamRolesCreateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleRequest == nil {
		return localVarReturnValue, nil, reportError("roleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamRolesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRolesDestroyExecute(r)
}

/*
IpamRolesDestroy Method for IpamRolesDestroy

Delete a role object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this role.
 @return ApiIpamRolesDestroyRequest
*/
func (a *IpamAPIService) IpamRolesDestroy(ctx context.Context, id int32) ApiIpamRolesDestroyRequest {
	return ApiIpamRolesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRolesDestroyExecute(r ApiIpamRolesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRolesListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	slug *[]string
	slugEmpty *bool
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNisw *[]string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
	weight *[]int32
	weightEmpty *bool
	weightGt *[]int32
	weightGte *[]int32
	weightLt *[]int32
	weightLte *[]int32
	weightN *[]int32
}

func (r ApiIpamRolesListRequest) Created(created []time.Time) ApiIpamRolesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRolesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamRolesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamRolesListRequest) CreatedGt(createdGt []time.Time) ApiIpamRolesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamRolesListRequest) CreatedGte(createdGte []time.Time) ApiIpamRolesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRolesListRequest) CreatedLt(createdLt []time.Time) ApiIpamRolesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamRolesListRequest) CreatedLte(createdLte []time.Time) ApiIpamRolesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRolesListRequest) CreatedN(createdN []time.Time) ApiIpamRolesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamRolesListRequest) CreatedByRequest(createdByRequest string) ApiIpamRolesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamRolesListRequest) Description(description []string) ApiIpamRolesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamRolesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamRolesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamRolesListRequest) DescriptionIc(descriptionIc []string) ApiIpamRolesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamRolesListRequest) DescriptionIe(descriptionIe []string) ApiIpamRolesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamRolesListRequest) DescriptionIew(descriptionIew []string) ApiIpamRolesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamRolesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamRolesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamRolesListRequest) DescriptionN(descriptionN []string) ApiIpamRolesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamRolesListRequest) DescriptionNic(descriptionNic []string) ApiIpamRolesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamRolesListRequest) DescriptionNie(descriptionNie []string) ApiIpamRolesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamRolesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamRolesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamRolesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamRolesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamRolesListRequest) Id(id []int32) ApiIpamRolesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRolesListRequest) IdEmpty(idEmpty bool) ApiIpamRolesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamRolesListRequest) IdGt(idGt []int32) ApiIpamRolesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamRolesListRequest) IdGte(idGte []int32) ApiIpamRolesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamRolesListRequest) IdLt(idLt []int32) ApiIpamRolesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamRolesListRequest) IdLte(idLte []int32) ApiIpamRolesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamRolesListRequest) IdN(idN []int32) ApiIpamRolesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRolesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamRolesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamRolesListRequest) Limit(limit int32) ApiIpamRolesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamRolesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamRolesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamRolesListRequest) Name(name []string) ApiIpamRolesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRolesListRequest) NameEmpty(nameEmpty bool) ApiIpamRolesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamRolesListRequest) NameIc(nameIc []string) ApiIpamRolesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRolesListRequest) NameIe(nameIe []string) ApiIpamRolesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRolesListRequest) NameIew(nameIew []string) ApiIpamRolesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRolesListRequest) NameIsw(nameIsw []string) ApiIpamRolesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRolesListRequest) NameN(nameN []string) ApiIpamRolesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRolesListRequest) NameNic(nameNic []string) ApiIpamRolesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRolesListRequest) NameNie(nameNie []string) ApiIpamRolesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRolesListRequest) NameNiew(nameNiew []string) ApiIpamRolesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRolesListRequest) NameNisw(nameNisw []string) ApiIpamRolesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRolesListRequest) Offset(offset int32) ApiIpamRolesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamRolesListRequest) Ordering(ordering string) ApiIpamRolesListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamRolesListRequest) Q(q string) ApiIpamRolesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRolesListRequest) Slug(slug []string) ApiIpamRolesListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamRolesListRequest) SlugEmpty(slugEmpty bool) ApiIpamRolesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiIpamRolesListRequest) SlugIc(slugIc []string) ApiIpamRolesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamRolesListRequest) SlugIe(slugIe []string) ApiIpamRolesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamRolesListRequest) SlugIew(slugIew []string) ApiIpamRolesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamRolesListRequest) SlugIsw(slugIsw []string) ApiIpamRolesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamRolesListRequest) SlugN(slugN []string) ApiIpamRolesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamRolesListRequest) SlugNic(slugNic []string) ApiIpamRolesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamRolesListRequest) SlugNie(slugNie []string) ApiIpamRolesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamRolesListRequest) SlugNiew(slugNiew []string) ApiIpamRolesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamRolesListRequest) SlugNisw(slugNisw []string) ApiIpamRolesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamRolesListRequest) Tag(tag []string) ApiIpamRolesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamRolesListRequest) TagN(tagN []string) ApiIpamRolesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamRolesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamRolesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamRolesListRequest) Weight(weight []int32) ApiIpamRolesListRequest {
	r.weight = &weight
	return r
}

func (r ApiIpamRolesListRequest) WeightEmpty(weightEmpty bool) ApiIpamRolesListRequest {
	r.weightEmpty = &weightEmpty
	return r
}

func (r ApiIpamRolesListRequest) WeightGt(weightGt []int32) ApiIpamRolesListRequest {
	r.weightGt = &weightGt
	return r
}

func (r ApiIpamRolesListRequest) WeightGte(weightGte []int32) ApiIpamRolesListRequest {
	r.weightGte = &weightGte
	return r
}

func (r ApiIpamRolesListRequest) WeightLt(weightLt []int32) ApiIpamRolesListRequest {
	r.weightLt = &weightLt
	return r
}

func (r ApiIpamRolesListRequest) WeightLte(weightLte []int32) ApiIpamRolesListRequest {
	r.weightLte = &weightLte
	return r
}

func (r ApiIpamRolesListRequest) WeightN(weightN []int32) ApiIpamRolesListRequest {
	r.weightN = &weightN
	return r
}

func (r ApiIpamRolesListRequest) Execute() (*PaginatedRoleList, *http.Response, error) {
	return r.ApiService.IpamRolesListExecute(r)
}

/*
IpamRolesList Method for IpamRolesList

Get a list of role objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesListRequest
*/
func (a *IpamAPIService) IpamRolesList(ctx context.Context) ApiIpamRolesListRequest {
	return ApiIpamRolesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRoleList
func (a *IpamAPIService) IpamRolesListExecute(r ApiIpamRolesListRequest) (*PaginatedRoleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRoleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug", t, "form", "multi")
		}
	}
	if r.slugEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slug__empty", r.slugEmpty, "form", "")
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", t, "form", "multi")
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", t, "form", "multi")
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", t, "form", "multi")
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", t, "form", "multi")
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", t, "form", "multi")
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", t, "form", "multi")
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", t, "form", "multi")
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", t, "form", "multi")
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	if r.weight != nil {
		t := *r.weight
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight", t, "form", "multi")
		}
	}
	if r.weightEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "weight__empty", r.weightEmpty, "form", "")
	}
	if r.weightGt != nil {
		t := *r.weightGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gt", t, "form", "multi")
		}
	}
	if r.weightGte != nil {
		t := *r.weightGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gte", t, "form", "multi")
		}
	}
	if r.weightLt != nil {
		t := *r.weightLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lt", t, "form", "multi")
		}
	}
	if r.weightLte != nil {
		t := *r.weightLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lte", t, "form", "multi")
		}
	}
	if r.weightN != nil {
		t := *r.weightN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__n", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedRoleRequest *PatchedRoleRequest
}

func (r ApiIpamRolesPartialUpdateRequest) PatchedRoleRequest(patchedRoleRequest PatchedRoleRequest) ApiIpamRolesPartialUpdateRequest {
	r.patchedRoleRequest = &patchedRoleRequest
	return r
}

func (r ApiIpamRolesPartialUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesPartialUpdateExecute(r)
}

/*
IpamRolesPartialUpdate Method for IpamRolesPartialUpdate

Patch a role object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this role.
 @return ApiIpamRolesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRolesPartialUpdate(ctx context.Context, id int32) ApiIpamRolesPartialUpdateRequest {
	return ApiIpamRolesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamAPIService) IpamRolesPartialUpdateExecute(r ApiIpamRolesPartialUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRoleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamRolesRetrieveRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesRetrieveExecute(r)
}

/*
IpamRolesRetrieve Method for IpamRolesRetrieve

Get a role object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this role.
 @return ApiIpamRolesRetrieveRequest
*/
func (a *IpamAPIService) IpamRolesRetrieve(ctx context.Context, id int32) ApiIpamRolesRetrieveRequest {
	return ApiIpamRolesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamAPIService) IpamRolesRetrieveExecute(r ApiIpamRolesRetrieveRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	roleRequest *RoleRequest
}

func (r ApiIpamRolesUpdateRequest) RoleRequest(roleRequest RoleRequest) ApiIpamRolesUpdateRequest {
	r.roleRequest = &roleRequest
	return r
}

func (r ApiIpamRolesUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesUpdateExecute(r)
}

/*
IpamRolesUpdate Method for IpamRolesUpdate

Put a role object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this role.
 @return ApiIpamRolesUpdateRequest
*/
func (a *IpamAPIService) IpamRolesUpdate(ctx context.Context, id int32) ApiIpamRolesUpdateRequest {
	return ApiIpamRolesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamAPIService) IpamRolesUpdateExecute(r ApiIpamRolesUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleRequest == nil {
		return localVarReturnValue, nil, reportError("roleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	routeTargetRequest *[]RouteTargetRequest
}

func (r ApiIpamRouteTargetsBulkDestroyRequest) RouteTargetRequest(routeTargetRequest []RouteTargetRequest) ApiIpamRouteTargetsBulkDestroyRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkDestroyExecute(r)
}

/*
IpamRouteTargetsBulkDestroy Method for IpamRouteTargetsBulkDestroy

Delete a list of route target objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamRouteTargetsBulkDestroy(ctx context.Context) ApiIpamRouteTargetsBulkDestroyRequest {
	return ApiIpamRouteTargetsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRouteTargetsBulkDestroyExecute(r ApiIpamRouteTargetsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return nil, reportError("routeTargetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	routeTargetRequest *[]RouteTargetRequest
}

func (r ApiIpamRouteTargetsBulkPartialUpdateRequest) RouteTargetRequest(routeTargetRequest []RouteTargetRequest) ApiIpamRouteTargetsBulkPartialUpdateRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsBulkPartialUpdateRequest) Execute() ([]RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkPartialUpdateExecute(r)
}

/*
IpamRouteTargetsBulkPartialUpdate Method for IpamRouteTargetsBulkPartialUpdate

Patch a list of route target objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsBulkPartialUpdate(ctx context.Context) ApiIpamRouteTargetsBulkPartialUpdateRequest {
	return ApiIpamRouteTargetsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RouteTarget
func (a *IpamAPIService) IpamRouteTargetsBulkPartialUpdateExecute(r ApiIpamRouteTargetsBulkPartialUpdateRequest) ([]RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return localVarReturnValue, nil, reportError("routeTargetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	routeTargetRequest *[]RouteTargetRequest
}

func (r ApiIpamRouteTargetsBulkUpdateRequest) RouteTargetRequest(routeTargetRequest []RouteTargetRequest) ApiIpamRouteTargetsBulkUpdateRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsBulkUpdateRequest) Execute() ([]RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkUpdateExecute(r)
}

/*
IpamRouteTargetsBulkUpdate Method for IpamRouteTargetsBulkUpdate

Put a list of route target objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsBulkUpdate(ctx context.Context) ApiIpamRouteTargetsBulkUpdateRequest {
	return ApiIpamRouteTargetsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RouteTarget
func (a *IpamAPIService) IpamRouteTargetsBulkUpdateExecute(r ApiIpamRouteTargetsBulkUpdateRequest) ([]RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return localVarReturnValue, nil, reportError("routeTargetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	routeTargetRequest *RouteTargetRequest
}

func (r ApiIpamRouteTargetsCreateRequest) RouteTargetRequest(routeTargetRequest RouteTargetRequest) ApiIpamRouteTargetsCreateRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsCreateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsCreateExecute(r)
}

/*
IpamRouteTargetsCreate Method for IpamRouteTargetsCreate

Post a list of route target objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsCreateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsCreate(ctx context.Context) ApiIpamRouteTargetsCreateRequest {
	return ApiIpamRouteTargetsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsCreateExecute(r ApiIpamRouteTargetsCreateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return localVarReturnValue, nil, reportError("routeTargetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamRouteTargetsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRouteTargetsDestroyExecute(r)
}

/*
IpamRouteTargetsDestroy Method for IpamRouteTargetsDestroy

Delete a route target object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this route target.
 @return ApiIpamRouteTargetsDestroyRequest
*/
func (a *IpamAPIService) IpamRouteTargetsDestroy(ctx context.Context, id int32) ApiIpamRouteTargetsDestroyRequest {
	return ApiIpamRouteTargetsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRouteTargetsDestroyExecute(r ApiIpamRouteTargetsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	exportingL2vpn *[]*int64
	exportingL2vpnN *[]*int64
	exportingL2vpnId *[]int32
	exportingL2vpnIdN *[]int32
	exportingVrf *[]*string
	exportingVrfN *[]*string
	exportingVrfId *[]int32
	exportingVrfIdN *[]int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	importingL2vpn *[]*int64
	importingL2vpnN *[]*int64
	importingL2vpnId *[]int32
	importingL2vpnIdN *[]int32
	importingVrf *[]*string
	importingVrfN *[]*string
	importingVrfId *[]int32
	importingVrfIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*int32
	tenantIdN *[]*int32
	updatedByRequest *string
}

func (r ApiIpamRouteTargetsListRequest) Created(created []time.Time) ApiIpamRouteTargetsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedGt(createdGt []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedGte(createdGte []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedLt(createdLt []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedLte(createdLte []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedN(createdN []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedByRequest(createdByRequest string) ApiIpamRouteTargetsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamRouteTargetsListRequest) Description(description []string) ApiIpamRouteTargetsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamRouteTargetsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionIc(descriptionIc []string) ApiIpamRouteTargetsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionIe(descriptionIe []string) ApiIpamRouteTargetsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionIew(descriptionIew []string) ApiIpamRouteTargetsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamRouteTargetsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionN(descriptionN []string) ApiIpamRouteTargetsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionNic(descriptionNic []string) ApiIpamRouteTargetsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionNie(descriptionNie []string) ApiIpamRouteTargetsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamRouteTargetsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamRouteTargetsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Exporting L2VPN (identifier)
func (r ApiIpamRouteTargetsListRequest) ExportingL2vpn(exportingL2vpn []*int64) ApiIpamRouteTargetsListRequest {
	r.exportingL2vpn = &exportingL2vpn
	return r
}

// Exporting L2VPN (identifier)
func (r ApiIpamRouteTargetsListRequest) ExportingL2vpnN(exportingL2vpnN []*int64) ApiIpamRouteTargetsListRequest {
	r.exportingL2vpnN = &exportingL2vpnN
	return r
}

// Exporting L2VPN
func (r ApiIpamRouteTargetsListRequest) ExportingL2vpnId(exportingL2vpnId []int32) ApiIpamRouteTargetsListRequest {
	r.exportingL2vpnId = &exportingL2vpnId
	return r
}

// Exporting L2VPN
func (r ApiIpamRouteTargetsListRequest) ExportingL2vpnIdN(exportingL2vpnIdN []int32) ApiIpamRouteTargetsListRequest {
	r.exportingL2vpnIdN = &exportingL2vpnIdN
	return r
}

// Export VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ExportingVrf(exportingVrf []*string) ApiIpamRouteTargetsListRequest {
	r.exportingVrf = &exportingVrf
	return r
}

// Export VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ExportingVrfN(exportingVrfN []*string) ApiIpamRouteTargetsListRequest {
	r.exportingVrfN = &exportingVrfN
	return r
}

// Exporting VRF
func (r ApiIpamRouteTargetsListRequest) ExportingVrfId(exportingVrfId []int32) ApiIpamRouteTargetsListRequest {
	r.exportingVrfId = &exportingVrfId
	return r
}

// Exporting VRF
func (r ApiIpamRouteTargetsListRequest) ExportingVrfIdN(exportingVrfIdN []int32) ApiIpamRouteTargetsListRequest {
	r.exportingVrfIdN = &exportingVrfIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) Id(id []int32) ApiIpamRouteTargetsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdEmpty(idEmpty bool) ApiIpamRouteTargetsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdGt(idGt []int32) ApiIpamRouteTargetsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdGte(idGte []int32) ApiIpamRouteTargetsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdLt(idLt []int32) ApiIpamRouteTargetsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdLte(idLte []int32) ApiIpamRouteTargetsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdN(idN []int32) ApiIpamRouteTargetsListRequest {
	r.idN = &idN
	return r
}

// Importing L2VPN (identifier)
func (r ApiIpamRouteTargetsListRequest) ImportingL2vpn(importingL2vpn []*int64) ApiIpamRouteTargetsListRequest {
	r.importingL2vpn = &importingL2vpn
	return r
}

// Importing L2VPN (identifier)
func (r ApiIpamRouteTargetsListRequest) ImportingL2vpnN(importingL2vpnN []*int64) ApiIpamRouteTargetsListRequest {
	r.importingL2vpnN = &importingL2vpnN
	return r
}

// Importing L2VPN
func (r ApiIpamRouteTargetsListRequest) ImportingL2vpnId(importingL2vpnId []int32) ApiIpamRouteTargetsListRequest {
	r.importingL2vpnId = &importingL2vpnId
	return r
}

// Importing L2VPN
func (r ApiIpamRouteTargetsListRequest) ImportingL2vpnIdN(importingL2vpnIdN []int32) ApiIpamRouteTargetsListRequest {
	r.importingL2vpnIdN = &importingL2vpnIdN
	return r
}

// Import VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ImportingVrf(importingVrf []*string) ApiIpamRouteTargetsListRequest {
	r.importingVrf = &importingVrf
	return r
}

// Import VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ImportingVrfN(importingVrfN []*string) ApiIpamRouteTargetsListRequest {
	r.importingVrfN = &importingVrfN
	return r
}

// Importing VRF
func (r ApiIpamRouteTargetsListRequest) ImportingVrfId(importingVrfId []int32) ApiIpamRouteTargetsListRequest {
	r.importingVrfId = &importingVrfId
	return r
}

// Importing VRF
func (r ApiIpamRouteTargetsListRequest) ImportingVrfIdN(importingVrfIdN []int32) ApiIpamRouteTargetsListRequest {
	r.importingVrfIdN = &importingVrfIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamRouteTargetsListRequest) Limit(limit int32) ApiIpamRouteTargetsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamRouteTargetsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamRouteTargetsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamRouteTargetsListRequest) Name(name []string) ApiIpamRouteTargetsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameEmpty(nameEmpty bool) ApiIpamRouteTargetsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIc(nameIc []string) ApiIpamRouteTargetsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIe(nameIe []string) ApiIpamRouteTargetsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIew(nameIew []string) ApiIpamRouteTargetsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIsw(nameIsw []string) ApiIpamRouteTargetsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameN(nameN []string) ApiIpamRouteTargetsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNic(nameNic []string) ApiIpamRouteTargetsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNie(nameNie []string) ApiIpamRouteTargetsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNiew(nameNiew []string) ApiIpamRouteTargetsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNisw(nameNisw []string) ApiIpamRouteTargetsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRouteTargetsListRequest) Offset(offset int32) ApiIpamRouteTargetsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamRouteTargetsListRequest) Ordering(ordering string) ApiIpamRouteTargetsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamRouteTargetsListRequest) Q(q string) ApiIpamRouteTargetsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRouteTargetsListRequest) Tag(tag []string) ApiIpamRouteTargetsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamRouteTargetsListRequest) TagN(tagN []string) ApiIpamRouteTargetsListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamRouteTargetsListRequest) Tenant(tenant []string) ApiIpamRouteTargetsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamRouteTargetsListRequest) TenantN(tenantN []string) ApiIpamRouteTargetsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroup(tenantGroup []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroupN(tenantGroupN []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroupId(tenantGroupId []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamRouteTargetsListRequest) TenantId(tenantId []*int32) ApiIpamRouteTargetsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamRouteTargetsListRequest) TenantIdN(tenantIdN []*int32) ApiIpamRouteTargetsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamRouteTargetsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamRouteTargetsListRequest) Execute() (*PaginatedRouteTargetList, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsListExecute(r)
}

/*
IpamRouteTargetsList Method for IpamRouteTargetsList

Get a list of route target objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsListRequest
*/
func (a *IpamAPIService) IpamRouteTargetsList(ctx context.Context) ApiIpamRouteTargetsListRequest {
	return ApiIpamRouteTargetsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRouteTargetList
func (a *IpamAPIService) IpamRouteTargetsListExecute(r ApiIpamRouteTargetsListRequest) (*PaginatedRouteTargetList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRouteTargetList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.exportingL2vpn != nil {
		t := *r.exportingL2vpn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn", t, "form", "multi")
		}
	}
	if r.exportingL2vpnN != nil {
		t := *r.exportingL2vpnN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn__n", t, "form", "multi")
		}
	}
	if r.exportingL2vpnId != nil {
		t := *r.exportingL2vpnId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn_id", t, "form", "multi")
		}
	}
	if r.exportingL2vpnIdN != nil {
		t := *r.exportingL2vpnIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn_id__n", t, "form", "multi")
		}
	}
	if r.exportingVrf != nil {
		t := *r.exportingVrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf", t, "form", "multi")
		}
	}
	if r.exportingVrfN != nil {
		t := *r.exportingVrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf__n", t, "form", "multi")
		}
	}
	if r.exportingVrfId != nil {
		t := *r.exportingVrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf_id", t, "form", "multi")
		}
	}
	if r.exportingVrfIdN != nil {
		t := *r.exportingVrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf_id__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.importingL2vpn != nil {
		t := *r.importingL2vpn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn", t, "form", "multi")
		}
	}
	if r.importingL2vpnN != nil {
		t := *r.importingL2vpnN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn__n", t, "form", "multi")
		}
	}
	if r.importingL2vpnId != nil {
		t := *r.importingL2vpnId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn_id", t, "form", "multi")
		}
	}
	if r.importingL2vpnIdN != nil {
		t := *r.importingL2vpnIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn_id__n", t, "form", "multi")
		}
	}
	if r.importingVrf != nil {
		t := *r.importingVrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf", t, "form", "multi")
		}
	}
	if r.importingVrfN != nil {
		t := *r.importingVrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf__n", t, "form", "multi")
		}
	}
	if r.importingVrfId != nil {
		t := *r.importingVrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf_id", t, "form", "multi")
		}
	}
	if r.importingVrfIdN != nil {
		t := *r.importingVrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "form", "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedRouteTargetRequest *PatchedRouteTargetRequest
}

func (r ApiIpamRouteTargetsPartialUpdateRequest) PatchedRouteTargetRequest(patchedRouteTargetRequest PatchedRouteTargetRequest) ApiIpamRouteTargetsPartialUpdateRequest {
	r.patchedRouteTargetRequest = &patchedRouteTargetRequest
	return r
}

func (r ApiIpamRouteTargetsPartialUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsPartialUpdateExecute(r)
}

/*
IpamRouteTargetsPartialUpdate Method for IpamRouteTargetsPartialUpdate

Patch a route target object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this route target.
 @return ApiIpamRouteTargetsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsPartialUpdate(ctx context.Context, id int32) ApiIpamRouteTargetsPartialUpdateRequest {
	return ApiIpamRouteTargetsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsPartialUpdateExecute(r ApiIpamRouteTargetsPartialUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRouteTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamRouteTargetsRetrieveRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsRetrieveExecute(r)
}

/*
IpamRouteTargetsRetrieve Method for IpamRouteTargetsRetrieve

Get a route target object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this route target.
 @return ApiIpamRouteTargetsRetrieveRequest
*/
func (a *IpamAPIService) IpamRouteTargetsRetrieve(ctx context.Context, id int32) ApiIpamRouteTargetsRetrieveRequest {
	return ApiIpamRouteTargetsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsRetrieveExecute(r ApiIpamRouteTargetsRetrieveRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	routeTargetRequest *RouteTargetRequest
}

func (r ApiIpamRouteTargetsUpdateRequest) RouteTargetRequest(routeTargetRequest RouteTargetRequest) ApiIpamRouteTargetsUpdateRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsUpdateExecute(r)
}

/*
IpamRouteTargetsUpdate Method for IpamRouteTargetsUpdate

Put a route target object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this route target.
 @return ApiIpamRouteTargetsUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsUpdate(ctx context.Context, id int32) ApiIpamRouteTargetsUpdateRequest {
	return ApiIpamRouteTargetsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsUpdateExecute(r ApiIpamRouteTargetsUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return localVarReturnValue, nil, reportError("routeTargetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	serviceTemplateRequest *[]ServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesBulkDestroyRequest) ServiceTemplateRequest(serviceTemplateRequest []ServiceTemplateRequest) ApiIpamServiceTemplatesBulkDestroyRequest {
	r.serviceTemplateRequest = &serviceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServiceTemplatesBulkDestroyExecute(r)
}

/*
IpamServiceTemplatesBulkDestroy Method for IpamServiceTemplatesBulkDestroy

Delete a list of service template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServiceTemplatesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesBulkDestroy(ctx context.Context) ApiIpamServiceTemplatesBulkDestroyRequest {
	return ApiIpamServiceTemplatesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamServiceTemplatesBulkDestroyExecute(r ApiIpamServiceTemplatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceTemplateRequest == nil {
		return nil, reportError("serviceTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	serviceTemplateRequest *[]ServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesBulkPartialUpdateRequest) ServiceTemplateRequest(serviceTemplateRequest []ServiceTemplateRequest) ApiIpamServiceTemplatesBulkPartialUpdateRequest {
	r.serviceTemplateRequest = &serviceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesBulkPartialUpdateRequest) Execute() ([]ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesBulkPartialUpdateExecute(r)
}

/*
IpamServiceTemplatesBulkPartialUpdate Method for IpamServiceTemplatesBulkPartialUpdate

Patch a list of service template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServiceTemplatesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesBulkPartialUpdate(ctx context.Context) ApiIpamServiceTemplatesBulkPartialUpdateRequest {
	return ApiIpamServiceTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesBulkPartialUpdateExecute(r ApiIpamServiceTemplatesBulkPartialUpdateRequest) ([]ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("serviceTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	serviceTemplateRequest *[]ServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesBulkUpdateRequest) ServiceTemplateRequest(serviceTemplateRequest []ServiceTemplateRequest) ApiIpamServiceTemplatesBulkUpdateRequest {
	r.serviceTemplateRequest = &serviceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesBulkUpdateRequest) Execute() ([]ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesBulkUpdateExecute(r)
}

/*
IpamServiceTemplatesBulkUpdate Method for IpamServiceTemplatesBulkUpdate

Put a list of service template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServiceTemplatesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesBulkUpdate(ctx context.Context) ApiIpamServiceTemplatesBulkUpdateRequest {
	return ApiIpamServiceTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesBulkUpdateExecute(r ApiIpamServiceTemplatesBulkUpdateRequest) ([]ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("serviceTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	writableServiceTemplateRequest *WritableServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesCreateRequest) WritableServiceTemplateRequest(writableServiceTemplateRequest WritableServiceTemplateRequest) ApiIpamServiceTemplatesCreateRequest {
	r.writableServiceTemplateRequest = &writableServiceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesCreateRequest) Execute() (*ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesCreateExecute(r)
}

/*
IpamServiceTemplatesCreate Method for IpamServiceTemplatesCreate

Post a list of service template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServiceTemplatesCreateRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesCreate(ctx context.Context) ApiIpamServiceTemplatesCreateRequest {
	return ApiIpamServiceTemplatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesCreateExecute(r ApiIpamServiceTemplatesCreateRequest) (*ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableServiceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableServiceTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableServiceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamServiceTemplatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServiceTemplatesDestroyExecute(r)
}

/*
IpamServiceTemplatesDestroy Method for IpamServiceTemplatesDestroy

Delete a service template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service template.
 @return ApiIpamServiceTemplatesDestroyRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesDestroy(ctx context.Context, id int32) ApiIpamServiceTemplatesDestroyRequest {
	return ApiIpamServiceTemplatesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamServiceTemplatesDestroyExecute(r ApiIpamServiceTemplatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	port *float32
	protocol *IpamServiceTemplatesListProtocolParameter
	q *string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiIpamServiceTemplatesListRequest) Created(created []time.Time) ApiIpamServiceTemplatesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedGt(createdGt []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedGte(createdGte []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedLt(createdLt []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedLte(createdLte []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedN(createdN []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedByRequest(createdByRequest string) ApiIpamServiceTemplatesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Description(description []string) ApiIpamServiceTemplatesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamServiceTemplatesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionIc(descriptionIc []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionIe(descriptionIe []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionIew(descriptionIew []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionN(descriptionN []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionNic(descriptionNic []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionNie(descriptionNie []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Id(id []int32) ApiIpamServiceTemplatesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdEmpty(idEmpty bool) ApiIpamServiceTemplatesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdGt(idGt []int32) ApiIpamServiceTemplatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdGte(idGte []int32) ApiIpamServiceTemplatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdLt(idLt []int32) ApiIpamServiceTemplatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdLte(idLte []int32) ApiIpamServiceTemplatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdN(idN []int32) ApiIpamServiceTemplatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamServiceTemplatesListRequest) Limit(limit int32) ApiIpamServiceTemplatesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamServiceTemplatesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamServiceTemplatesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Name(name []string) ApiIpamServiceTemplatesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameEmpty(nameEmpty bool) ApiIpamServiceTemplatesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameIc(nameIc []string) ApiIpamServiceTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameIe(nameIe []string) ApiIpamServiceTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameIew(nameIew []string) ApiIpamServiceTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameIsw(nameIsw []string) ApiIpamServiceTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameN(nameN []string) ApiIpamServiceTemplatesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameNic(nameNic []string) ApiIpamServiceTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameNie(nameNie []string) ApiIpamServiceTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameNiew(nameNiew []string) ApiIpamServiceTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameNisw(nameNisw []string) ApiIpamServiceTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamServiceTemplatesListRequest) Offset(offset int32) ApiIpamServiceTemplatesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamServiceTemplatesListRequest) Ordering(ordering string) ApiIpamServiceTemplatesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Port(port float32) ApiIpamServiceTemplatesListRequest {
	r.port = &port
	return r
}

// * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP
func (r ApiIpamServiceTemplatesListRequest) Protocol(protocol IpamServiceTemplatesListProtocolParameter) ApiIpamServiceTemplatesListRequest {
	r.protocol = &protocol
	return r
}

// Search
func (r ApiIpamServiceTemplatesListRequest) Q(q string) ApiIpamServiceTemplatesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Tag(tag []string) ApiIpamServiceTemplatesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamServiceTemplatesListRequest) TagN(tagN []string) ApiIpamServiceTemplatesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamServiceTemplatesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamServiceTemplatesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Execute() (*PaginatedServiceTemplateList, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesListExecute(r)
}

/*
IpamServiceTemplatesList Method for IpamServiceTemplatesList

Get a list of service template objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServiceTemplatesListRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesList(ctx context.Context) ApiIpamServiceTemplatesListRequest {
	return ApiIpamServiceTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedServiceTemplateList
func (a *IpamAPIService) IpamServiceTemplatesListExecute(r ApiIpamServiceTemplatesListRequest) (*PaginatedServiceTemplateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedServiceTemplateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.port != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", r.port, "form", "")
	}
	if r.protocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", r.protocol, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedWritableServiceTemplateRequest *PatchedWritableServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesPartialUpdateRequest) PatchedWritableServiceTemplateRequest(patchedWritableServiceTemplateRequest PatchedWritableServiceTemplateRequest) ApiIpamServiceTemplatesPartialUpdateRequest {
	r.patchedWritableServiceTemplateRequest = &patchedWritableServiceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesPartialUpdateRequest) Execute() (*ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesPartialUpdateExecute(r)
}

/*
IpamServiceTemplatesPartialUpdate Method for IpamServiceTemplatesPartialUpdate

Patch a service template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service template.
 @return ApiIpamServiceTemplatesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesPartialUpdate(ctx context.Context, id int32) ApiIpamServiceTemplatesPartialUpdateRequest {
	return ApiIpamServiceTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesPartialUpdateExecute(r ApiIpamServiceTemplatesPartialUpdateRequest) (*ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableServiceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamServiceTemplatesRetrieveRequest) Execute() (*ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesRetrieveExecute(r)
}

/*
IpamServiceTemplatesRetrieve Method for IpamServiceTemplatesRetrieve

Get a service template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service template.
 @return ApiIpamServiceTemplatesRetrieveRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesRetrieve(ctx context.Context, id int32) ApiIpamServiceTemplatesRetrieveRequest {
	return ApiIpamServiceTemplatesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesRetrieveExecute(r ApiIpamServiceTemplatesRetrieveRequest) (*ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	writableServiceTemplateRequest *WritableServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesUpdateRequest) WritableServiceTemplateRequest(writableServiceTemplateRequest WritableServiceTemplateRequest) ApiIpamServiceTemplatesUpdateRequest {
	r.writableServiceTemplateRequest = &writableServiceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesUpdateRequest) Execute() (*ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesUpdateExecute(r)
}

/*
IpamServiceTemplatesUpdate Method for IpamServiceTemplatesUpdate

Put a service template object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service template.
 @return ApiIpamServiceTemplatesUpdateRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesUpdate(ctx context.Context, id int32) ApiIpamServiceTemplatesUpdateRequest {
	return ApiIpamServiceTemplatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesUpdateExecute(r ApiIpamServiceTemplatesUpdateRequest) (*ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableServiceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableServiceTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableServiceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	serviceRequest *[]ServiceRequest
}

func (r ApiIpamServicesBulkDestroyRequest) ServiceRequest(serviceRequest []ServiceRequest) ApiIpamServicesBulkDestroyRequest {
	r.serviceRequest = &serviceRequest
	return r
}

func (r ApiIpamServicesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServicesBulkDestroyExecute(r)
}

/*
IpamServicesBulkDestroy Method for IpamServicesBulkDestroy

Delete a list of service objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamServicesBulkDestroy(ctx context.Context) ApiIpamServicesBulkDestroyRequest {
	return ApiIpamServicesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamServicesBulkDestroyExecute(r ApiIpamServicesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceRequest == nil {
		return nil, reportError("serviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServicesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	serviceRequest *[]ServiceRequest
}

func (r ApiIpamServicesBulkPartialUpdateRequest) ServiceRequest(serviceRequest []ServiceRequest) ApiIpamServicesBulkPartialUpdateRequest {
	r.serviceRequest = &serviceRequest
	return r
}

func (r ApiIpamServicesBulkPartialUpdateRequest) Execute() ([]Service, *http.Response, error) {
	return r.ApiService.IpamServicesBulkPartialUpdateExecute(r)
}

/*
IpamServicesBulkPartialUpdate Method for IpamServicesBulkPartialUpdate

Patch a list of service objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamServicesBulkPartialUpdate(ctx context.Context) ApiIpamServicesBulkPartialUpdateRequest {
	return ApiIpamServicesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Service
func (a *IpamAPIService) IpamServicesBulkPartialUpdateExecute(r ApiIpamServicesBulkPartialUpdateRequest) ([]Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceRequest == nil {
		return localVarReturnValue, nil, reportError("serviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	serviceRequest *[]ServiceRequest
}

func (r ApiIpamServicesBulkUpdateRequest) ServiceRequest(serviceRequest []ServiceRequest) ApiIpamServicesBulkUpdateRequest {
	r.serviceRequest = &serviceRequest
	return r
}

func (r ApiIpamServicesBulkUpdateRequest) Execute() ([]Service, *http.Response, error) {
	return r.ApiService.IpamServicesBulkUpdateExecute(r)
}

/*
IpamServicesBulkUpdate Method for IpamServicesBulkUpdate

Put a list of service objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamServicesBulkUpdate(ctx context.Context) ApiIpamServicesBulkUpdateRequest {
	return ApiIpamServicesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Service
func (a *IpamAPIService) IpamServicesBulkUpdateExecute(r ApiIpamServicesBulkUpdateRequest) ([]Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceRequest == nil {
		return localVarReturnValue, nil, reportError("serviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	writableServiceRequest *WritableServiceRequest
}

func (r ApiIpamServicesCreateRequest) WritableServiceRequest(writableServiceRequest WritableServiceRequest) ApiIpamServicesCreateRequest {
	r.writableServiceRequest = &writableServiceRequest
	return r
}

func (r ApiIpamServicesCreateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesCreateExecute(r)
}

/*
IpamServicesCreate Method for IpamServicesCreate

Post a list of service objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesCreateRequest
*/
func (a *IpamAPIService) IpamServicesCreate(ctx context.Context) ApiIpamServicesCreateRequest {
	return ApiIpamServicesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamAPIService) IpamServicesCreateExecute(r ApiIpamServicesCreateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableServiceRequest == nil {
		return localVarReturnValue, nil, reportError("writableServiceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableServiceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamServicesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServicesDestroyExecute(r)
}

/*
IpamServicesDestroy Method for IpamServicesDestroy

Delete a service object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service.
 @return ApiIpamServicesDestroyRequest
*/
func (a *IpamAPIService) IpamServicesDestroy(ctx context.Context, id int32) ApiIpamServicesDestroyRequest {
	return ApiIpamServicesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamServicesDestroyExecute(r ApiIpamServicesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServicesListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	device *[]*string
	deviceN *[]*string
	deviceId *[]*int32
	deviceIdN *[]*int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	ipAddress *[]string
	ipAddressN *[]string
	ipAddressId *[]int32
	ipAddressIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	port *float32
	protocol *IpamServiceTemplatesListProtocolParameter
	q *string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
	virtualMachine *[]string
	virtualMachineN *[]string
	virtualMachineId *[]*int32
	virtualMachineIdN *[]*int32
}

func (r ApiIpamServicesListRequest) Created(created []time.Time) ApiIpamServicesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamServicesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamServicesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamServicesListRequest) CreatedGt(createdGt []time.Time) ApiIpamServicesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamServicesListRequest) CreatedGte(createdGte []time.Time) ApiIpamServicesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamServicesListRequest) CreatedLt(createdLt []time.Time) ApiIpamServicesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamServicesListRequest) CreatedLte(createdLte []time.Time) ApiIpamServicesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamServicesListRequest) CreatedN(createdN []time.Time) ApiIpamServicesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamServicesListRequest) CreatedByRequest(createdByRequest string) ApiIpamServicesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamServicesListRequest) Description(description []string) ApiIpamServicesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamServicesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamServicesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamServicesListRequest) DescriptionIc(descriptionIc []string) ApiIpamServicesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamServicesListRequest) DescriptionIe(descriptionIe []string) ApiIpamServicesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamServicesListRequest) DescriptionIew(descriptionIew []string) ApiIpamServicesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamServicesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamServicesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamServicesListRequest) DescriptionN(descriptionN []string) ApiIpamServicesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamServicesListRequest) DescriptionNic(descriptionNic []string) ApiIpamServicesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamServicesListRequest) DescriptionNie(descriptionNie []string) ApiIpamServicesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamServicesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamServicesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamServicesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamServicesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Device (name)
func (r ApiIpamServicesListRequest) Device(device []*string) ApiIpamServicesListRequest {
	r.device = &device
	return r
}

// Device (name)
func (r ApiIpamServicesListRequest) DeviceN(deviceN []*string) ApiIpamServicesListRequest {
	r.deviceN = &deviceN
	return r
}

// Device (ID)
func (r ApiIpamServicesListRequest) DeviceId(deviceId []*int32) ApiIpamServicesListRequest {
	r.deviceId = &deviceId
	return r
}

// Device (ID)
func (r ApiIpamServicesListRequest) DeviceIdN(deviceIdN []*int32) ApiIpamServicesListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiIpamServicesListRequest) Id(id []int32) ApiIpamServicesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamServicesListRequest) IdEmpty(idEmpty bool) ApiIpamServicesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamServicesListRequest) IdGt(idGt []int32) ApiIpamServicesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamServicesListRequest) IdGte(idGte []int32) ApiIpamServicesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamServicesListRequest) IdLt(idLt []int32) ApiIpamServicesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamServicesListRequest) IdLte(idLte []int32) ApiIpamServicesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamServicesListRequest) IdN(idN []int32) ApiIpamServicesListRequest {
	r.idN = &idN
	return r
}

// IP address
func (r ApiIpamServicesListRequest) IpAddress(ipAddress []string) ApiIpamServicesListRequest {
	r.ipAddress = &ipAddress
	return r
}

// IP address
func (r ApiIpamServicesListRequest) IpAddressN(ipAddressN []string) ApiIpamServicesListRequest {
	r.ipAddressN = &ipAddressN
	return r
}

// IP address (ID)
func (r ApiIpamServicesListRequest) IpAddressId(ipAddressId []int32) ApiIpamServicesListRequest {
	r.ipAddressId = &ipAddressId
	return r
}

// IP address (ID)
func (r ApiIpamServicesListRequest) IpAddressIdN(ipAddressIdN []int32) ApiIpamServicesListRequest {
	r.ipAddressIdN = &ipAddressIdN
	return r
}

func (r ApiIpamServicesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamServicesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamServicesListRequest) Limit(limit int32) ApiIpamServicesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamServicesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamServicesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamServicesListRequest) Name(name []string) ApiIpamServicesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamServicesListRequest) NameEmpty(nameEmpty bool) ApiIpamServicesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamServicesListRequest) NameIc(nameIc []string) ApiIpamServicesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamServicesListRequest) NameIe(nameIe []string) ApiIpamServicesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamServicesListRequest) NameIew(nameIew []string) ApiIpamServicesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamServicesListRequest) NameIsw(nameIsw []string) ApiIpamServicesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamServicesListRequest) NameN(nameN []string) ApiIpamServicesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamServicesListRequest) NameNic(nameNic []string) ApiIpamServicesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamServicesListRequest) NameNie(nameNie []string) ApiIpamServicesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamServicesListRequest) NameNiew(nameNiew []string) ApiIpamServicesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamServicesListRequest) NameNisw(nameNisw []string) ApiIpamServicesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamServicesListRequest) Offset(offset int32) ApiIpamServicesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamServicesListRequest) Ordering(ordering string) ApiIpamServicesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamServicesListRequest) Port(port float32) ApiIpamServicesListRequest {
	r.port = &port
	return r
}

// * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP
func (r ApiIpamServicesListRequest) Protocol(protocol IpamServiceTemplatesListProtocolParameter) ApiIpamServicesListRequest {
	r.protocol = &protocol
	return r
}

// Search
func (r ApiIpamServicesListRequest) Q(q string) ApiIpamServicesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamServicesListRequest) Tag(tag []string) ApiIpamServicesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamServicesListRequest) TagN(tagN []string) ApiIpamServicesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamServicesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamServicesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

// Virtual machine (name)
func (r ApiIpamServicesListRequest) VirtualMachine(virtualMachine []string) ApiIpamServicesListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

// Virtual machine (name)
func (r ApiIpamServicesListRequest) VirtualMachineN(virtualMachineN []string) ApiIpamServicesListRequest {
	r.virtualMachineN = &virtualMachineN
	return r
}

// Virtual machine (ID)
func (r ApiIpamServicesListRequest) VirtualMachineId(virtualMachineId []*int32) ApiIpamServicesListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

// Virtual machine (ID)
func (r ApiIpamServicesListRequest) VirtualMachineIdN(virtualMachineIdN []*int32) ApiIpamServicesListRequest {
	r.virtualMachineIdN = &virtualMachineIdN
	return r
}

func (r ApiIpamServicesListRequest) Execute() (*PaginatedServiceList, *http.Response, error) {
	return r.ApiService.IpamServicesListExecute(r)
}

/*
IpamServicesList Method for IpamServicesList

Get a list of service objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesListRequest
*/
func (a *IpamAPIService) IpamServicesList(ctx context.Context) ApiIpamServicesListRequest {
	return ApiIpamServicesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedServiceList
func (a *IpamAPIService) IpamServicesListExecute(r ApiIpamServicesListRequest) (*PaginatedServiceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedServiceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "form", "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "form", "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "form", "multi")
		}
	}
	if r.deviceIdN != nil {
		t := *r.deviceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.ipAddress != nil {
		t := *r.ipAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address", t, "form", "multi")
		}
	}
	if r.ipAddressN != nil {
		t := *r.ipAddressN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address__n", t, "form", "multi")
		}
	}
	if r.ipAddressId != nil {
		t := *r.ipAddressId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address_id", t, "form", "multi")
		}
	}
	if r.ipAddressIdN != nil {
		t := *r.ipAddressIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.port != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", r.port, "form", "")
	}
	if r.protocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", r.protocol, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", t, "form", "multi")
		}
	}
	if r.virtualMachineN != nil {
		t := *r.virtualMachineN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__n", t, "form", "multi")
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", t, "form", "multi")
		}
	}
	if r.virtualMachineIdN != nil {
		t := *r.virtualMachineIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id__n", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedWritableServiceRequest *PatchedWritableServiceRequest
}

func (r ApiIpamServicesPartialUpdateRequest) PatchedWritableServiceRequest(patchedWritableServiceRequest PatchedWritableServiceRequest) ApiIpamServicesPartialUpdateRequest {
	r.patchedWritableServiceRequest = &patchedWritableServiceRequest
	return r
}

func (r ApiIpamServicesPartialUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesPartialUpdateExecute(r)
}

/*
IpamServicesPartialUpdate Method for IpamServicesPartialUpdate

Patch a service object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service.
 @return ApiIpamServicesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamServicesPartialUpdate(ctx context.Context, id int32) ApiIpamServicesPartialUpdateRequest {
	return ApiIpamServicesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamAPIService) IpamServicesPartialUpdateExecute(r ApiIpamServicesPartialUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableServiceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamServicesRetrieveRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesRetrieveExecute(r)
}

/*
IpamServicesRetrieve Method for IpamServicesRetrieve

Get a service object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service.
 @return ApiIpamServicesRetrieveRequest
*/
func (a *IpamAPIService) IpamServicesRetrieve(ctx context.Context, id int32) ApiIpamServicesRetrieveRequest {
	return ApiIpamServicesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamAPIService) IpamServicesRetrieveExecute(r ApiIpamServicesRetrieveRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	writableServiceRequest *WritableServiceRequest
}

func (r ApiIpamServicesUpdateRequest) WritableServiceRequest(writableServiceRequest WritableServiceRequest) ApiIpamServicesUpdateRequest {
	r.writableServiceRequest = &writableServiceRequest
	return r
}

func (r ApiIpamServicesUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesUpdateExecute(r)
}

/*
IpamServicesUpdate Method for IpamServicesUpdate

Put a service object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this service.
 @return ApiIpamServicesUpdateRequest
*/
func (a *IpamAPIService) IpamServicesUpdate(ctx context.Context, id int32) ApiIpamServicesUpdateRequest {
	return ApiIpamServicesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamAPIService) IpamServicesUpdateExecute(r ApiIpamServicesUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableServiceRequest == nil {
		return localVarReturnValue, nil, reportError("writableServiceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableServiceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsAvailableVlansCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	vLANRequest *[]VLANRequest
}

func (r ApiIpamVlanGroupsAvailableVlansCreateRequest) VLANRequest(vLANRequest []VLANRequest) ApiIpamVlanGroupsAvailableVlansCreateRequest {
	r.vLANRequest = &vLANRequest
	return r
}

func (r ApiIpamVlanGroupsAvailableVlansCreateRequest) Execute() ([]VLAN, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsAvailableVlansCreateExecute(r)
}

/*
IpamVlanGroupsAvailableVlansCreate Method for IpamVlanGroupsAvailableVlansCreate

Post a VLAN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIpamVlanGroupsAvailableVlansCreateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsAvailableVlansCreate(ctx context.Context, id int32) ApiIpamVlanGroupsAvailableVlansCreateRequest {
	return ApiIpamVlanGroupsAvailableVlansCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []VLAN
func (a *IpamAPIService) IpamVlanGroupsAvailableVlansCreateExecute(r ApiIpamVlanGroupsAvailableVlansCreateRequest) ([]VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsAvailableVlansCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/available-vlans/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANRequest == nil {
		return localVarReturnValue, nil, reportError("vLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsAvailableVlansListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamVlanGroupsAvailableVlansListRequest) Execute() ([]AvailableVLAN, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsAvailableVlansListExecute(r)
}

/*
IpamVlanGroupsAvailableVlansList Method for IpamVlanGroupsAvailableVlansList

Get a VLAN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiIpamVlanGroupsAvailableVlansListRequest
*/
func (a *IpamAPIService) IpamVlanGroupsAvailableVlansList(ctx context.Context, id int32) ApiIpamVlanGroupsAvailableVlansListRequest {
	return ApiIpamVlanGroupsAvailableVlansListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []AvailableVLAN
func (a *IpamAPIService) IpamVlanGroupsAvailableVlansListExecute(r ApiIpamVlanGroupsAvailableVlansListRequest) ([]AvailableVLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AvailableVLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsAvailableVlansList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/available-vlans/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANGroupRequest *[]VLANGroupRequest
}

func (r ApiIpamVlanGroupsBulkDestroyRequest) VLANGroupRequest(vLANGroupRequest []VLANGroupRequest) ApiIpamVlanGroupsBulkDestroyRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkDestroyExecute(r)
}

/*
IpamVlanGroupsBulkDestroy Method for IpamVlanGroupsBulkDestroy

Delete a list of VLAN group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVlanGroupsBulkDestroy(ctx context.Context) ApiIpamVlanGroupsBulkDestroyRequest {
	return ApiIpamVlanGroupsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanGroupsBulkDestroyExecute(r ApiIpamVlanGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return nil, reportError("vLANGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANGroupRequest *[]VLANGroupRequest
}

func (r ApiIpamVlanGroupsBulkPartialUpdateRequest) VLANGroupRequest(vLANGroupRequest []VLANGroupRequest) ApiIpamVlanGroupsBulkPartialUpdateRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsBulkPartialUpdateRequest) Execute() ([]VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkPartialUpdateExecute(r)
}

/*
IpamVlanGroupsBulkPartialUpdate Method for IpamVlanGroupsBulkPartialUpdate

Patch a list of VLAN group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsBulkPartialUpdate(ctx context.Context) ApiIpamVlanGroupsBulkPartialUpdateRequest {
	return ApiIpamVlanGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLANGroup
func (a *IpamAPIService) IpamVlanGroupsBulkPartialUpdateExecute(r ApiIpamVlanGroupsBulkPartialUpdateRequest) ([]VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("vLANGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANGroupRequest *[]VLANGroupRequest
}

func (r ApiIpamVlanGroupsBulkUpdateRequest) VLANGroupRequest(vLANGroupRequest []VLANGroupRequest) ApiIpamVlanGroupsBulkUpdateRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsBulkUpdateRequest) Execute() ([]VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkUpdateExecute(r)
}

/*
IpamVlanGroupsBulkUpdate Method for IpamVlanGroupsBulkUpdate

Put a list of VLAN group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsBulkUpdate(ctx context.Context) ApiIpamVlanGroupsBulkUpdateRequest {
	return ApiIpamVlanGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLANGroup
func (a *IpamAPIService) IpamVlanGroupsBulkUpdateExecute(r ApiIpamVlanGroupsBulkUpdateRequest) ([]VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("vLANGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANGroupRequest *VLANGroupRequest
}

func (r ApiIpamVlanGroupsCreateRequest) VLANGroupRequest(vLANGroupRequest VLANGroupRequest) ApiIpamVlanGroupsCreateRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsCreateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsCreateExecute(r)
}

/*
IpamVlanGroupsCreate Method for IpamVlanGroupsCreate

Post a list of VLAN group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsCreateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsCreate(ctx context.Context) ApiIpamVlanGroupsCreateRequest {
	return ApiIpamVlanGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsCreateExecute(r ApiIpamVlanGroupsCreateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("vLANGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamVlanGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanGroupsDestroyExecute(r)
}

/*
IpamVlanGroupsDestroy Method for IpamVlanGroupsDestroy

Delete a VLAN group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN group.
 @return ApiIpamVlanGroupsDestroyRequest
*/
func (a *IpamAPIService) IpamVlanGroupsDestroy(ctx context.Context, id int32) ApiIpamVlanGroupsDestroyRequest {
	return ApiIpamVlanGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanGroupsDestroyExecute(r ApiIpamVlanGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	cluster *int32
	clusterGroup *int32
	containsVid *float32
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	location *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	rack *int32
	region *int32
	scopeId *[]int32
	scopeIdEmpty *bool
	scopeIdGt *[]int32
	scopeIdGte *[]int32
	scopeIdLt *[]int32
	scopeIdLte *[]int32
	scopeIdN *[]int32
	scopeType *string
	scopeTypeN *string
	site *int32
	siteGroup *int32
	slug *[]string
	slugEmpty *bool
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNisw *[]string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiIpamVlanGroupsListRequest) Cluster(cluster int32) ApiIpamVlanGroupsListRequest {
	r.cluster = &cluster
	return r
}

func (r ApiIpamVlanGroupsListRequest) ClusterGroup(clusterGroup int32) ApiIpamVlanGroupsListRequest {
	r.clusterGroup = &clusterGroup
	return r
}

func (r ApiIpamVlanGroupsListRequest) ContainsVid(containsVid float32) ApiIpamVlanGroupsListRequest {
	r.containsVid = &containsVid
	return r
}

func (r ApiIpamVlanGroupsListRequest) Created(created []time.Time) ApiIpamVlanGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedGt(createdGt []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedGte(createdGte []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedLt(createdLt []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedLte(createdLte []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedN(createdN []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedByRequest(createdByRequest string) ApiIpamVlanGroupsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamVlanGroupsListRequest) Description(description []string) ApiIpamVlanGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamVlanGroupsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIc(descriptionIc []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIe(descriptionIe []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIew(descriptionIew []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionN(descriptionN []string) ApiIpamVlanGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNic(descriptionNic []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNie(descriptionNie []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) Id(id []int32) ApiIpamVlanGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdEmpty(idEmpty bool) ApiIpamVlanGroupsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdGt(idGt []int32) ApiIpamVlanGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdGte(idGte []int32) ApiIpamVlanGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdLt(idLt []int32) ApiIpamVlanGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdLte(idLte []int32) ApiIpamVlanGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdN(idN []int32) ApiIpamVlanGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamVlanGroupsListRequest) Limit(limit int32) ApiIpamVlanGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVlanGroupsListRequest) Location(location int32) ApiIpamVlanGroupsListRequest {
	r.location = &location
	return r
}

func (r ApiIpamVlanGroupsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamVlanGroupsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamVlanGroupsListRequest) Name(name []string) ApiIpamVlanGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameEmpty(nameEmpty bool) ApiIpamVlanGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIc(nameIc []string) ApiIpamVlanGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIe(nameIe []string) ApiIpamVlanGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIew(nameIew []string) ApiIpamVlanGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIsw(nameIsw []string) ApiIpamVlanGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameN(nameN []string) ApiIpamVlanGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNic(nameNic []string) ApiIpamVlanGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNie(nameNie []string) ApiIpamVlanGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNiew(nameNiew []string) ApiIpamVlanGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNisw(nameNisw []string) ApiIpamVlanGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlanGroupsListRequest) Offset(offset int32) ApiIpamVlanGroupsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVlanGroupsListRequest) Ordering(ordering string) ApiIpamVlanGroupsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamVlanGroupsListRequest) Q(q string) ApiIpamVlanGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVlanGroupsListRequest) Rack(rack int32) ApiIpamVlanGroupsListRequest {
	r.rack = &rack
	return r
}

func (r ApiIpamVlanGroupsListRequest) Region(region int32) ApiIpamVlanGroupsListRequest {
	r.region = &region
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeId(scopeId []int32) ApiIpamVlanGroupsListRequest {
	r.scopeId = &scopeId
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdEmpty(scopeIdEmpty bool) ApiIpamVlanGroupsListRequest {
	r.scopeIdEmpty = &scopeIdEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdGt(scopeIdGt []int32) ApiIpamVlanGroupsListRequest {
	r.scopeIdGt = &scopeIdGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdGte(scopeIdGte []int32) ApiIpamVlanGroupsListRequest {
	r.scopeIdGte = &scopeIdGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdLt(scopeIdLt []int32) ApiIpamVlanGroupsListRequest {
	r.scopeIdLt = &scopeIdLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdLte(scopeIdLte []int32) ApiIpamVlanGroupsListRequest {
	r.scopeIdLte = &scopeIdLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdN(scopeIdN []int32) ApiIpamVlanGroupsListRequest {
	r.scopeIdN = &scopeIdN
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeType(scopeType string) ApiIpamVlanGroupsListRequest {
	r.scopeType = &scopeType
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeTypeN(scopeTypeN string) ApiIpamVlanGroupsListRequest {
	r.scopeTypeN = &scopeTypeN
	return r
}

func (r ApiIpamVlanGroupsListRequest) Site(site int32) ApiIpamVlanGroupsListRequest {
	r.site = &site
	return r
}

func (r ApiIpamVlanGroupsListRequest) SiteGroup(siteGroup int32) ApiIpamVlanGroupsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiIpamVlanGroupsListRequest) Slug(slug []string) ApiIpamVlanGroupsListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugEmpty(slugEmpty bool) ApiIpamVlanGroupsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIc(slugIc []string) ApiIpamVlanGroupsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIe(slugIe []string) ApiIpamVlanGroupsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIew(slugIew []string) ApiIpamVlanGroupsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIsw(slugIsw []string) ApiIpamVlanGroupsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugN(slugN []string) ApiIpamVlanGroupsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNic(slugNic []string) ApiIpamVlanGroupsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNie(slugNie []string) ApiIpamVlanGroupsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNiew(slugNiew []string) ApiIpamVlanGroupsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNisw(slugNisw []string) ApiIpamVlanGroupsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) Tag(tag []string) ApiIpamVlanGroupsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVlanGroupsListRequest) TagN(tagN []string) ApiIpamVlanGroupsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamVlanGroupsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamVlanGroupsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamVlanGroupsListRequest) Execute() (*PaginatedVLANGroupList, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsListExecute(r)
}

/*
IpamVlanGroupsList Method for IpamVlanGroupsList

Get a list of VLAN group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsListRequest
*/
func (a *IpamAPIService) IpamVlanGroupsList(ctx context.Context) ApiIpamVlanGroupsListRequest {
	return ApiIpamVlanGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVLANGroupList
func (a *IpamAPIService) IpamVlanGroupsListExecute(r ApiIpamVlanGroupsListRequest) (*PaginatedVLANGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVLANGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.clusterGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_group", r.clusterGroup, "form", "")
	}
	if r.containsVid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains_vid", r.containsVid, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location", r.location, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.rack != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rack", r.rack, "form", "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "form", "")
	}
	if r.scopeId != nil {
		t := *r.scopeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id", t, "form", "multi")
		}
	}
	if r.scopeIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__empty", r.scopeIdEmpty, "form", "")
	}
	if r.scopeIdGt != nil {
		t := *r.scopeIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gt", t, "form", "multi")
		}
	}
	if r.scopeIdGte != nil {
		t := *r.scopeIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gte", t, "form", "multi")
		}
	}
	if r.scopeIdLt != nil {
		t := *r.scopeIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lt", t, "form", "multi")
		}
	}
	if r.scopeIdLte != nil {
		t := *r.scopeIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lte", t, "form", "multi")
		}
	}
	if r.scopeIdN != nil {
		t := *r.scopeIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__n", t, "form", "multi")
		}
	}
	if r.scopeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope_type", r.scopeType, "form", "")
	}
	if r.scopeTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope_type__n", r.scopeTypeN, "form", "")
	}
	if r.site != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "site", r.site, "form", "")
	}
	if r.siteGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "site_group", r.siteGroup, "form", "")
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug", t, "form", "multi")
		}
	}
	if r.slugEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slug__empty", r.slugEmpty, "form", "")
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", t, "form", "multi")
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", t, "form", "multi")
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", t, "form", "multi")
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", t, "form", "multi")
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", t, "form", "multi")
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", t, "form", "multi")
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", t, "form", "multi")
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", t, "form", "multi")
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedVLANGroupRequest *PatchedVLANGroupRequest
}

func (r ApiIpamVlanGroupsPartialUpdateRequest) PatchedVLANGroupRequest(patchedVLANGroupRequest PatchedVLANGroupRequest) ApiIpamVlanGroupsPartialUpdateRequest {
	r.patchedVLANGroupRequest = &patchedVLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsPartialUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsPartialUpdateExecute(r)
}

/*
IpamVlanGroupsPartialUpdate Method for IpamVlanGroupsPartialUpdate

Patch a VLAN group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN group.
 @return ApiIpamVlanGroupsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsPartialUpdate(ctx context.Context, id int32) ApiIpamVlanGroupsPartialUpdateRequest {
	return ApiIpamVlanGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsPartialUpdateExecute(r ApiIpamVlanGroupsPartialUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamVlanGroupsRetrieveRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsRetrieveExecute(r)
}

/*
IpamVlanGroupsRetrieve Method for IpamVlanGroupsRetrieve

Get a VLAN group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN group.
 @return ApiIpamVlanGroupsRetrieveRequest
*/
func (a *IpamAPIService) IpamVlanGroupsRetrieve(ctx context.Context, id int32) ApiIpamVlanGroupsRetrieveRequest {
	return ApiIpamVlanGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsRetrieveExecute(r ApiIpamVlanGroupsRetrieveRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	vLANGroupRequest *VLANGroupRequest
}

func (r ApiIpamVlanGroupsUpdateRequest) VLANGroupRequest(vLANGroupRequest VLANGroupRequest) ApiIpamVlanGroupsUpdateRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsUpdateExecute(r)
}

/*
IpamVlanGroupsUpdate Method for IpamVlanGroupsUpdate

Put a VLAN group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN group.
 @return ApiIpamVlanGroupsUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsUpdate(ctx context.Context, id int32) ApiIpamVlanGroupsUpdateRequest {
	return ApiIpamVlanGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsUpdateExecute(r ApiIpamVlanGroupsUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("vLANGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationPoliciesBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANTranslationPolicyRequest *[]VLANTranslationPolicyRequest
}

func (r ApiIpamVlanTranslationPoliciesBulkDestroyRequest) VLANTranslationPolicyRequest(vLANTranslationPolicyRequest []VLANTranslationPolicyRequest) ApiIpamVlanTranslationPoliciesBulkDestroyRequest {
	r.vLANTranslationPolicyRequest = &vLANTranslationPolicyRequest
	return r
}

func (r ApiIpamVlanTranslationPoliciesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanTranslationPoliciesBulkDestroyExecute(r)
}

/*
IpamVlanTranslationPoliciesBulkDestroy Method for IpamVlanTranslationPoliciesBulkDestroy

Delete a list of VLAN translation policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanTranslationPoliciesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVlanTranslationPoliciesBulkDestroy(ctx context.Context) ApiIpamVlanTranslationPoliciesBulkDestroyRequest {
	return ApiIpamVlanTranslationPoliciesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanTranslationPoliciesBulkDestroyExecute(r ApiIpamVlanTranslationPoliciesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationPoliciesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANTranslationPolicyRequest == nil {
		return nil, reportError("vLANTranslationPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANTranslationPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationPoliciesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANTranslationPolicyRequest *[]VLANTranslationPolicyRequest
}

func (r ApiIpamVlanTranslationPoliciesBulkPartialUpdateRequest) VLANTranslationPolicyRequest(vLANTranslationPolicyRequest []VLANTranslationPolicyRequest) ApiIpamVlanTranslationPoliciesBulkPartialUpdateRequest {
	r.vLANTranslationPolicyRequest = &vLANTranslationPolicyRequest
	return r
}

func (r ApiIpamVlanTranslationPoliciesBulkPartialUpdateRequest) Execute() ([]VLANTranslationPolicy, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationPoliciesBulkPartialUpdateExecute(r)
}

/*
IpamVlanTranslationPoliciesBulkPartialUpdate Method for IpamVlanTranslationPoliciesBulkPartialUpdate

Patch a list of VLAN translation policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanTranslationPoliciesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanTranslationPoliciesBulkPartialUpdate(ctx context.Context) ApiIpamVlanTranslationPoliciesBulkPartialUpdateRequest {
	return ApiIpamVlanTranslationPoliciesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLANTranslationPolicy
func (a *IpamAPIService) IpamVlanTranslationPoliciesBulkPartialUpdateExecute(r ApiIpamVlanTranslationPoliciesBulkPartialUpdateRequest) ([]VLANTranslationPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLANTranslationPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationPoliciesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANTranslationPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("vLANTranslationPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANTranslationPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationPoliciesBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANTranslationPolicyRequest *[]VLANTranslationPolicyRequest
}

func (r ApiIpamVlanTranslationPoliciesBulkUpdateRequest) VLANTranslationPolicyRequest(vLANTranslationPolicyRequest []VLANTranslationPolicyRequest) ApiIpamVlanTranslationPoliciesBulkUpdateRequest {
	r.vLANTranslationPolicyRequest = &vLANTranslationPolicyRequest
	return r
}

func (r ApiIpamVlanTranslationPoliciesBulkUpdateRequest) Execute() ([]VLANTranslationPolicy, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationPoliciesBulkUpdateExecute(r)
}

/*
IpamVlanTranslationPoliciesBulkUpdate Method for IpamVlanTranslationPoliciesBulkUpdate

Put a list of VLAN translation policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanTranslationPoliciesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVlanTranslationPoliciesBulkUpdate(ctx context.Context) ApiIpamVlanTranslationPoliciesBulkUpdateRequest {
	return ApiIpamVlanTranslationPoliciesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLANTranslationPolicy
func (a *IpamAPIService) IpamVlanTranslationPoliciesBulkUpdateExecute(r ApiIpamVlanTranslationPoliciesBulkUpdateRequest) ([]VLANTranslationPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLANTranslationPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationPoliciesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANTranslationPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("vLANTranslationPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANTranslationPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationPoliciesCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANTranslationPolicyRequest *VLANTranslationPolicyRequest
}

func (r ApiIpamVlanTranslationPoliciesCreateRequest) VLANTranslationPolicyRequest(vLANTranslationPolicyRequest VLANTranslationPolicyRequest) ApiIpamVlanTranslationPoliciesCreateRequest {
	r.vLANTranslationPolicyRequest = &vLANTranslationPolicyRequest
	return r
}

func (r ApiIpamVlanTranslationPoliciesCreateRequest) Execute() (*VLANTranslationPolicy, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationPoliciesCreateExecute(r)
}

/*
IpamVlanTranslationPoliciesCreate Method for IpamVlanTranslationPoliciesCreate

Post a list of VLAN translation policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanTranslationPoliciesCreateRequest
*/
func (a *IpamAPIService) IpamVlanTranslationPoliciesCreate(ctx context.Context) ApiIpamVlanTranslationPoliciesCreateRequest {
	return ApiIpamVlanTranslationPoliciesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLANTranslationPolicy
func (a *IpamAPIService) IpamVlanTranslationPoliciesCreateExecute(r ApiIpamVlanTranslationPoliciesCreateRequest) (*VLANTranslationPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANTranslationPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationPoliciesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANTranslationPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("vLANTranslationPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANTranslationPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationPoliciesDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamVlanTranslationPoliciesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanTranslationPoliciesDestroyExecute(r)
}

/*
IpamVlanTranslationPoliciesDestroy Method for IpamVlanTranslationPoliciesDestroy

Delete a VLAN translation policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN translation policy.
 @return ApiIpamVlanTranslationPoliciesDestroyRequest
*/
func (a *IpamAPIService) IpamVlanTranslationPoliciesDestroy(ctx context.Context, id int32) ApiIpamVlanTranslationPoliciesDestroyRequest {
	return ApiIpamVlanTranslationPoliciesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanTranslationPoliciesDestroyExecute(r ApiIpamVlanTranslationPoliciesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationPoliciesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationPoliciesListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiIpamVlanTranslationPoliciesListRequest) Created(created []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) CreatedGt(createdGt []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) CreatedGte(createdGte []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) CreatedLt(createdLt []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) CreatedLte(createdLte []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) CreatedN(createdN []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) CreatedByRequest(createdByRequest string) ApiIpamVlanTranslationPoliciesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) Description(description []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamVlanTranslationPoliciesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) DescriptionIc(descriptionIc []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) DescriptionIe(descriptionIe []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) DescriptionIew(descriptionIew []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) DescriptionN(descriptionN []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) DescriptionNic(descriptionNic []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) DescriptionNie(descriptionNie []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) Id(id []int32) ApiIpamVlanTranslationPoliciesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) IdEmpty(idEmpty bool) ApiIpamVlanTranslationPoliciesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) IdGt(idGt []int32) ApiIpamVlanTranslationPoliciesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) IdGte(idGte []int32) ApiIpamVlanTranslationPoliciesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) IdLt(idLt []int32) ApiIpamVlanTranslationPoliciesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) IdLte(idLte []int32) ApiIpamVlanTranslationPoliciesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) IdN(idN []int32) ApiIpamVlanTranslationPoliciesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamVlanTranslationPoliciesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamVlanTranslationPoliciesListRequest) Limit(limit int32) ApiIpamVlanTranslationPoliciesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamVlanTranslationPoliciesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) Name(name []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) NameEmpty(nameEmpty bool) ApiIpamVlanTranslationPoliciesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) NameIc(nameIc []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) NameIe(nameIe []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) NameIew(nameIew []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) NameIsw(nameIsw []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) NameN(nameN []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) NameNic(nameNic []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) NameNie(nameNie []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) NameNiew(nameNiew []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) NameNisw(nameNisw []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlanTranslationPoliciesListRequest) Offset(offset int32) ApiIpamVlanTranslationPoliciesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVlanTranslationPoliciesListRequest) Ordering(ordering string) ApiIpamVlanTranslationPoliciesListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamVlanTranslationPoliciesListRequest) Q(q string) ApiIpamVlanTranslationPoliciesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) Tag(tag []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) TagN(tagN []string) ApiIpamVlanTranslationPoliciesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamVlanTranslationPoliciesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamVlanTranslationPoliciesListRequest) Execute() (*PaginatedVLANTranslationPolicyList, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationPoliciesListExecute(r)
}

/*
IpamVlanTranslationPoliciesList Method for IpamVlanTranslationPoliciesList

Get a list of VLAN translation policy objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanTranslationPoliciesListRequest
*/
func (a *IpamAPIService) IpamVlanTranslationPoliciesList(ctx context.Context) ApiIpamVlanTranslationPoliciesListRequest {
	return ApiIpamVlanTranslationPoliciesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVLANTranslationPolicyList
func (a *IpamAPIService) IpamVlanTranslationPoliciesListExecute(r ApiIpamVlanTranslationPoliciesListRequest) (*PaginatedVLANTranslationPolicyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVLANTranslationPolicyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationPoliciesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-policies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationPoliciesPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedVLANTranslationPolicyRequest *PatchedVLANTranslationPolicyRequest
}

func (r ApiIpamVlanTranslationPoliciesPartialUpdateRequest) PatchedVLANTranslationPolicyRequest(patchedVLANTranslationPolicyRequest PatchedVLANTranslationPolicyRequest) ApiIpamVlanTranslationPoliciesPartialUpdateRequest {
	r.patchedVLANTranslationPolicyRequest = &patchedVLANTranslationPolicyRequest
	return r
}

func (r ApiIpamVlanTranslationPoliciesPartialUpdateRequest) Execute() (*VLANTranslationPolicy, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationPoliciesPartialUpdateExecute(r)
}

/*
IpamVlanTranslationPoliciesPartialUpdate Method for IpamVlanTranslationPoliciesPartialUpdate

Patch a VLAN translation policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN translation policy.
 @return ApiIpamVlanTranslationPoliciesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanTranslationPoliciesPartialUpdate(ctx context.Context, id int32) ApiIpamVlanTranslationPoliciesPartialUpdateRequest {
	return ApiIpamVlanTranslationPoliciesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANTranslationPolicy
func (a *IpamAPIService) IpamVlanTranslationPoliciesPartialUpdateExecute(r ApiIpamVlanTranslationPoliciesPartialUpdateRequest) (*VLANTranslationPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANTranslationPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationPoliciesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVLANTranslationPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationPoliciesRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamVlanTranslationPoliciesRetrieveRequest) Execute() (*VLANTranslationPolicy, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationPoliciesRetrieveExecute(r)
}

/*
IpamVlanTranslationPoliciesRetrieve Method for IpamVlanTranslationPoliciesRetrieve

Get a VLAN translation policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN translation policy.
 @return ApiIpamVlanTranslationPoliciesRetrieveRequest
*/
func (a *IpamAPIService) IpamVlanTranslationPoliciesRetrieve(ctx context.Context, id int32) ApiIpamVlanTranslationPoliciesRetrieveRequest {
	return ApiIpamVlanTranslationPoliciesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANTranslationPolicy
func (a *IpamAPIService) IpamVlanTranslationPoliciesRetrieveExecute(r ApiIpamVlanTranslationPoliciesRetrieveRequest) (*VLANTranslationPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANTranslationPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationPoliciesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationPoliciesUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	vLANTranslationPolicyRequest *VLANTranslationPolicyRequest
}

func (r ApiIpamVlanTranslationPoliciesUpdateRequest) VLANTranslationPolicyRequest(vLANTranslationPolicyRequest VLANTranslationPolicyRequest) ApiIpamVlanTranslationPoliciesUpdateRequest {
	r.vLANTranslationPolicyRequest = &vLANTranslationPolicyRequest
	return r
}

func (r ApiIpamVlanTranslationPoliciesUpdateRequest) Execute() (*VLANTranslationPolicy, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationPoliciesUpdateExecute(r)
}

/*
IpamVlanTranslationPoliciesUpdate Method for IpamVlanTranslationPoliciesUpdate

Put a VLAN translation policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN translation policy.
 @return ApiIpamVlanTranslationPoliciesUpdateRequest
*/
func (a *IpamAPIService) IpamVlanTranslationPoliciesUpdate(ctx context.Context, id int32) ApiIpamVlanTranslationPoliciesUpdateRequest {
	return ApiIpamVlanTranslationPoliciesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANTranslationPolicy
func (a *IpamAPIService) IpamVlanTranslationPoliciesUpdateExecute(r ApiIpamVlanTranslationPoliciesUpdateRequest) (*VLANTranslationPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANTranslationPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationPoliciesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-policies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANTranslationPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("vLANTranslationPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANTranslationPolicyRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationRulesBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANTranslationRuleRequest *[]VLANTranslationRuleRequest
}

func (r ApiIpamVlanTranslationRulesBulkDestroyRequest) VLANTranslationRuleRequest(vLANTranslationRuleRequest []VLANTranslationRuleRequest) ApiIpamVlanTranslationRulesBulkDestroyRequest {
	r.vLANTranslationRuleRequest = &vLANTranslationRuleRequest
	return r
}

func (r ApiIpamVlanTranslationRulesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanTranslationRulesBulkDestroyExecute(r)
}

/*
IpamVlanTranslationRulesBulkDestroy Method for IpamVlanTranslationRulesBulkDestroy

Delete a list of VLAN translation rule objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanTranslationRulesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVlanTranslationRulesBulkDestroy(ctx context.Context) ApiIpamVlanTranslationRulesBulkDestroyRequest {
	return ApiIpamVlanTranslationRulesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanTranslationRulesBulkDestroyExecute(r ApiIpamVlanTranslationRulesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationRulesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-rules/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANTranslationRuleRequest == nil {
		return nil, reportError("vLANTranslationRuleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANTranslationRuleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationRulesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANTranslationRuleRequest *[]VLANTranslationRuleRequest
}

func (r ApiIpamVlanTranslationRulesBulkPartialUpdateRequest) VLANTranslationRuleRequest(vLANTranslationRuleRequest []VLANTranslationRuleRequest) ApiIpamVlanTranslationRulesBulkPartialUpdateRequest {
	r.vLANTranslationRuleRequest = &vLANTranslationRuleRequest
	return r
}

func (r ApiIpamVlanTranslationRulesBulkPartialUpdateRequest) Execute() ([]VLANTranslationRule, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationRulesBulkPartialUpdateExecute(r)
}

/*
IpamVlanTranslationRulesBulkPartialUpdate Method for IpamVlanTranslationRulesBulkPartialUpdate

Patch a list of VLAN translation rule objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanTranslationRulesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanTranslationRulesBulkPartialUpdate(ctx context.Context) ApiIpamVlanTranslationRulesBulkPartialUpdateRequest {
	return ApiIpamVlanTranslationRulesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLANTranslationRule
func (a *IpamAPIService) IpamVlanTranslationRulesBulkPartialUpdateExecute(r ApiIpamVlanTranslationRulesBulkPartialUpdateRequest) ([]VLANTranslationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLANTranslationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationRulesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-rules/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANTranslationRuleRequest == nil {
		return localVarReturnValue, nil, reportError("vLANTranslationRuleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANTranslationRuleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationRulesBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANTranslationRuleRequest *[]VLANTranslationRuleRequest
}

func (r ApiIpamVlanTranslationRulesBulkUpdateRequest) VLANTranslationRuleRequest(vLANTranslationRuleRequest []VLANTranslationRuleRequest) ApiIpamVlanTranslationRulesBulkUpdateRequest {
	r.vLANTranslationRuleRequest = &vLANTranslationRuleRequest
	return r
}

func (r ApiIpamVlanTranslationRulesBulkUpdateRequest) Execute() ([]VLANTranslationRule, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationRulesBulkUpdateExecute(r)
}

/*
IpamVlanTranslationRulesBulkUpdate Method for IpamVlanTranslationRulesBulkUpdate

Put a list of VLAN translation rule objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanTranslationRulesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVlanTranslationRulesBulkUpdate(ctx context.Context) ApiIpamVlanTranslationRulesBulkUpdateRequest {
	return ApiIpamVlanTranslationRulesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLANTranslationRule
func (a *IpamAPIService) IpamVlanTranslationRulesBulkUpdateExecute(r ApiIpamVlanTranslationRulesBulkUpdateRequest) ([]VLANTranslationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLANTranslationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationRulesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-rules/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANTranslationRuleRequest == nil {
		return localVarReturnValue, nil, reportError("vLANTranslationRuleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANTranslationRuleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationRulesCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANTranslationRuleRequest *VLANTranslationRuleRequest
}

func (r ApiIpamVlanTranslationRulesCreateRequest) VLANTranslationRuleRequest(vLANTranslationRuleRequest VLANTranslationRuleRequest) ApiIpamVlanTranslationRulesCreateRequest {
	r.vLANTranslationRuleRequest = &vLANTranslationRuleRequest
	return r
}

func (r ApiIpamVlanTranslationRulesCreateRequest) Execute() (*VLANTranslationRule, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationRulesCreateExecute(r)
}

/*
IpamVlanTranslationRulesCreate Method for IpamVlanTranslationRulesCreate

Post a list of VLAN translation rule objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanTranslationRulesCreateRequest
*/
func (a *IpamAPIService) IpamVlanTranslationRulesCreate(ctx context.Context) ApiIpamVlanTranslationRulesCreateRequest {
	return ApiIpamVlanTranslationRulesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLANTranslationRule
func (a *IpamAPIService) IpamVlanTranslationRulesCreateExecute(r ApiIpamVlanTranslationRulesCreateRequest) (*VLANTranslationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANTranslationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationRulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-rules/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANTranslationRuleRequest == nil {
		return localVarReturnValue, nil, reportError("vLANTranslationRuleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANTranslationRuleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationRulesDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamVlanTranslationRulesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanTranslationRulesDestroyExecute(r)
}

/*
IpamVlanTranslationRulesDestroy Method for IpamVlanTranslationRulesDestroy

Delete a VLAN translation rule object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN translation rule.
 @return ApiIpamVlanTranslationRulesDestroyRequest
*/
func (a *IpamAPIService) IpamVlanTranslationRulesDestroy(ctx context.Context, id int32) ApiIpamVlanTranslationRulesDestroyRequest {
	return ApiIpamVlanTranslationRulesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanTranslationRulesDestroyExecute(r ApiIpamVlanTranslationRulesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationRulesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationRulesListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	localVid *[]int32
	localVidEmpty *bool
	localVidGt *[]int32
	localVidGte *[]int32
	localVidLt *[]int32
	localVidLte *[]int32
	localVidN *[]int32
	modifiedByRequest *string
	offset *int32
	ordering *string
	policy *[]string
	policyN *[]string
	policyId *[]int32
	policyIdN *[]int32
	q *string
	remoteVid *[]int32
	remoteVidEmpty *bool
	remoteVidGt *[]int32
	remoteVidGte *[]int32
	remoteVidLt *[]int32
	remoteVidLte *[]int32
	remoteVidN *[]int32
	tag *[]string
	tagN *[]string
	updatedByRequest *string
}

func (r ApiIpamVlanTranslationRulesListRequest) Created(created []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) CreatedGt(createdGt []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) CreatedGte(createdGte []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) CreatedLt(createdLt []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) CreatedLte(createdLte []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) CreatedN(createdN []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) CreatedByRequest(createdByRequest string) ApiIpamVlanTranslationRulesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) Description(description []string) ApiIpamVlanTranslationRulesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamVlanTranslationRulesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) DescriptionIc(descriptionIc []string) ApiIpamVlanTranslationRulesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) DescriptionIe(descriptionIe []string) ApiIpamVlanTranslationRulesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) DescriptionIew(descriptionIew []string) ApiIpamVlanTranslationRulesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamVlanTranslationRulesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) DescriptionN(descriptionN []string) ApiIpamVlanTranslationRulesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) DescriptionNic(descriptionNic []string) ApiIpamVlanTranslationRulesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) DescriptionNie(descriptionNie []string) ApiIpamVlanTranslationRulesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamVlanTranslationRulesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamVlanTranslationRulesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) Id(id []int32) ApiIpamVlanTranslationRulesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) IdEmpty(idEmpty bool) ApiIpamVlanTranslationRulesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) IdGt(idGt []int32) ApiIpamVlanTranslationRulesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) IdGte(idGte []int32) ApiIpamVlanTranslationRulesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) IdLt(idLt []int32) ApiIpamVlanTranslationRulesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) IdLte(idLte []int32) ApiIpamVlanTranslationRulesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) IdN(idN []int32) ApiIpamVlanTranslationRulesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamVlanTranslationRulesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamVlanTranslationRulesListRequest) Limit(limit int32) ApiIpamVlanTranslationRulesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LocalVid(localVid []int32) ApiIpamVlanTranslationRulesListRequest {
	r.localVid = &localVid
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LocalVidEmpty(localVidEmpty bool) ApiIpamVlanTranslationRulesListRequest {
	r.localVidEmpty = &localVidEmpty
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LocalVidGt(localVidGt []int32) ApiIpamVlanTranslationRulesListRequest {
	r.localVidGt = &localVidGt
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LocalVidGte(localVidGte []int32) ApiIpamVlanTranslationRulesListRequest {
	r.localVidGte = &localVidGte
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LocalVidLt(localVidLt []int32) ApiIpamVlanTranslationRulesListRequest {
	r.localVidLt = &localVidLt
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LocalVidLte(localVidLte []int32) ApiIpamVlanTranslationRulesListRequest {
	r.localVidLte = &localVidLte
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) LocalVidN(localVidN []int32) ApiIpamVlanTranslationRulesListRequest {
	r.localVidN = &localVidN
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamVlanTranslationRulesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlanTranslationRulesListRequest) Offset(offset int32) ApiIpamVlanTranslationRulesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVlanTranslationRulesListRequest) Ordering(ordering string) ApiIpamVlanTranslationRulesListRequest {
	r.ordering = &ordering
	return r
}

// VLAN Translation Policy (name)
func (r ApiIpamVlanTranslationRulesListRequest) Policy(policy []string) ApiIpamVlanTranslationRulesListRequest {
	r.policy = &policy
	return r
}

// VLAN Translation Policy (name)
func (r ApiIpamVlanTranslationRulesListRequest) PolicyN(policyN []string) ApiIpamVlanTranslationRulesListRequest {
	r.policyN = &policyN
	return r
}

// VLAN Translation Policy (ID)
func (r ApiIpamVlanTranslationRulesListRequest) PolicyId(policyId []int32) ApiIpamVlanTranslationRulesListRequest {
	r.policyId = &policyId
	return r
}

// VLAN Translation Policy (ID)
func (r ApiIpamVlanTranslationRulesListRequest) PolicyIdN(policyIdN []int32) ApiIpamVlanTranslationRulesListRequest {
	r.policyIdN = &policyIdN
	return r
}

// Search
func (r ApiIpamVlanTranslationRulesListRequest) Q(q string) ApiIpamVlanTranslationRulesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) RemoteVid(remoteVid []int32) ApiIpamVlanTranslationRulesListRequest {
	r.remoteVid = &remoteVid
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) RemoteVidEmpty(remoteVidEmpty bool) ApiIpamVlanTranslationRulesListRequest {
	r.remoteVidEmpty = &remoteVidEmpty
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) RemoteVidGt(remoteVidGt []int32) ApiIpamVlanTranslationRulesListRequest {
	r.remoteVidGt = &remoteVidGt
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) RemoteVidGte(remoteVidGte []int32) ApiIpamVlanTranslationRulesListRequest {
	r.remoteVidGte = &remoteVidGte
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) RemoteVidLt(remoteVidLt []int32) ApiIpamVlanTranslationRulesListRequest {
	r.remoteVidLt = &remoteVidLt
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) RemoteVidLte(remoteVidLte []int32) ApiIpamVlanTranslationRulesListRequest {
	r.remoteVidLte = &remoteVidLte
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) RemoteVidN(remoteVidN []int32) ApiIpamVlanTranslationRulesListRequest {
	r.remoteVidN = &remoteVidN
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) Tag(tag []string) ApiIpamVlanTranslationRulesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) TagN(tagN []string) ApiIpamVlanTranslationRulesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamVlanTranslationRulesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamVlanTranslationRulesListRequest) Execute() (*PaginatedVLANTranslationRuleList, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationRulesListExecute(r)
}

/*
IpamVlanTranslationRulesList Method for IpamVlanTranslationRulesList

Get a list of VLAN translation rule objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanTranslationRulesListRequest
*/
func (a *IpamAPIService) IpamVlanTranslationRulesList(ctx context.Context) ApiIpamVlanTranslationRulesListRequest {
	return ApiIpamVlanTranslationRulesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVLANTranslationRuleList
func (a *IpamAPIService) IpamVlanTranslationRulesListExecute(r ApiIpamVlanTranslationRulesListRequest) (*PaginatedVLANTranslationRuleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVLANTranslationRuleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationRulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-rules/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.localVid != nil {
		t := *r.localVid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid", t, "form", "multi")
		}
	}
	if r.localVidEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid__empty", r.localVidEmpty, "form", "")
	}
	if r.localVidGt != nil {
		t := *r.localVidGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid__gt", t, "form", "multi")
		}
	}
	if r.localVidGte != nil {
		t := *r.localVidGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid__gte", t, "form", "multi")
		}
	}
	if r.localVidLt != nil {
		t := *r.localVidLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid__lt", t, "form", "multi")
		}
	}
	if r.localVidLte != nil {
		t := *r.localVidLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid__lte", t, "form", "multi")
		}
	}
	if r.localVidN != nil {
		t := *r.localVidN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "local_vid__n", t, "form", "multi")
		}
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.policy != nil {
		t := *r.policy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policy", t, "form", "multi")
		}
	}
	if r.policyN != nil {
		t := *r.policyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policy__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policy__n", t, "form", "multi")
		}
	}
	if r.policyId != nil {
		t := *r.policyId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policy_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policy_id", t, "form", "multi")
		}
	}
	if r.policyIdN != nil {
		t := *r.policyIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "policy_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "policy_id__n", t, "form", "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.remoteVid != nil {
		t := *r.remoteVid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid", t, "form", "multi")
		}
	}
	if r.remoteVidEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid__empty", r.remoteVidEmpty, "form", "")
	}
	if r.remoteVidGt != nil {
		t := *r.remoteVidGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid__gt", t, "form", "multi")
		}
	}
	if r.remoteVidGte != nil {
		t := *r.remoteVidGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid__gte", t, "form", "multi")
		}
	}
	if r.remoteVidLt != nil {
		t := *r.remoteVidLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid__lt", t, "form", "multi")
		}
	}
	if r.remoteVidLte != nil {
		t := *r.remoteVidLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid__lte", t, "form", "multi")
		}
	}
	if r.remoteVidN != nil {
		t := *r.remoteVidN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "remote_vid__n", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationRulesPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedVLANTranslationRuleRequest *PatchedVLANTranslationRuleRequest
}

func (r ApiIpamVlanTranslationRulesPartialUpdateRequest) PatchedVLANTranslationRuleRequest(patchedVLANTranslationRuleRequest PatchedVLANTranslationRuleRequest) ApiIpamVlanTranslationRulesPartialUpdateRequest {
	r.patchedVLANTranslationRuleRequest = &patchedVLANTranslationRuleRequest
	return r
}

func (r ApiIpamVlanTranslationRulesPartialUpdateRequest) Execute() (*VLANTranslationRule, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationRulesPartialUpdateExecute(r)
}

/*
IpamVlanTranslationRulesPartialUpdate Method for IpamVlanTranslationRulesPartialUpdate

Patch a VLAN translation rule object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN translation rule.
 @return ApiIpamVlanTranslationRulesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanTranslationRulesPartialUpdate(ctx context.Context, id int32) ApiIpamVlanTranslationRulesPartialUpdateRequest {
	return ApiIpamVlanTranslationRulesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANTranslationRule
func (a *IpamAPIService) IpamVlanTranslationRulesPartialUpdateExecute(r ApiIpamVlanTranslationRulesPartialUpdateRequest) (*VLANTranslationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANTranslationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationRulesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVLANTranslationRuleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationRulesRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamVlanTranslationRulesRetrieveRequest) Execute() (*VLANTranslationRule, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationRulesRetrieveExecute(r)
}

/*
IpamVlanTranslationRulesRetrieve Method for IpamVlanTranslationRulesRetrieve

Get a VLAN translation rule object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN translation rule.
 @return ApiIpamVlanTranslationRulesRetrieveRequest
*/
func (a *IpamAPIService) IpamVlanTranslationRulesRetrieve(ctx context.Context, id int32) ApiIpamVlanTranslationRulesRetrieveRequest {
	return ApiIpamVlanTranslationRulesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANTranslationRule
func (a *IpamAPIService) IpamVlanTranslationRulesRetrieveExecute(r ApiIpamVlanTranslationRulesRetrieveRequest) (*VLANTranslationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANTranslationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationRulesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanTranslationRulesUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	vLANTranslationRuleRequest *VLANTranslationRuleRequest
}

func (r ApiIpamVlanTranslationRulesUpdateRequest) VLANTranslationRuleRequest(vLANTranslationRuleRequest VLANTranslationRuleRequest) ApiIpamVlanTranslationRulesUpdateRequest {
	r.vLANTranslationRuleRequest = &vLANTranslationRuleRequest
	return r
}

func (r ApiIpamVlanTranslationRulesUpdateRequest) Execute() (*VLANTranslationRule, *http.Response, error) {
	return r.ApiService.IpamVlanTranslationRulesUpdateExecute(r)
}

/*
IpamVlanTranslationRulesUpdate Method for IpamVlanTranslationRulesUpdate

Put a VLAN translation rule object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN translation rule.
 @return ApiIpamVlanTranslationRulesUpdateRequest
*/
func (a *IpamAPIService) IpamVlanTranslationRulesUpdate(ctx context.Context, id int32) ApiIpamVlanTranslationRulesUpdateRequest {
	return ApiIpamVlanTranslationRulesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANTranslationRule
func (a *IpamAPIService) IpamVlanTranslationRulesUpdateExecute(r ApiIpamVlanTranslationRulesUpdateRequest) (*VLANTranslationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANTranslationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanTranslationRulesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-translation-rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANTranslationRuleRequest == nil {
		return localVarReturnValue, nil, reportError("vLANTranslationRuleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANTranslationRuleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANRequest *[]VLANRequest
}

func (r ApiIpamVlansBulkDestroyRequest) VLANRequest(vLANRequest []VLANRequest) ApiIpamVlansBulkDestroyRequest {
	r.vLANRequest = &vLANRequest
	return r
}

func (r ApiIpamVlansBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlansBulkDestroyExecute(r)
}

/*
IpamVlansBulkDestroy Method for IpamVlansBulkDestroy

Delete a list of VLAN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVlansBulkDestroy(ctx context.Context) ApiIpamVlansBulkDestroyRequest {
	return ApiIpamVlansBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlansBulkDestroyExecute(r ApiIpamVlansBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANRequest == nil {
		return nil, reportError("vLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlansBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANRequest *[]VLANRequest
}

func (r ApiIpamVlansBulkPartialUpdateRequest) VLANRequest(vLANRequest []VLANRequest) ApiIpamVlansBulkPartialUpdateRequest {
	r.vLANRequest = &vLANRequest
	return r
}

func (r ApiIpamVlansBulkPartialUpdateRequest) Execute() ([]VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansBulkPartialUpdateExecute(r)
}

/*
IpamVlansBulkPartialUpdate Method for IpamVlansBulkPartialUpdate

Patch a list of VLAN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlansBulkPartialUpdate(ctx context.Context) ApiIpamVlansBulkPartialUpdateRequest {
	return ApiIpamVlansBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLAN
func (a *IpamAPIService) IpamVlansBulkPartialUpdateExecute(r ApiIpamVlansBulkPartialUpdateRequest) ([]VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANRequest == nil {
		return localVarReturnValue, nil, reportError("vLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vLANRequest *[]VLANRequest
}

func (r ApiIpamVlansBulkUpdateRequest) VLANRequest(vLANRequest []VLANRequest) ApiIpamVlansBulkUpdateRequest {
	r.vLANRequest = &vLANRequest
	return r
}

func (r ApiIpamVlansBulkUpdateRequest) Execute() ([]VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansBulkUpdateExecute(r)
}

/*
IpamVlansBulkUpdate Method for IpamVlansBulkUpdate

Put a list of VLAN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVlansBulkUpdate(ctx context.Context) ApiIpamVlansBulkUpdateRequest {
	return ApiIpamVlansBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VLAN
func (a *IpamAPIService) IpamVlansBulkUpdateExecute(r ApiIpamVlansBulkUpdateRequest) ([]VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANRequest == nil {
		return localVarReturnValue, nil, reportError("vLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	writableVLANRequest *WritableVLANRequest
}

func (r ApiIpamVlansCreateRequest) WritableVLANRequest(writableVLANRequest WritableVLANRequest) ApiIpamVlansCreateRequest {
	r.writableVLANRequest = &writableVLANRequest
	return r
}

func (r ApiIpamVlansCreateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansCreateExecute(r)
}

/*
IpamVlansCreate Method for IpamVlansCreate

Post a list of VLAN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansCreateRequest
*/
func (a *IpamAPIService) IpamVlansCreate(ctx context.Context) ApiIpamVlansCreateRequest {
	return ApiIpamVlansCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamAPIService) IpamVlansCreateExecute(r ApiIpamVlansCreateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVLANRequest == nil {
		return localVarReturnValue, nil, reportError("writableVLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamVlansDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlansDestroyExecute(r)
}

/*
IpamVlansDestroy Method for IpamVlansDestroy

Delete a VLAN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN.
 @return ApiIpamVlansDestroyRequest
*/
func (a *IpamAPIService) IpamVlansDestroy(ctx context.Context, id int32) ApiIpamVlansDestroyRequest {
	return ApiIpamVlansDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlansDestroyExecute(r ApiIpamVlansDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlansListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	availableAtSite *string
	availableOnDevice *string
	availableOnVirtualmachine *string
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	group *[]string
	groupN *[]string
	groupId *[]*int32
	groupIdN *[]*int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	interfaceId *string
	l2vpn *[]*int64
	l2vpnN *[]*int64
	l2vpnId *[]int32
	l2vpnIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	qinqRole *[]*string
	qinqRoleEmpty *bool
	qinqRoleIc *[]*string
	qinqRoleIe *[]*string
	qinqRoleIew *[]*string
	qinqRoleIsw *[]*string
	qinqRoleN *[]*string
	qinqRoleNic *[]*string
	qinqRoleNie *[]*string
	qinqRoleNiew *[]*string
	qinqRoleNisw *[]*string
	qinqSvlanId *[]*int32
	qinqSvlanIdN *[]*int32
	qinqSvlanVid *[]int32
	qinqSvlanVidEmpty *[]int32
	qinqSvlanVidGt *[]int32
	qinqSvlanVidGte *[]int32
	qinqSvlanVidLt *[]int32
	qinqSvlanVidLte *[]int32
	qinqSvlanVidN *[]int32
	region *[]string
	regionN *[]string
	regionId *[]string
	regionIdN *[]string
	role *[]string
	roleN *[]string
	roleId *[]*int32
	roleIdN *[]*int32
	site *[]string
	siteN *[]string
	siteGroup *[]string
	siteGroupN *[]string
	siteGroupId *[]string
	siteGroupIdN *[]string
	siteId *[]*int32
	siteIdN *[]*int32
	status *[]string
	statusEmpty *bool
	statusIc *[]string
	statusIe *[]string
	statusIew *[]string
	statusIsw *[]string
	statusN *[]string
	statusNic *[]string
	statusNie *[]string
	statusNiew *[]string
	statusNisw *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*int32
	tenantIdN *[]*int32
	updatedByRequest *string
	vid *[]int32
	vidEmpty *bool
	vidGt *[]int32
	vidGte *[]int32
	vidLt *[]int32
	vidLte *[]int32
	vidN *[]int32
	vminterfaceId *string
}

func (r ApiIpamVlansListRequest) AvailableAtSite(availableAtSite string) ApiIpamVlansListRequest {
	r.availableAtSite = &availableAtSite
	return r
}

func (r ApiIpamVlansListRequest) AvailableOnDevice(availableOnDevice string) ApiIpamVlansListRequest {
	r.availableOnDevice = &availableOnDevice
	return r
}

func (r ApiIpamVlansListRequest) AvailableOnVirtualmachine(availableOnVirtualmachine string) ApiIpamVlansListRequest {
	r.availableOnVirtualmachine = &availableOnVirtualmachine
	return r
}

func (r ApiIpamVlansListRequest) Created(created []time.Time) ApiIpamVlansListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlansListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamVlansListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamVlansListRequest) CreatedGt(createdGt []time.Time) ApiIpamVlansListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamVlansListRequest) CreatedGte(createdGte []time.Time) ApiIpamVlansListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlansListRequest) CreatedLt(createdLt []time.Time) ApiIpamVlansListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamVlansListRequest) CreatedLte(createdLte []time.Time) ApiIpamVlansListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVlansListRequest) CreatedN(createdN []time.Time) ApiIpamVlansListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamVlansListRequest) CreatedByRequest(createdByRequest string) ApiIpamVlansListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamVlansListRequest) Description(description []string) ApiIpamVlansListRequest {
	r.description = &description
	return r
}

func (r ApiIpamVlansListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamVlansListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamVlansListRequest) DescriptionIc(descriptionIc []string) ApiIpamVlansListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamVlansListRequest) DescriptionIe(descriptionIe []string) ApiIpamVlansListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamVlansListRequest) DescriptionIew(descriptionIew []string) ApiIpamVlansListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamVlansListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamVlansListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamVlansListRequest) DescriptionN(descriptionN []string) ApiIpamVlansListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamVlansListRequest) DescriptionNic(descriptionNic []string) ApiIpamVlansListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamVlansListRequest) DescriptionNie(descriptionNie []string) ApiIpamVlansListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamVlansListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamVlansListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamVlansListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamVlansListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Group
func (r ApiIpamVlansListRequest) Group(group []string) ApiIpamVlansListRequest {
	r.group = &group
	return r
}

// Group
func (r ApiIpamVlansListRequest) GroupN(groupN []string) ApiIpamVlansListRequest {
	r.groupN = &groupN
	return r
}

// Group (ID)
func (r ApiIpamVlansListRequest) GroupId(groupId []*int32) ApiIpamVlansListRequest {
	r.groupId = &groupId
	return r
}

// Group (ID)
func (r ApiIpamVlansListRequest) GroupIdN(groupIdN []*int32) ApiIpamVlansListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiIpamVlansListRequest) Id(id []int32) ApiIpamVlansListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlansListRequest) IdEmpty(idEmpty bool) ApiIpamVlansListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamVlansListRequest) IdGt(idGt []int32) ApiIpamVlansListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamVlansListRequest) IdGte(idGte []int32) ApiIpamVlansListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamVlansListRequest) IdLt(idLt []int32) ApiIpamVlansListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamVlansListRequest) IdLte(idLte []int32) ApiIpamVlansListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamVlansListRequest) IdN(idN []int32) ApiIpamVlansListRequest {
	r.idN = &idN
	return r
}

// Assigned interface
func (r ApiIpamVlansListRequest) InterfaceId(interfaceId string) ApiIpamVlansListRequest {
	r.interfaceId = &interfaceId
	return r
}

// L2VPN
func (r ApiIpamVlansListRequest) L2vpn(l2vpn []*int64) ApiIpamVlansListRequest {
	r.l2vpn = &l2vpn
	return r
}

// L2VPN
func (r ApiIpamVlansListRequest) L2vpnN(l2vpnN []*int64) ApiIpamVlansListRequest {
	r.l2vpnN = &l2vpnN
	return r
}

// L2VPN (ID)
func (r ApiIpamVlansListRequest) L2vpnId(l2vpnId []int32) ApiIpamVlansListRequest {
	r.l2vpnId = &l2vpnId
	return r
}

// L2VPN (ID)
func (r ApiIpamVlansListRequest) L2vpnIdN(l2vpnIdN []int32) ApiIpamVlansListRequest {
	r.l2vpnIdN = &l2vpnIdN
	return r
}

func (r ApiIpamVlansListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVlansListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamVlansListRequest) Limit(limit int32) ApiIpamVlansListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVlansListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamVlansListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamVlansListRequest) Name(name []string) ApiIpamVlansListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVlansListRequest) NameEmpty(nameEmpty bool) ApiIpamVlansListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamVlansListRequest) NameIc(nameIc []string) ApiIpamVlansListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVlansListRequest) NameIe(nameIe []string) ApiIpamVlansListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVlansListRequest) NameIew(nameIew []string) ApiIpamVlansListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVlansListRequest) NameIsw(nameIsw []string) ApiIpamVlansListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVlansListRequest) NameN(nameN []string) ApiIpamVlansListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVlansListRequest) NameNic(nameNic []string) ApiIpamVlansListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVlansListRequest) NameNie(nameNie []string) ApiIpamVlansListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVlansListRequest) NameNiew(nameNiew []string) ApiIpamVlansListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVlansListRequest) NameNisw(nameNisw []string) ApiIpamVlansListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlansListRequest) Offset(offset int32) ApiIpamVlansListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVlansListRequest) Ordering(ordering string) ApiIpamVlansListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamVlansListRequest) Q(q string) ApiIpamVlansListRequest {
	r.q = &q
	return r
}

// Customer/service VLAN designation (for Q-in-Q/IEEE 802.1ad)
func (r ApiIpamVlansListRequest) QinqRole(qinqRole []*string) ApiIpamVlansListRequest {
	r.qinqRole = &qinqRole
	return r
}

func (r ApiIpamVlansListRequest) QinqRoleEmpty(qinqRoleEmpty bool) ApiIpamVlansListRequest {
	r.qinqRoleEmpty = &qinqRoleEmpty
	return r
}

// Customer/service VLAN designation (for Q-in-Q/IEEE 802.1ad)
func (r ApiIpamVlansListRequest) QinqRoleIc(qinqRoleIc []*string) ApiIpamVlansListRequest {
	r.qinqRoleIc = &qinqRoleIc
	return r
}

// Customer/service VLAN designation (for Q-in-Q/IEEE 802.1ad)
func (r ApiIpamVlansListRequest) QinqRoleIe(qinqRoleIe []*string) ApiIpamVlansListRequest {
	r.qinqRoleIe = &qinqRoleIe
	return r
}

// Customer/service VLAN designation (for Q-in-Q/IEEE 802.1ad)
func (r ApiIpamVlansListRequest) QinqRoleIew(qinqRoleIew []*string) ApiIpamVlansListRequest {
	r.qinqRoleIew = &qinqRoleIew
	return r
}

// Customer/service VLAN designation (for Q-in-Q/IEEE 802.1ad)
func (r ApiIpamVlansListRequest) QinqRoleIsw(qinqRoleIsw []*string) ApiIpamVlansListRequest {
	r.qinqRoleIsw = &qinqRoleIsw
	return r
}

// Customer/service VLAN designation (for Q-in-Q/IEEE 802.1ad)
func (r ApiIpamVlansListRequest) QinqRoleN(qinqRoleN []*string) ApiIpamVlansListRequest {
	r.qinqRoleN = &qinqRoleN
	return r
}

// Customer/service VLAN designation (for Q-in-Q/IEEE 802.1ad)
func (r ApiIpamVlansListRequest) QinqRoleNic(qinqRoleNic []*string) ApiIpamVlansListRequest {
	r.qinqRoleNic = &qinqRoleNic
	return r
}

// Customer/service VLAN designation (for Q-in-Q/IEEE 802.1ad)
func (r ApiIpamVlansListRequest) QinqRoleNie(qinqRoleNie []*string) ApiIpamVlansListRequest {
	r.qinqRoleNie = &qinqRoleNie
	return r
}

// Customer/service VLAN designation (for Q-in-Q/IEEE 802.1ad)
func (r ApiIpamVlansListRequest) QinqRoleNiew(qinqRoleNiew []*string) ApiIpamVlansListRequest {
	r.qinqRoleNiew = &qinqRoleNiew
	return r
}

// Customer/service VLAN designation (for Q-in-Q/IEEE 802.1ad)
func (r ApiIpamVlansListRequest) QinqRoleNisw(qinqRoleNisw []*string) ApiIpamVlansListRequest {
	r.qinqRoleNisw = &qinqRoleNisw
	return r
}

// Q-in-Q SVLAN (ID)
func (r ApiIpamVlansListRequest) QinqSvlanId(qinqSvlanId []*int32) ApiIpamVlansListRequest {
	r.qinqSvlanId = &qinqSvlanId
	return r
}

// Q-in-Q SVLAN (ID)
func (r ApiIpamVlansListRequest) QinqSvlanIdN(qinqSvlanIdN []*int32) ApiIpamVlansListRequest {
	r.qinqSvlanIdN = &qinqSvlanIdN
	return r
}

func (r ApiIpamVlansListRequest) QinqSvlanVid(qinqSvlanVid []int32) ApiIpamVlansListRequest {
	r.qinqSvlanVid = &qinqSvlanVid
	return r
}

func (r ApiIpamVlansListRequest) QinqSvlanVidEmpty(qinqSvlanVidEmpty []int32) ApiIpamVlansListRequest {
	r.qinqSvlanVidEmpty = &qinqSvlanVidEmpty
	return r
}

func (r ApiIpamVlansListRequest) QinqSvlanVidGt(qinqSvlanVidGt []int32) ApiIpamVlansListRequest {
	r.qinqSvlanVidGt = &qinqSvlanVidGt
	return r
}

func (r ApiIpamVlansListRequest) QinqSvlanVidGte(qinqSvlanVidGte []int32) ApiIpamVlansListRequest {
	r.qinqSvlanVidGte = &qinqSvlanVidGte
	return r
}

func (r ApiIpamVlansListRequest) QinqSvlanVidLt(qinqSvlanVidLt []int32) ApiIpamVlansListRequest {
	r.qinqSvlanVidLt = &qinqSvlanVidLt
	return r
}

func (r ApiIpamVlansListRequest) QinqSvlanVidLte(qinqSvlanVidLte []int32) ApiIpamVlansListRequest {
	r.qinqSvlanVidLte = &qinqSvlanVidLte
	return r
}

func (r ApiIpamVlansListRequest) QinqSvlanVidN(qinqSvlanVidN []int32) ApiIpamVlansListRequest {
	r.qinqSvlanVidN = &qinqSvlanVidN
	return r
}

func (r ApiIpamVlansListRequest) Region(region []string) ApiIpamVlansListRequest {
	r.region = &region
	return r
}

func (r ApiIpamVlansListRequest) RegionN(regionN []string) ApiIpamVlansListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiIpamVlansListRequest) RegionId(regionId []string) ApiIpamVlansListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiIpamVlansListRequest) RegionIdN(regionIdN []string) ApiIpamVlansListRequest {
	r.regionIdN = &regionIdN
	return r
}

// Role (slug)
func (r ApiIpamVlansListRequest) Role(role []string) ApiIpamVlansListRequest {
	r.role = &role
	return r
}

// Role (slug)
func (r ApiIpamVlansListRequest) RoleN(roleN []string) ApiIpamVlansListRequest {
	r.roleN = &roleN
	return r
}

// Role (ID)
func (r ApiIpamVlansListRequest) RoleId(roleId []*int32) ApiIpamVlansListRequest {
	r.roleId = &roleId
	return r
}

// Role (ID)
func (r ApiIpamVlansListRequest) RoleIdN(roleIdN []*int32) ApiIpamVlansListRequest {
	r.roleIdN = &roleIdN
	return r
}

// Site (slug)
func (r ApiIpamVlansListRequest) Site(site []string) ApiIpamVlansListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiIpamVlansListRequest) SiteN(siteN []string) ApiIpamVlansListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiIpamVlansListRequest) SiteGroup(siteGroup []string) ApiIpamVlansListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiIpamVlansListRequest) SiteGroupN(siteGroupN []string) ApiIpamVlansListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiIpamVlansListRequest) SiteGroupId(siteGroupId []string) ApiIpamVlansListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiIpamVlansListRequest) SiteGroupIdN(siteGroupIdN []string) ApiIpamVlansListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

// Site (ID)
func (r ApiIpamVlansListRequest) SiteId(siteId []*int32) ApiIpamVlansListRequest {
	r.siteId = &siteId
	return r
}

// Site (ID)
func (r ApiIpamVlansListRequest) SiteIdN(siteIdN []*int32) ApiIpamVlansListRequest {
	r.siteIdN = &siteIdN
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) Status(status []string) ApiIpamVlansListRequest {
	r.status = &status
	return r
}

func (r ApiIpamVlansListRequest) StatusEmpty(statusEmpty bool) ApiIpamVlansListRequest {
	r.statusEmpty = &statusEmpty
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) StatusIc(statusIc []string) ApiIpamVlansListRequest {
	r.statusIc = &statusIc
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) StatusIe(statusIe []string) ApiIpamVlansListRequest {
	r.statusIe = &statusIe
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) StatusIew(statusIew []string) ApiIpamVlansListRequest {
	r.statusIew = &statusIew
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) StatusIsw(statusIsw []string) ApiIpamVlansListRequest {
	r.statusIsw = &statusIsw
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) StatusN(statusN []string) ApiIpamVlansListRequest {
	r.statusN = &statusN
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) StatusNic(statusNic []string) ApiIpamVlansListRequest {
	r.statusNic = &statusNic
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) StatusNie(statusNie []string) ApiIpamVlansListRequest {
	r.statusNie = &statusNie
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) StatusNiew(statusNiew []string) ApiIpamVlansListRequest {
	r.statusNiew = &statusNiew
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) StatusNisw(statusNisw []string) ApiIpamVlansListRequest {
	r.statusNisw = &statusNisw
	return r
}

func (r ApiIpamVlansListRequest) Tag(tag []string) ApiIpamVlansListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVlansListRequest) TagN(tagN []string) ApiIpamVlansListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamVlansListRequest) Tenant(tenant []string) ApiIpamVlansListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamVlansListRequest) TenantN(tenantN []string) ApiIpamVlansListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamVlansListRequest) TenantGroup(tenantGroup []string) ApiIpamVlansListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamVlansListRequest) TenantGroupN(tenantGroupN []string) ApiIpamVlansListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamVlansListRequest) TenantGroupId(tenantGroupId []string) ApiIpamVlansListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamVlansListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamVlansListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamVlansListRequest) TenantId(tenantId []*int32) ApiIpamVlansListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamVlansListRequest) TenantIdN(tenantIdN []*int32) ApiIpamVlansListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamVlansListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamVlansListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamVlansListRequest) Vid(vid []int32) ApiIpamVlansListRequest {
	r.vid = &vid
	return r
}

func (r ApiIpamVlansListRequest) VidEmpty(vidEmpty bool) ApiIpamVlansListRequest {
	r.vidEmpty = &vidEmpty
	return r
}

func (r ApiIpamVlansListRequest) VidGt(vidGt []int32) ApiIpamVlansListRequest {
	r.vidGt = &vidGt
	return r
}

func (r ApiIpamVlansListRequest) VidGte(vidGte []int32) ApiIpamVlansListRequest {
	r.vidGte = &vidGte
	return r
}

func (r ApiIpamVlansListRequest) VidLt(vidLt []int32) ApiIpamVlansListRequest {
	r.vidLt = &vidLt
	return r
}

func (r ApiIpamVlansListRequest) VidLte(vidLte []int32) ApiIpamVlansListRequest {
	r.vidLte = &vidLte
	return r
}

func (r ApiIpamVlansListRequest) VidN(vidN []int32) ApiIpamVlansListRequest {
	r.vidN = &vidN
	return r
}

// Assigned VM interface
func (r ApiIpamVlansListRequest) VminterfaceId(vminterfaceId string) ApiIpamVlansListRequest {
	r.vminterfaceId = &vminterfaceId
	return r
}

func (r ApiIpamVlansListRequest) Execute() (*PaginatedVLANList, *http.Response, error) {
	return r.ApiService.IpamVlansListExecute(r)
}

/*
IpamVlansList Method for IpamVlansList

Get a list of VLAN objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansListRequest
*/
func (a *IpamAPIService) IpamVlansList(ctx context.Context) ApiIpamVlansListRequest {
	return ApiIpamVlansListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVLANList
func (a *IpamAPIService) IpamVlansListExecute(r ApiIpamVlansListRequest) (*PaginatedVLANList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVLANList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.availableAtSite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available_at_site", r.availableAtSite, "form", "")
	}
	if r.availableOnDevice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available_on_device", r.availableOnDevice, "form", "")
	}
	if r.availableOnVirtualmachine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available_on_virtualmachine", r.availableOnVirtualmachine, "form", "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group", t, "form", "multi")
		}
	}
	if r.groupN != nil {
		t := *r.groupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", t, "form", "multi")
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", t, "form", "multi")
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.interfaceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", r.interfaceId, "form", "")
	}
	if r.l2vpn != nil {
		t := *r.l2vpn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn", t, "form", "multi")
		}
	}
	if r.l2vpnN != nil {
		t := *r.l2vpnN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn__n", t, "form", "multi")
		}
	}
	if r.l2vpnId != nil {
		t := *r.l2vpnId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id", t, "form", "multi")
		}
	}
	if r.l2vpnIdN != nil {
		t := *r.l2vpnIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.qinqRole != nil {
		t := *r.qinqRole
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role", t, "form", "multi")
		}
	}
	if r.qinqRoleEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__empty", r.qinqRoleEmpty, "form", "")
	}
	if r.qinqRoleIc != nil {
		t := *r.qinqRoleIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__ic", t, "form", "multi")
		}
	}
	if r.qinqRoleIe != nil {
		t := *r.qinqRoleIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__ie", t, "form", "multi")
		}
	}
	if r.qinqRoleIew != nil {
		t := *r.qinqRoleIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__iew", t, "form", "multi")
		}
	}
	if r.qinqRoleIsw != nil {
		t := *r.qinqRoleIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__isw", t, "form", "multi")
		}
	}
	if r.qinqRoleN != nil {
		t := *r.qinqRoleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__n", t, "form", "multi")
		}
	}
	if r.qinqRoleNic != nil {
		t := *r.qinqRoleNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__nic", t, "form", "multi")
		}
	}
	if r.qinqRoleNie != nil {
		t := *r.qinqRoleNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__nie", t, "form", "multi")
		}
	}
	if r.qinqRoleNiew != nil {
		t := *r.qinqRoleNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__niew", t, "form", "multi")
		}
	}
	if r.qinqRoleNisw != nil {
		t := *r.qinqRoleNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_role__nisw", t, "form", "multi")
		}
	}
	if r.qinqSvlanId != nil {
		t := *r.qinqSvlanId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_id", t, "form", "multi")
		}
	}
	if r.qinqSvlanIdN != nil {
		t := *r.qinqSvlanIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_id__n", t, "form", "multi")
		}
	}
	if r.qinqSvlanVid != nil {
		t := *r.qinqSvlanVid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid", t, "form", "multi")
		}
	}
	if r.qinqSvlanVidEmpty != nil {
		t := *r.qinqSvlanVidEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__empty", t, "form", "multi")
		}
	}
	if r.qinqSvlanVidGt != nil {
		t := *r.qinqSvlanVidGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__gt", t, "form", "multi")
		}
	}
	if r.qinqSvlanVidGte != nil {
		t := *r.qinqSvlanVidGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__gte", t, "form", "multi")
		}
	}
	if r.qinqSvlanVidLt != nil {
		t := *r.qinqSvlanVidLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__lt", t, "form", "multi")
		}
	}
	if r.qinqSvlanVidLte != nil {
		t := *r.qinqSvlanVidLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__lte", t, "form", "multi")
		}
	}
	if r.qinqSvlanVidN != nil {
		t := *r.qinqSvlanVidN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "qinq_svlan_vid__n", t, "form", "multi")
		}
	}
	if r.region != nil {
		t := *r.region
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region", t, "form", "multi")
		}
	}
	if r.regionN != nil {
		t := *r.regionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region__n", t, "form", "multi")
		}
	}
	if r.regionId != nil {
		t := *r.regionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region_id", t, "form", "multi")
		}
	}
	if r.regionIdN != nil {
		t := *r.regionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region_id__n", t, "form", "multi")
		}
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "form", "multi")
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "form", "multi")
		}
	}
	if r.roleId != nil {
		t := *r.roleId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", t, "form", "multi")
		}
	}
	if r.roleIdN != nil {
		t := *r.roleIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", t, "form", "multi")
		}
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site", t, "form", "multi")
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", t, "form", "multi")
		}
	}
	if r.siteGroup != nil {
		t := *r.siteGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group", t, "form", "multi")
		}
	}
	if r.siteGroupN != nil {
		t := *r.siteGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group__n", t, "form", "multi")
		}
	}
	if r.siteGroupId != nil {
		t := *r.siteGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id", t, "form", "multi")
		}
	}
	if r.siteGroupIdN != nil {
		t := *r.siteGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id__n", t, "form", "multi")
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", t, "form", "multi")
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", t, "form", "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "form", "multi")
		}
	}
	if r.statusEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__empty", r.statusEmpty, "form", "")
	}
	if r.statusIc != nil {
		t := *r.statusIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__ic", t, "form", "multi")
		}
	}
	if r.statusIe != nil {
		t := *r.statusIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__ie", t, "form", "multi")
		}
	}
	if r.statusIew != nil {
		t := *r.statusIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__iew", t, "form", "multi")
		}
	}
	if r.statusIsw != nil {
		t := *r.statusIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__isw", t, "form", "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "form", "multi")
		}
	}
	if r.statusNic != nil {
		t := *r.statusNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nic", t, "form", "multi")
		}
	}
	if r.statusNie != nil {
		t := *r.statusNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nie", t, "form", "multi")
		}
	}
	if r.statusNiew != nil {
		t := *r.statusNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__niew", t, "form", "multi")
		}
	}
	if r.statusNisw != nil {
		t := *r.statusNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "form", "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	if r.vid != nil {
		t := *r.vid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid", t, "form", "multi")
		}
	}
	if r.vidEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vid__empty", r.vidEmpty, "form", "")
	}
	if r.vidGt != nil {
		t := *r.vidGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gt", t, "form", "multi")
		}
	}
	if r.vidGte != nil {
		t := *r.vidGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gte", t, "form", "multi")
		}
	}
	if r.vidLt != nil {
		t := *r.vidLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lt", t, "form", "multi")
		}
	}
	if r.vidLte != nil {
		t := *r.vidLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lte", t, "form", "multi")
		}
	}
	if r.vidN != nil {
		t := *r.vidN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__n", t, "form", "multi")
		}
	}
	if r.vminterfaceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id", r.vminterfaceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedWritableVLANRequest *PatchedWritableVLANRequest
}

func (r ApiIpamVlansPartialUpdateRequest) PatchedWritableVLANRequest(patchedWritableVLANRequest PatchedWritableVLANRequest) ApiIpamVlansPartialUpdateRequest {
	r.patchedWritableVLANRequest = &patchedWritableVLANRequest
	return r
}

func (r ApiIpamVlansPartialUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansPartialUpdateExecute(r)
}

/*
IpamVlansPartialUpdate Method for IpamVlansPartialUpdate

Patch a VLAN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN.
 @return ApiIpamVlansPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlansPartialUpdate(ctx context.Context, id int32) ApiIpamVlansPartialUpdateRequest {
	return ApiIpamVlansPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamAPIService) IpamVlansPartialUpdateExecute(r ApiIpamVlansPartialUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableVLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamVlansRetrieveRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansRetrieveExecute(r)
}

/*
IpamVlansRetrieve Method for IpamVlansRetrieve

Get a VLAN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN.
 @return ApiIpamVlansRetrieveRequest
*/
func (a *IpamAPIService) IpamVlansRetrieve(ctx context.Context, id int32) ApiIpamVlansRetrieveRequest {
	return ApiIpamVlansRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamAPIService) IpamVlansRetrieveExecute(r ApiIpamVlansRetrieveRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	writableVLANRequest *WritableVLANRequest
}

func (r ApiIpamVlansUpdateRequest) WritableVLANRequest(writableVLANRequest WritableVLANRequest) ApiIpamVlansUpdateRequest {
	r.writableVLANRequest = &writableVLANRequest
	return r
}

func (r ApiIpamVlansUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansUpdateExecute(r)
}

/*
IpamVlansUpdate Method for IpamVlansUpdate

Put a VLAN object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VLAN.
 @return ApiIpamVlansUpdateRequest
*/
func (a *IpamAPIService) IpamVlansUpdate(ctx context.Context, id int32) ApiIpamVlansUpdateRequest {
	return ApiIpamVlansUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamAPIService) IpamVlansUpdateExecute(r ApiIpamVlansUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVLANRequest == nil {
		return localVarReturnValue, nil, reportError("writableVLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vRFRequest *[]VRFRequest
}

func (r ApiIpamVrfsBulkDestroyRequest) VRFRequest(vRFRequest []VRFRequest) ApiIpamVrfsBulkDestroyRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfsBulkDestroyExecute(r)
}

/*
IpamVrfsBulkDestroy Method for IpamVrfsBulkDestroy

Delete a list of VRF objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVrfsBulkDestroy(ctx context.Context) ApiIpamVrfsBulkDestroyRequest {
	return ApiIpamVrfsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVrfsBulkDestroyExecute(r ApiIpamVrfsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return nil, reportError("vRFRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vRFRequest *[]VRFRequest
}

func (r ApiIpamVrfsBulkPartialUpdateRequest) VRFRequest(vRFRequest []VRFRequest) ApiIpamVrfsBulkPartialUpdateRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsBulkPartialUpdateRequest) Execute() ([]VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsBulkPartialUpdateExecute(r)
}

/*
IpamVrfsBulkPartialUpdate Method for IpamVrfsBulkPartialUpdate

Patch a list of VRF objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsBulkPartialUpdate(ctx context.Context) ApiIpamVrfsBulkPartialUpdateRequest {
	return ApiIpamVrfsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VRF
func (a *IpamAPIService) IpamVrfsBulkPartialUpdateExecute(r ApiIpamVrfsBulkPartialUpdateRequest) ([]VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return localVarReturnValue, nil, reportError("vRFRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vRFRequest *[]VRFRequest
}

func (r ApiIpamVrfsBulkUpdateRequest) VRFRequest(vRFRequest []VRFRequest) ApiIpamVrfsBulkUpdateRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsBulkUpdateRequest) Execute() ([]VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsBulkUpdateExecute(r)
}

/*
IpamVrfsBulkUpdate Method for IpamVrfsBulkUpdate

Put a list of VRF objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsBulkUpdate(ctx context.Context) ApiIpamVrfsBulkUpdateRequest {
	return ApiIpamVrfsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VRF
func (a *IpamAPIService) IpamVrfsBulkUpdateExecute(r ApiIpamVrfsBulkUpdateRequest) ([]VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return localVarReturnValue, nil, reportError("vRFRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsCreateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	vRFRequest *VRFRequest
}

func (r ApiIpamVrfsCreateRequest) VRFRequest(vRFRequest VRFRequest) ApiIpamVrfsCreateRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsCreateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsCreateExecute(r)
}

/*
IpamVrfsCreate Method for IpamVrfsCreate

Post a list of VRF objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsCreateRequest
*/
func (a *IpamAPIService) IpamVrfsCreate(ctx context.Context) ApiIpamVrfsCreateRequest {
	return ApiIpamVrfsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamAPIService) IpamVrfsCreateExecute(r ApiIpamVrfsCreateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return localVarReturnValue, nil, reportError("vRFRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsDestroyRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamVrfsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfsDestroyExecute(r)
}

/*
IpamVrfsDestroy Method for IpamVrfsDestroy

Delete a VRF object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VRF.
 @return ApiIpamVrfsDestroyRequest
*/
func (a *IpamAPIService) IpamVrfsDestroy(ctx context.Context, id int32) ApiIpamVrfsDestroyRequest {
	return ApiIpamVrfsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVrfsDestroyExecute(r ApiIpamVrfsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfsListRequest struct {
	ctx context.Context
	ApiService IpamAPI
	created *[]time.Time
	createdEmpty *[]time.Time
	createdGt *[]time.Time
	createdGte *[]time.Time
	createdLt *[]time.Time
	createdLte *[]time.Time
	createdN *[]time.Time
	createdByRequest *string
	description *[]string
	descriptionEmpty *bool
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNisw *[]string
	enforceUnique *bool
	exportTarget *[]string
	exportTargetN *[]string
	exportTargetId *[]int32
	exportTargetIdN *[]int32
	id *[]int32
	idEmpty *bool
	idGt *[]int32
	idGte *[]int32
	idLt *[]int32
	idLte *[]int32
	idN *[]int32
	importTarget *[]string
	importTargetN *[]string
	importTargetId *[]int32
	importTargetIdN *[]int32
	lastUpdated *[]time.Time
	lastUpdatedEmpty *[]time.Time
	lastUpdatedGt *[]time.Time
	lastUpdatedGte *[]time.Time
	lastUpdatedLt *[]time.Time
	lastUpdatedLte *[]time.Time
	lastUpdatedN *[]time.Time
	limit *int32
	modifiedByRequest *string
	name *[]string
	nameEmpty *bool
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNisw *[]string
	offset *int32
	ordering *string
	q *string
	rd *[]string
	rdEmpty *bool
	rdIc *[]string
	rdIe *[]string
	rdIew *[]string
	rdIsw *[]string
	rdN *[]string
	rdNic *[]string
	rdNie *[]string
	rdNiew *[]string
	rdNisw *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*int32
	tenantIdN *[]*int32
	updatedByRequest *string
}

func (r ApiIpamVrfsListRequest) Created(created []time.Time) ApiIpamVrfsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVrfsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamVrfsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamVrfsListRequest) CreatedGt(createdGt []time.Time) ApiIpamVrfsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamVrfsListRequest) CreatedGte(createdGte []time.Time) ApiIpamVrfsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVrfsListRequest) CreatedLt(createdLt []time.Time) ApiIpamVrfsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamVrfsListRequest) CreatedLte(createdLte []time.Time) ApiIpamVrfsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVrfsListRequest) CreatedN(createdN []time.Time) ApiIpamVrfsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamVrfsListRequest) CreatedByRequest(createdByRequest string) ApiIpamVrfsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamVrfsListRequest) Description(description []string) ApiIpamVrfsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamVrfsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionIc(descriptionIc []string) ApiIpamVrfsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionIe(descriptionIe []string) ApiIpamVrfsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionIew(descriptionIew []string) ApiIpamVrfsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamVrfsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionN(descriptionN []string) ApiIpamVrfsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionNic(descriptionNic []string) ApiIpamVrfsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionNie(descriptionNie []string) ApiIpamVrfsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamVrfsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamVrfsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamVrfsListRequest) EnforceUnique(enforceUnique bool) ApiIpamVrfsListRequest {
	r.enforceUnique = &enforceUnique
	return r
}

// Export target (name)
func (r ApiIpamVrfsListRequest) ExportTarget(exportTarget []string) ApiIpamVrfsListRequest {
	r.exportTarget = &exportTarget
	return r
}

// Export target (name)
func (r ApiIpamVrfsListRequest) ExportTargetN(exportTargetN []string) ApiIpamVrfsListRequest {
	r.exportTargetN = &exportTargetN
	return r
}

// Export target
func (r ApiIpamVrfsListRequest) ExportTargetId(exportTargetId []int32) ApiIpamVrfsListRequest {
	r.exportTargetId = &exportTargetId
	return r
}

// Export target
func (r ApiIpamVrfsListRequest) ExportTargetIdN(exportTargetIdN []int32) ApiIpamVrfsListRequest {
	r.exportTargetIdN = &exportTargetIdN
	return r
}

func (r ApiIpamVrfsListRequest) Id(id []int32) ApiIpamVrfsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVrfsListRequest) IdEmpty(idEmpty bool) ApiIpamVrfsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamVrfsListRequest) IdGt(idGt []int32) ApiIpamVrfsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamVrfsListRequest) IdGte(idGte []int32) ApiIpamVrfsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamVrfsListRequest) IdLt(idLt []int32) ApiIpamVrfsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamVrfsListRequest) IdLte(idLte []int32) ApiIpamVrfsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamVrfsListRequest) IdN(idN []int32) ApiIpamVrfsListRequest {
	r.idN = &idN
	return r
}

// Import target (name)
func (r ApiIpamVrfsListRequest) ImportTarget(importTarget []string) ApiIpamVrfsListRequest {
	r.importTarget = &importTarget
	return r
}

// Import target (name)
func (r ApiIpamVrfsListRequest) ImportTargetN(importTargetN []string) ApiIpamVrfsListRequest {
	r.importTargetN = &importTargetN
	return r
}

// Import target
func (r ApiIpamVrfsListRequest) ImportTargetId(importTargetId []int32) ApiIpamVrfsListRequest {
	r.importTargetId = &importTargetId
	return r
}

// Import target
func (r ApiIpamVrfsListRequest) ImportTargetIdN(importTargetIdN []int32) ApiIpamVrfsListRequest {
	r.importTargetIdN = &importTargetIdN
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamVrfsListRequest) Limit(limit int32) ApiIpamVrfsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVrfsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamVrfsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamVrfsListRequest) Name(name []string) ApiIpamVrfsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVrfsListRequest) NameEmpty(nameEmpty bool) ApiIpamVrfsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamVrfsListRequest) NameIc(nameIc []string) ApiIpamVrfsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVrfsListRequest) NameIe(nameIe []string) ApiIpamVrfsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVrfsListRequest) NameIew(nameIew []string) ApiIpamVrfsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVrfsListRequest) NameIsw(nameIsw []string) ApiIpamVrfsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVrfsListRequest) NameN(nameN []string) ApiIpamVrfsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVrfsListRequest) NameNic(nameNic []string) ApiIpamVrfsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVrfsListRequest) NameNie(nameNie []string) ApiIpamVrfsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVrfsListRequest) NameNiew(nameNiew []string) ApiIpamVrfsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVrfsListRequest) NameNisw(nameNisw []string) ApiIpamVrfsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVrfsListRequest) Offset(offset int32) ApiIpamVrfsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVrfsListRequest) Ordering(ordering string) ApiIpamVrfsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamVrfsListRequest) Q(q string) ApiIpamVrfsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVrfsListRequest) Rd(rd []string) ApiIpamVrfsListRequest {
	r.rd = &rd
	return r
}

func (r ApiIpamVrfsListRequest) RdEmpty(rdEmpty bool) ApiIpamVrfsListRequest {
	r.rdEmpty = &rdEmpty
	return r
}

func (r ApiIpamVrfsListRequest) RdIc(rdIc []string) ApiIpamVrfsListRequest {
	r.rdIc = &rdIc
	return r
}

func (r ApiIpamVrfsListRequest) RdIe(rdIe []string) ApiIpamVrfsListRequest {
	r.rdIe = &rdIe
	return r
}

func (r ApiIpamVrfsListRequest) RdIew(rdIew []string) ApiIpamVrfsListRequest {
	r.rdIew = &rdIew
	return r
}

func (r ApiIpamVrfsListRequest) RdIsw(rdIsw []string) ApiIpamVrfsListRequest {
	r.rdIsw = &rdIsw
	return r
}

func (r ApiIpamVrfsListRequest) RdN(rdN []string) ApiIpamVrfsListRequest {
	r.rdN = &rdN
	return r
}

func (r ApiIpamVrfsListRequest) RdNic(rdNic []string) ApiIpamVrfsListRequest {
	r.rdNic = &rdNic
	return r
}

func (r ApiIpamVrfsListRequest) RdNie(rdNie []string) ApiIpamVrfsListRequest {
	r.rdNie = &rdNie
	return r
}

func (r ApiIpamVrfsListRequest) RdNiew(rdNiew []string) ApiIpamVrfsListRequest {
	r.rdNiew = &rdNiew
	return r
}

func (r ApiIpamVrfsListRequest) RdNisw(rdNisw []string) ApiIpamVrfsListRequest {
	r.rdNisw = &rdNisw
	return r
}

func (r ApiIpamVrfsListRequest) Tag(tag []string) ApiIpamVrfsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVrfsListRequest) TagN(tagN []string) ApiIpamVrfsListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamVrfsListRequest) Tenant(tenant []string) ApiIpamVrfsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamVrfsListRequest) TenantN(tenantN []string) ApiIpamVrfsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroup(tenantGroup []string) ApiIpamVrfsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroupN(tenantGroupN []string) ApiIpamVrfsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroupId(tenantGroupId []string) ApiIpamVrfsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamVrfsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamVrfsListRequest) TenantId(tenantId []*int32) ApiIpamVrfsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamVrfsListRequest) TenantIdN(tenantIdN []*int32) ApiIpamVrfsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamVrfsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamVrfsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamVrfsListRequest) Execute() (*PaginatedVRFList, *http.Response, error) {
	return r.ApiService.IpamVrfsListExecute(r)
}

/*
IpamVrfsList Method for IpamVrfsList

Get a list of VRF objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsListRequest
*/
func (a *IpamAPIService) IpamVrfsList(ctx context.Context) ApiIpamVrfsListRequest {
	return ApiIpamVrfsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVRFList
func (a *IpamAPIService) IpamVrfsListExecute(r ApiIpamVrfsListRequest) (*PaginatedVRFList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVRFList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "form", "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "form", "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "form", "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "form", "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "form", "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "form", "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "form", "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "form", "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "form", "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "form", "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "form", "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "form", "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "form", "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "form", "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "form", "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "form", "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "form", "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "form", "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "form", "multi")
		}
	}
	if r.enforceUnique != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enforce_unique", r.enforceUnique, "form", "")
	}
	if r.exportTarget != nil {
		t := *r.exportTarget
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target", t, "form", "multi")
		}
	}
	if r.exportTargetN != nil {
		t := *r.exportTargetN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target__n", t, "form", "multi")
		}
	}
	if r.exportTargetId != nil {
		t := *r.exportTargetId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id", t, "form", "multi")
		}
	}
	if r.exportTargetIdN != nil {
		t := *r.exportTargetIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id__n", t, "form", "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "form", "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "form", "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "form", "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "form", "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "form", "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "form", "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "form", "multi")
		}
	}
	if r.importTarget != nil {
		t := *r.importTarget
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target", t, "form", "multi")
		}
	}
	if r.importTargetN != nil {
		t := *r.importTargetN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target__n", t, "form", "multi")
		}
	}
	if r.importTargetId != nil {
		t := *r.importTargetId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id", t, "form", "multi")
		}
	}
	if r.importTargetIdN != nil {
		t := *r.importTargetIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id__n", t, "form", "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "form", "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "form", "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "form", "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "form", "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "form", "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "form", "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "form", "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "form", "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "form", "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "form", "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "form", "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "form", "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "form", "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "form", "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "form", "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "form", "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "form", "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.rd != nil {
		t := *r.rd
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd", t, "form", "multi")
		}
	}
	if r.rdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rd__empty", r.rdEmpty, "form", "")
	}
	if r.rdIc != nil {
		t := *r.rdIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ic", t, "form", "multi")
		}
	}
	if r.rdIe != nil {
		t := *r.rdIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ie", t, "form", "multi")
		}
	}
	if r.rdIew != nil {
		t := *r.rdIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__iew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__iew", t, "form", "multi")
		}
	}
	if r.rdIsw != nil {
		t := *r.rdIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__isw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__isw", t, "form", "multi")
		}
	}
	if r.rdN != nil {
		t := *r.rdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__n", t, "form", "multi")
		}
	}
	if r.rdNic != nil {
		t := *r.rdNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nic", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nic", t, "form", "multi")
		}
	}
	if r.rdNie != nil {
		t := *r.rdNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nie", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nie", t, "form", "multi")
		}
	}
	if r.rdNiew != nil {
		t := *r.rdNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__niew", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__niew", t, "form", "multi")
		}
	}
	if r.rdNisw != nil {
		t := *r.rdNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nisw", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nisw", t, "form", "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "form", "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "form", "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "form", "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "form", "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "form", "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "form", "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "form", "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "form", "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "form", "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "form", "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsPartialUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	patchedVRFRequest *PatchedVRFRequest
}

func (r ApiIpamVrfsPartialUpdateRequest) PatchedVRFRequest(patchedVRFRequest PatchedVRFRequest) ApiIpamVrfsPartialUpdateRequest {
	r.patchedVRFRequest = &patchedVRFRequest
	return r
}

func (r ApiIpamVrfsPartialUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsPartialUpdateExecute(r)
}

/*
IpamVrfsPartialUpdate Method for IpamVrfsPartialUpdate

Patch a VRF object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VRF.
 @return ApiIpamVrfsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsPartialUpdate(ctx context.Context, id int32) ApiIpamVrfsPartialUpdateRequest {
	return ApiIpamVrfsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamAPIService) IpamVrfsPartialUpdateExecute(r ApiIpamVrfsPartialUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsRetrieveRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
}

func (r ApiIpamVrfsRetrieveRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsRetrieveExecute(r)
}

/*
IpamVrfsRetrieve Method for IpamVrfsRetrieve

Get a VRF object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VRF.
 @return ApiIpamVrfsRetrieveRequest
*/
func (a *IpamAPIService) IpamVrfsRetrieve(ctx context.Context, id int32) ApiIpamVrfsRetrieveRequest {
	return ApiIpamVrfsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamAPIService) IpamVrfsRetrieveExecute(r ApiIpamVrfsRetrieveRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsUpdateRequest struct {
	ctx context.Context
	ApiService IpamAPI
	id int32
	vRFRequest *VRFRequest
}

func (r ApiIpamVrfsUpdateRequest) VRFRequest(vRFRequest VRFRequest) ApiIpamVrfsUpdateRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsUpdateExecute(r)
}

/*
IpamVrfsUpdate Method for IpamVrfsUpdate

Put a VRF object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this VRF.
 @return ApiIpamVrfsUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsUpdate(ctx context.Context, id int32) ApiIpamVrfsUpdateRequest {
	return ApiIpamVrfsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamAPIService) IpamVrfsUpdateExecute(r ApiIpamVrfsUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return localVarReturnValue, nil, reportError("vRFRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
