/*
NetBox REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 4.0.11 (4.0)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netbox

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
	"time"
)

// UsersAPIService UsersAPI service
type UsersAPIService service

type ApiUsersConfigRetrieveRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
}

func (r ApiUsersConfigRetrieveRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UsersConfigRetrieveExecute(r)
}

/*
UsersConfigRetrieve Method for UsersConfigRetrieve

An API endpoint via which a user can update his or her own UserConfig data (but no one else's).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersConfigRetrieveRequest
*/
func (a *UsersAPIService) UsersConfigRetrieve(ctx context.Context) ApiUsersConfigRetrieveRequest {
	return ApiUsersConfigRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *UsersAPIService) UsersConfigRetrieveExecute(r ApiUsersConfigRetrieveRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersConfigRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/config/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsBulkDestroyRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	groupRequest *[]GroupRequest
}

func (r ApiUsersGroupsBulkDestroyRequest) GroupRequest(groupRequest []GroupRequest) ApiUsersGroupsBulkDestroyRequest {
	r.groupRequest = &groupRequest
	return r
}

func (r ApiUsersGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersGroupsBulkDestroyExecute(r)
}

/*
UsersGroupsBulkDestroy Method for UsersGroupsBulkDestroy

Delete a list of group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersGroupsBulkDestroyRequest
*/
func (a *UsersAPIService) UsersGroupsBulkDestroy(ctx context.Context) ApiUsersGroupsBulkDestroyRequest {
	return ApiUsersGroupsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersGroupsBulkDestroyExecute(r ApiUsersGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupRequest == nil {
		return nil, reportError("groupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGroupsBulkPartialUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	groupRequest *[]GroupRequest
}

func (r ApiUsersGroupsBulkPartialUpdateRequest) GroupRequest(groupRequest []GroupRequest) ApiUsersGroupsBulkPartialUpdateRequest {
	r.groupRequest = &groupRequest
	return r
}

func (r ApiUsersGroupsBulkPartialUpdateRequest) Execute() ([]Group, *http.Response, error) {
	return r.ApiService.UsersGroupsBulkPartialUpdateExecute(r)
}

/*
UsersGroupsBulkPartialUpdate Method for UsersGroupsBulkPartialUpdate

Patch a list of group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersGroupsBulkPartialUpdateRequest
*/
func (a *UsersAPIService) UsersGroupsBulkPartialUpdate(ctx context.Context) ApiUsersGroupsBulkPartialUpdateRequest {
	return ApiUsersGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Group
func (a *UsersAPIService) UsersGroupsBulkPartialUpdateExecute(r ApiUsersGroupsBulkPartialUpdateRequest) ([]Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupRequest == nil {
		return localVarReturnValue, nil, reportError("groupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsBulkUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	groupRequest *[]GroupRequest
}

func (r ApiUsersGroupsBulkUpdateRequest) GroupRequest(groupRequest []GroupRequest) ApiUsersGroupsBulkUpdateRequest {
	r.groupRequest = &groupRequest
	return r
}

func (r ApiUsersGroupsBulkUpdateRequest) Execute() ([]Group, *http.Response, error) {
	return r.ApiService.UsersGroupsBulkUpdateExecute(r)
}

/*
UsersGroupsBulkUpdate Method for UsersGroupsBulkUpdate

Put a list of group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersGroupsBulkUpdateRequest
*/
func (a *UsersAPIService) UsersGroupsBulkUpdate(ctx context.Context) ApiUsersGroupsBulkUpdateRequest {
	return ApiUsersGroupsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Group
func (a *UsersAPIService) UsersGroupsBulkUpdateExecute(r ApiUsersGroupsBulkUpdateRequest) ([]Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupRequest == nil {
		return localVarReturnValue, nil, reportError("groupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsCreateRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	groupRequest *GroupRequest
}

func (r ApiUsersGroupsCreateRequest) GroupRequest(groupRequest GroupRequest) ApiUsersGroupsCreateRequest {
	r.groupRequest = &groupRequest
	return r
}

func (r ApiUsersGroupsCreateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsCreateExecute(r)
}

/*
UsersGroupsCreate Method for UsersGroupsCreate

Post a list of group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersGroupsCreateRequest
*/
func (a *UsersAPIService) UsersGroupsCreate(ctx context.Context) ApiUsersGroupsCreateRequest {
	return ApiUsersGroupsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Group
func (a *UsersAPIService) UsersGroupsCreateExecute(r ApiUsersGroupsCreateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupRequest == nil {
		return localVarReturnValue, nil, reportError("groupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	id         int32
}

func (r ApiUsersGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersGroupsDestroyExecute(r)
}

/*
UsersGroupsDestroy Method for UsersGroupsDestroy

Delete a group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this group.
	@return ApiUsersGroupsDestroyRequest
*/
func (a *UsersAPIService) UsersGroupsDestroy(ctx context.Context, id int32) ApiUsersGroupsDestroyRequest {
	return ApiUsersGroupsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersGroupsDestroyExecute(r ApiUsersGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGroupsListRequest struct {
	ctx              context.Context
	ApiService       *UsersAPIService
	description      *[]string
	descriptionEmpty *bool
	descriptionIc    *[]string
	descriptionIe    *[]string
	descriptionIew   *[]string
	descriptionIsw   *[]string
	descriptionN     *[]string
	descriptionNic   *[]string
	descriptionNie   *[]string
	descriptionNiew  *[]string
	descriptionNisw  *[]string
	id               *[]int32
	idEmpty          *bool
	idGt             *[]int32
	idGte            *[]int32
	idLt             *[]int32
	idLte            *[]int32
	idN              *[]int32
	limit            *int32
	name             *[]string
	nameEmpty        *bool
	nameIc           *[]string
	nameIe           *[]string
	nameIew          *[]string
	nameIsw          *[]string
	nameN            *[]string
	nameNic          *[]string
	nameNie          *[]string
	nameNiew         *[]string
	nameNisw         *[]string
	offset           *int32
	ordering         *string
	permissionId     *[]int32
	permissionIdN    *[]int32
	q                *string
	userId           *[]int32
	userIdN          *[]int32
}

func (r ApiUsersGroupsListRequest) Description(description []string) ApiUsersGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiUsersGroupsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionIc(descriptionIc []string) ApiUsersGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionIe(descriptionIe []string) ApiUsersGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionIew(descriptionIew []string) ApiUsersGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionIsw(descriptionIsw []string) ApiUsersGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionN(descriptionN []string) ApiUsersGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionNic(descriptionNic []string) ApiUsersGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionNie(descriptionNie []string) ApiUsersGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionNiew(descriptionNiew []string) ApiUsersGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiUsersGroupsListRequest) DescriptionNisw(descriptionNisw []string) ApiUsersGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiUsersGroupsListRequest) Id(id []int32) ApiUsersGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiUsersGroupsListRequest) IdEmpty(idEmpty bool) ApiUsersGroupsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiUsersGroupsListRequest) IdGt(idGt []int32) ApiUsersGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiUsersGroupsListRequest) IdGte(idGte []int32) ApiUsersGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiUsersGroupsListRequest) IdLt(idLt []int32) ApiUsersGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiUsersGroupsListRequest) IdLte(idLte []int32) ApiUsersGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiUsersGroupsListRequest) IdN(idN []int32) ApiUsersGroupsListRequest {
	r.idN = &idN
	return r
}

// Number of results to return per page.
func (r ApiUsersGroupsListRequest) Limit(limit int32) ApiUsersGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiUsersGroupsListRequest) Name(name []string) ApiUsersGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiUsersGroupsListRequest) NameEmpty(nameEmpty bool) ApiUsersGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiUsersGroupsListRequest) NameIc(nameIc []string) ApiUsersGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiUsersGroupsListRequest) NameIe(nameIe []string) ApiUsersGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiUsersGroupsListRequest) NameIew(nameIew []string) ApiUsersGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiUsersGroupsListRequest) NameIsw(nameIsw []string) ApiUsersGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiUsersGroupsListRequest) NameN(nameN []string) ApiUsersGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiUsersGroupsListRequest) NameNic(nameNic []string) ApiUsersGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiUsersGroupsListRequest) NameNie(nameNie []string) ApiUsersGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiUsersGroupsListRequest) NameNiew(nameNiew []string) ApiUsersGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiUsersGroupsListRequest) NameNisw(nameNisw []string) ApiUsersGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiUsersGroupsListRequest) Offset(offset int32) ApiUsersGroupsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiUsersGroupsListRequest) Ordering(ordering string) ApiUsersGroupsListRequest {
	r.ordering = &ordering
	return r
}

// Permission (ID)
func (r ApiUsersGroupsListRequest) PermissionId(permissionId []int32) ApiUsersGroupsListRequest {
	r.permissionId = &permissionId
	return r
}

// Permission (ID)
func (r ApiUsersGroupsListRequest) PermissionIdN(permissionIdN []int32) ApiUsersGroupsListRequest {
	r.permissionIdN = &permissionIdN
	return r
}

// Search
func (r ApiUsersGroupsListRequest) Q(q string) ApiUsersGroupsListRequest {
	r.q = &q
	return r
}

// User (ID)
func (r ApiUsersGroupsListRequest) UserId(userId []int32) ApiUsersGroupsListRequest {
	r.userId = &userId
	return r
}

// User (ID)
func (r ApiUsersGroupsListRequest) UserIdN(userIdN []int32) ApiUsersGroupsListRequest {
	r.userIdN = &userIdN
	return r
}

func (r ApiUsersGroupsListRequest) Execute() (*PaginatedGroupList, *http.Response, error) {
	return r.ApiService.UsersGroupsListExecute(r)
}

/*
UsersGroupsList Method for UsersGroupsList

Get a list of group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersGroupsListRequest
*/
func (a *UsersAPIService) UsersGroupsList(ctx context.Context) ApiUsersGroupsListRequest {
	return ApiUsersGroupsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedGroupList
func (a *UsersAPIService) UsersGroupsListExecute(r ApiUsersGroupsListRequest) (*PaginatedGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.permissionId != nil {
		t := *r.permissionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id", t, "multi")
		}
	}
	if r.permissionIdN != nil {
		t := *r.permissionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.userId != nil {
		t := *r.userId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", t, "multi")
		}
	}
	if r.userIdN != nil {
		t := *r.userIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_id__n", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsPartialUpdateRequest struct {
	ctx                 context.Context
	ApiService          *UsersAPIService
	id                  int32
	patchedGroupRequest *PatchedGroupRequest
}

func (r ApiUsersGroupsPartialUpdateRequest) PatchedGroupRequest(patchedGroupRequest PatchedGroupRequest) ApiUsersGroupsPartialUpdateRequest {
	r.patchedGroupRequest = &patchedGroupRequest
	return r
}

func (r ApiUsersGroupsPartialUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsPartialUpdateExecute(r)
}

/*
UsersGroupsPartialUpdate Method for UsersGroupsPartialUpdate

Patch a group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this group.
	@return ApiUsersGroupsPartialUpdateRequest
*/
func (a *UsersAPIService) UsersGroupsPartialUpdate(ctx context.Context, id int32) ApiUsersGroupsPartialUpdateRequest {
	return ApiUsersGroupsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Group
func (a *UsersAPIService) UsersGroupsPartialUpdateExecute(r ApiUsersGroupsPartialUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsRetrieveRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	id         int32
}

func (r ApiUsersGroupsRetrieveRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsRetrieveExecute(r)
}

/*
UsersGroupsRetrieve Method for UsersGroupsRetrieve

Get a group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this group.
	@return ApiUsersGroupsRetrieveRequest
*/
func (a *UsersAPIService) UsersGroupsRetrieve(ctx context.Context, id int32) ApiUsersGroupsRetrieveRequest {
	return ApiUsersGroupsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Group
func (a *UsersAPIService) UsersGroupsRetrieveExecute(r ApiUsersGroupsRetrieveRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	id           int32
	groupRequest *GroupRequest
}

func (r ApiUsersGroupsUpdateRequest) GroupRequest(groupRequest GroupRequest) ApiUsersGroupsUpdateRequest {
	r.groupRequest = &groupRequest
	return r
}

func (r ApiUsersGroupsUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsUpdateExecute(r)
}

/*
UsersGroupsUpdate Method for UsersGroupsUpdate

Put a group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this group.
	@return ApiUsersGroupsUpdateRequest
*/
func (a *UsersAPIService) UsersGroupsUpdate(ctx context.Context, id int32) ApiUsersGroupsUpdateRequest {
	return ApiUsersGroupsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Group
func (a *UsersAPIService) UsersGroupsUpdateExecute(r ApiUsersGroupsUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupRequest == nil {
		return localVarReturnValue, nil, reportError("groupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkDestroyRequest struct {
	ctx                     context.Context
	ApiService              *UsersAPIService
	objectPermissionRequest *[]ObjectPermissionRequest
}

func (r ApiUsersPermissionsBulkDestroyRequest) ObjectPermissionRequest(objectPermissionRequest []ObjectPermissionRequest) ApiUsersPermissionsBulkDestroyRequest {
	r.objectPermissionRequest = &objectPermissionRequest
	return r
}

func (r ApiUsersPermissionsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersPermissionsBulkDestroyExecute(r)
}

/*
UsersPermissionsBulkDestroy Method for UsersPermissionsBulkDestroy

Delete a list of permission objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersPermissionsBulkDestroyRequest
*/
func (a *UsersAPIService) UsersPermissionsBulkDestroy(ctx context.Context) ApiUsersPermissionsBulkDestroyRequest {
	return ApiUsersPermissionsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersPermissionsBulkDestroyExecute(r ApiUsersPermissionsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectPermissionRequest == nil {
		return nil, reportError("objectPermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectPermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkPartialUpdateRequest struct {
	ctx                     context.Context
	ApiService              *UsersAPIService
	objectPermissionRequest *[]ObjectPermissionRequest
}

func (r ApiUsersPermissionsBulkPartialUpdateRequest) ObjectPermissionRequest(objectPermissionRequest []ObjectPermissionRequest) ApiUsersPermissionsBulkPartialUpdateRequest {
	r.objectPermissionRequest = &objectPermissionRequest
	return r
}

func (r ApiUsersPermissionsBulkPartialUpdateRequest) Execute() ([]ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsBulkPartialUpdateExecute(r)
}

/*
UsersPermissionsBulkPartialUpdate Method for UsersPermissionsBulkPartialUpdate

Patch a list of permission objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersPermissionsBulkPartialUpdateRequest
*/
func (a *UsersAPIService) UsersPermissionsBulkPartialUpdate(ctx context.Context) ApiUsersPermissionsBulkPartialUpdateRequest {
	return ApiUsersPermissionsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ObjectPermission
func (a *UsersAPIService) UsersPermissionsBulkPartialUpdateExecute(r ApiUsersPermissionsBulkPartialUpdateRequest) ([]ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectPermissionRequest == nil {
		return localVarReturnValue, nil, reportError("objectPermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectPermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkUpdateRequest struct {
	ctx                     context.Context
	ApiService              *UsersAPIService
	objectPermissionRequest *[]ObjectPermissionRequest
}

func (r ApiUsersPermissionsBulkUpdateRequest) ObjectPermissionRequest(objectPermissionRequest []ObjectPermissionRequest) ApiUsersPermissionsBulkUpdateRequest {
	r.objectPermissionRequest = &objectPermissionRequest
	return r
}

func (r ApiUsersPermissionsBulkUpdateRequest) Execute() ([]ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsBulkUpdateExecute(r)
}

/*
UsersPermissionsBulkUpdate Method for UsersPermissionsBulkUpdate

Put a list of permission objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersPermissionsBulkUpdateRequest
*/
func (a *UsersAPIService) UsersPermissionsBulkUpdate(ctx context.Context) ApiUsersPermissionsBulkUpdateRequest {
	return ApiUsersPermissionsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ObjectPermission
func (a *UsersAPIService) UsersPermissionsBulkUpdateExecute(r ApiUsersPermissionsBulkUpdateRequest) ([]ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectPermissionRequest == nil {
		return localVarReturnValue, nil, reportError("objectPermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectPermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsCreateRequest struct {
	ctx                     context.Context
	ApiService              *UsersAPIService
	objectPermissionRequest *ObjectPermissionRequest
}

func (r ApiUsersPermissionsCreateRequest) ObjectPermissionRequest(objectPermissionRequest ObjectPermissionRequest) ApiUsersPermissionsCreateRequest {
	r.objectPermissionRequest = &objectPermissionRequest
	return r
}

func (r ApiUsersPermissionsCreateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsCreateExecute(r)
}

/*
UsersPermissionsCreate Method for UsersPermissionsCreate

Post a list of permission objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersPermissionsCreateRequest
*/
func (a *UsersAPIService) UsersPermissionsCreate(ctx context.Context) ApiUsersPermissionsCreateRequest {
	return ApiUsersPermissionsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ObjectPermission
func (a *UsersAPIService) UsersPermissionsCreateExecute(r ApiUsersPermissionsCreateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectPermissionRequest == nil {
		return localVarReturnValue, nil, reportError("objectPermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectPermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	id         int32
}

func (r ApiUsersPermissionsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersPermissionsDestroyExecute(r)
}

/*
UsersPermissionsDestroy Method for UsersPermissionsDestroy

Delete a permission object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this permission.
	@return ApiUsersPermissionsDestroyRequest
*/
func (a *UsersAPIService) UsersPermissionsDestroy(ctx context.Context, id int32) ApiUsersPermissionsDestroyRequest {
	return ApiUsersPermissionsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersPermissionsDestroyExecute(r ApiUsersPermissionsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPermissionsListRequest struct {
	ctx              context.Context
	ApiService       *UsersAPIService
	canAdd           *bool
	canChange        *bool
	canDelete        *bool
	canView          *bool
	description      *[]string
	descriptionEmpty *bool
	descriptionIc    *[]string
	descriptionIe    *[]string
	descriptionIew   *[]string
	descriptionIsw   *[]string
	descriptionN     *[]string
	descriptionNic   *[]string
	descriptionNie   *[]string
	descriptionNiew  *[]string
	descriptionNisw  *[]string
	enabled          *bool
	group            *[]string
	groupN           *[]string
	groupId          *[]int32
	groupIdN         *[]int32
	id               *[]int32
	idEmpty          *bool
	idGt             *[]int32
	idGte            *[]int32
	idLt             *[]int32
	idLte            *[]int32
	idN              *[]int32
	limit            *int32
	name             *[]string
	nameEmpty        *bool
	nameIc           *[]string
	nameIe           *[]string
	nameIew          *[]string
	nameIsw          *[]string
	nameN            *[]string
	nameNic          *[]string
	nameNie          *[]string
	nameNiew         *[]string
	nameNisw         *[]string
	objectType       *string
	objectTypeIc     *string
	objectTypeIe     *string
	objectTypeIew    *string
	objectTypeIsw    *string
	objectTypeN      *string
	objectTypeNic    *string
	objectTypeNie    *string
	objectTypeNiew   *string
	objectTypeNisw   *string
	objectTypeId     *[]int32
	objectTypeIdN    *[]int32
	objectTypes      *[]int32
	objectTypesN     *[]int32
	offset           *int32
	ordering         *string
	q                *string
	user             *[]string
	userN            *[]string
	userId           *[]int32
	userIdN          *[]int32
}

func (r ApiUsersPermissionsListRequest) CanAdd(canAdd bool) ApiUsersPermissionsListRequest {
	r.canAdd = &canAdd
	return r
}

func (r ApiUsersPermissionsListRequest) CanChange(canChange bool) ApiUsersPermissionsListRequest {
	r.canChange = &canChange
	return r
}

func (r ApiUsersPermissionsListRequest) CanDelete(canDelete bool) ApiUsersPermissionsListRequest {
	r.canDelete = &canDelete
	return r
}

func (r ApiUsersPermissionsListRequest) CanView(canView bool) ApiUsersPermissionsListRequest {
	r.canView = &canView
	return r
}

func (r ApiUsersPermissionsListRequest) Description(description []string) ApiUsersPermissionsListRequest {
	r.description = &description
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiUsersPermissionsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionIc(descriptionIc []string) ApiUsersPermissionsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionIe(descriptionIe []string) ApiUsersPermissionsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionIew(descriptionIew []string) ApiUsersPermissionsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionIsw(descriptionIsw []string) ApiUsersPermissionsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionN(descriptionN []string) ApiUsersPermissionsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionNic(descriptionNic []string) ApiUsersPermissionsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionNie(descriptionNie []string) ApiUsersPermissionsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionNiew(descriptionNiew []string) ApiUsersPermissionsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiUsersPermissionsListRequest) DescriptionNisw(descriptionNisw []string) ApiUsersPermissionsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiUsersPermissionsListRequest) Enabled(enabled bool) ApiUsersPermissionsListRequest {
	r.enabled = &enabled
	return r
}

// Group (name)
func (r ApiUsersPermissionsListRequest) Group(group []string) ApiUsersPermissionsListRequest {
	r.group = &group
	return r
}

// Group (name)
func (r ApiUsersPermissionsListRequest) GroupN(groupN []string) ApiUsersPermissionsListRequest {
	r.groupN = &groupN
	return r
}

// Group
func (r ApiUsersPermissionsListRequest) GroupId(groupId []int32) ApiUsersPermissionsListRequest {
	r.groupId = &groupId
	return r
}

// Group
func (r ApiUsersPermissionsListRequest) GroupIdN(groupIdN []int32) ApiUsersPermissionsListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiUsersPermissionsListRequest) Id(id []int32) ApiUsersPermissionsListRequest {
	r.id = &id
	return r
}

func (r ApiUsersPermissionsListRequest) IdEmpty(idEmpty bool) ApiUsersPermissionsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiUsersPermissionsListRequest) IdGt(idGt []int32) ApiUsersPermissionsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiUsersPermissionsListRequest) IdGte(idGte []int32) ApiUsersPermissionsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiUsersPermissionsListRequest) IdLt(idLt []int32) ApiUsersPermissionsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiUsersPermissionsListRequest) IdLte(idLte []int32) ApiUsersPermissionsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiUsersPermissionsListRequest) IdN(idN []int32) ApiUsersPermissionsListRequest {
	r.idN = &idN
	return r
}

// Number of results to return per page.
func (r ApiUsersPermissionsListRequest) Limit(limit int32) ApiUsersPermissionsListRequest {
	r.limit = &limit
	return r
}

func (r ApiUsersPermissionsListRequest) Name(name []string) ApiUsersPermissionsListRequest {
	r.name = &name
	return r
}

func (r ApiUsersPermissionsListRequest) NameEmpty(nameEmpty bool) ApiUsersPermissionsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiUsersPermissionsListRequest) NameIc(nameIc []string) ApiUsersPermissionsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiUsersPermissionsListRequest) NameIe(nameIe []string) ApiUsersPermissionsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiUsersPermissionsListRequest) NameIew(nameIew []string) ApiUsersPermissionsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiUsersPermissionsListRequest) NameIsw(nameIsw []string) ApiUsersPermissionsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiUsersPermissionsListRequest) NameN(nameN []string) ApiUsersPermissionsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiUsersPermissionsListRequest) NameNic(nameNic []string) ApiUsersPermissionsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiUsersPermissionsListRequest) NameNie(nameNie []string) ApiUsersPermissionsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiUsersPermissionsListRequest) NameNiew(nameNiew []string) ApiUsersPermissionsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiUsersPermissionsListRequest) NameNisw(nameNisw []string) ApiUsersPermissionsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectType(objectType string) ApiUsersPermissionsListRequest {
	r.objectType = &objectType
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeIc(objectTypeIc string) ApiUsersPermissionsListRequest {
	r.objectTypeIc = &objectTypeIc
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeIe(objectTypeIe string) ApiUsersPermissionsListRequest {
	r.objectTypeIe = &objectTypeIe
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeIew(objectTypeIew string) ApiUsersPermissionsListRequest {
	r.objectTypeIew = &objectTypeIew
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeIsw(objectTypeIsw string) ApiUsersPermissionsListRequest {
	r.objectTypeIsw = &objectTypeIsw
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeN(objectTypeN string) ApiUsersPermissionsListRequest {
	r.objectTypeN = &objectTypeN
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeNic(objectTypeNic string) ApiUsersPermissionsListRequest {
	r.objectTypeNic = &objectTypeNic
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeNie(objectTypeNie string) ApiUsersPermissionsListRequest {
	r.objectTypeNie = &objectTypeNie
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeNiew(objectTypeNiew string) ApiUsersPermissionsListRequest {
	r.objectTypeNiew = &objectTypeNiew
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeNisw(objectTypeNisw string) ApiUsersPermissionsListRequest {
	r.objectTypeNisw = &objectTypeNisw
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeId(objectTypeId []int32) ApiUsersPermissionsListRequest {
	r.objectTypeId = &objectTypeId
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypeIdN(objectTypeIdN []int32) ApiUsersPermissionsListRequest {
	r.objectTypeIdN = &objectTypeIdN
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypes(objectTypes []int32) ApiUsersPermissionsListRequest {
	r.objectTypes = &objectTypes
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypesN(objectTypesN []int32) ApiUsersPermissionsListRequest {
	r.objectTypesN = &objectTypesN
	return r
}

// The initial index from which to return the results.
func (r ApiUsersPermissionsListRequest) Offset(offset int32) ApiUsersPermissionsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiUsersPermissionsListRequest) Ordering(ordering string) ApiUsersPermissionsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiUsersPermissionsListRequest) Q(q string) ApiUsersPermissionsListRequest {
	r.q = &q
	return r
}

// User (name)
func (r ApiUsersPermissionsListRequest) User(user []string) ApiUsersPermissionsListRequest {
	r.user = &user
	return r
}

// User (name)
func (r ApiUsersPermissionsListRequest) UserN(userN []string) ApiUsersPermissionsListRequest {
	r.userN = &userN
	return r
}

// User
func (r ApiUsersPermissionsListRequest) UserId(userId []int32) ApiUsersPermissionsListRequest {
	r.userId = &userId
	return r
}

// User
func (r ApiUsersPermissionsListRequest) UserIdN(userIdN []int32) ApiUsersPermissionsListRequest {
	r.userIdN = &userIdN
	return r
}

func (r ApiUsersPermissionsListRequest) Execute() (*PaginatedObjectPermissionList, *http.Response, error) {
	return r.ApiService.UsersPermissionsListExecute(r)
}

/*
UsersPermissionsList Method for UsersPermissionsList

Get a list of permission objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersPermissionsListRequest
*/
func (a *UsersAPIService) UsersPermissionsList(ctx context.Context) ApiUsersPermissionsListRequest {
	return ApiUsersPermissionsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedObjectPermissionList
func (a *UsersAPIService) UsersPermissionsListExecute(r ApiUsersPermissionsListRequest) (*PaginatedObjectPermissionList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedObjectPermissionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.canAdd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "can_add", r.canAdd, "")
	}
	if r.canChange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "can_change", r.canChange, "")
	}
	if r.canDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "can_delete", r.canDelete, "")
	}
	if r.canView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "can_view", r.canView, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "")
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group", t, "multi")
		}
	}
	if r.groupN != nil {
		t := *r.groupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", t, "multi")
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", t, "multi")
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.objectType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type", r.objectType, "")
	}
	if r.objectTypeIc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__ic", r.objectTypeIc, "")
	}
	if r.objectTypeIe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__ie", r.objectTypeIe, "")
	}
	if r.objectTypeIew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__iew", r.objectTypeIew, "")
	}
	if r.objectTypeIsw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__isw", r.objectTypeIsw, "")
	}
	if r.objectTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__n", r.objectTypeN, "")
	}
	if r.objectTypeNic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__nic", r.objectTypeNic, "")
	}
	if r.objectTypeNie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__nie", r.objectTypeNie, "")
	}
	if r.objectTypeNiew != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__niew", r.objectTypeNiew, "")
	}
	if r.objectTypeNisw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object_type__nisw", r.objectTypeNisw, "")
	}
	if r.objectTypeId != nil {
		t := *r.objectTypeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_type_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_type_id", t, "multi")
		}
	}
	if r.objectTypeIdN != nil {
		t := *r.objectTypeIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_type_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_type_id__n", t, "multi")
		}
	}
	if r.objectTypes != nil {
		t := *r.objectTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_types", t, "multi")
		}
	}
	if r.objectTypesN != nil {
		t := *r.objectTypesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "object_types__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "object_types__n", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user", t, "multi")
		}
	}
	if r.userN != nil {
		t := *r.userN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user__n", t, "multi")
		}
	}
	if r.userId != nil {
		t := *r.userId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", t, "multi")
		}
	}
	if r.userIdN != nil {
		t := *r.userIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_id__n", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsPartialUpdateRequest struct {
	ctx                            context.Context
	ApiService                     *UsersAPIService
	id                             int32
	patchedObjectPermissionRequest *PatchedObjectPermissionRequest
}

func (r ApiUsersPermissionsPartialUpdateRequest) PatchedObjectPermissionRequest(patchedObjectPermissionRequest PatchedObjectPermissionRequest) ApiUsersPermissionsPartialUpdateRequest {
	r.patchedObjectPermissionRequest = &patchedObjectPermissionRequest
	return r
}

func (r ApiUsersPermissionsPartialUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsPartialUpdateExecute(r)
}

/*
UsersPermissionsPartialUpdate Method for UsersPermissionsPartialUpdate

Patch a permission object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this permission.
	@return ApiUsersPermissionsPartialUpdateRequest
*/
func (a *UsersAPIService) UsersPermissionsPartialUpdate(ctx context.Context, id int32) ApiUsersPermissionsPartialUpdateRequest {
	return ApiUsersPermissionsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ObjectPermission
func (a *UsersAPIService) UsersPermissionsPartialUpdateExecute(r ApiUsersPermissionsPartialUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedObjectPermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsRetrieveRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	id         int32
}

func (r ApiUsersPermissionsRetrieveRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsRetrieveExecute(r)
}

/*
UsersPermissionsRetrieve Method for UsersPermissionsRetrieve

Get a permission object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this permission.
	@return ApiUsersPermissionsRetrieveRequest
*/
func (a *UsersAPIService) UsersPermissionsRetrieve(ctx context.Context, id int32) ApiUsersPermissionsRetrieveRequest {
	return ApiUsersPermissionsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ObjectPermission
func (a *UsersAPIService) UsersPermissionsRetrieveExecute(r ApiUsersPermissionsRetrieveRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsUpdateRequest struct {
	ctx                     context.Context
	ApiService              *UsersAPIService
	id                      int32
	objectPermissionRequest *ObjectPermissionRequest
}

func (r ApiUsersPermissionsUpdateRequest) ObjectPermissionRequest(objectPermissionRequest ObjectPermissionRequest) ApiUsersPermissionsUpdateRequest {
	r.objectPermissionRequest = &objectPermissionRequest
	return r
}

func (r ApiUsersPermissionsUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsUpdateExecute(r)
}

/*
UsersPermissionsUpdate Method for UsersPermissionsUpdate

Put a permission object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this permission.
	@return ApiUsersPermissionsUpdateRequest
*/
func (a *UsersAPIService) UsersPermissionsUpdate(ctx context.Context, id int32) ApiUsersPermissionsUpdateRequest {
	return ApiUsersPermissionsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ObjectPermission
func (a *UsersAPIService) UsersPermissionsUpdateExecute(r ApiUsersPermissionsUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersPermissionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectPermissionRequest == nil {
		return localVarReturnValue, nil, reportError("objectPermissionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectPermissionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensBulkDestroyRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	tokenRequest *[]TokenRequest
}

func (r ApiUsersTokensBulkDestroyRequest) TokenRequest(tokenRequest []TokenRequest) ApiUsersTokensBulkDestroyRequest {
	r.tokenRequest = &tokenRequest
	return r
}

func (r ApiUsersTokensBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersTokensBulkDestroyExecute(r)
}

/*
UsersTokensBulkDestroy Method for UsersTokensBulkDestroy

Delete a list of token objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersTokensBulkDestroyRequest
*/
func (a *UsersAPIService) UsersTokensBulkDestroy(ctx context.Context) ApiUsersTokensBulkDestroyRequest {
	return ApiUsersTokensBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersTokensBulkDestroyExecute(r ApiUsersTokensBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersTokensBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenRequest == nil {
		return nil, reportError("tokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTokensBulkPartialUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	tokenRequest *[]TokenRequest
}

func (r ApiUsersTokensBulkPartialUpdateRequest) TokenRequest(tokenRequest []TokenRequest) ApiUsersTokensBulkPartialUpdateRequest {
	r.tokenRequest = &tokenRequest
	return r
}

func (r ApiUsersTokensBulkPartialUpdateRequest) Execute() ([]Token, *http.Response, error) {
	return r.ApiService.UsersTokensBulkPartialUpdateExecute(r)
}

/*
UsersTokensBulkPartialUpdate Method for UsersTokensBulkPartialUpdate

Patch a list of token objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersTokensBulkPartialUpdateRequest
*/
func (a *UsersAPIService) UsersTokensBulkPartialUpdate(ctx context.Context) ApiUsersTokensBulkPartialUpdateRequest {
	return ApiUsersTokensBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Token
func (a *UsersAPIService) UsersTokensBulkPartialUpdateExecute(r ApiUsersTokensBulkPartialUpdateRequest) ([]Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersTokensBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenRequest == nil {
		return localVarReturnValue, nil, reportError("tokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensBulkUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	tokenRequest *[]TokenRequest
}

func (r ApiUsersTokensBulkUpdateRequest) TokenRequest(tokenRequest []TokenRequest) ApiUsersTokensBulkUpdateRequest {
	r.tokenRequest = &tokenRequest
	return r
}

func (r ApiUsersTokensBulkUpdateRequest) Execute() ([]Token, *http.Response, error) {
	return r.ApiService.UsersTokensBulkUpdateExecute(r)
}

/*
UsersTokensBulkUpdate Method for UsersTokensBulkUpdate

Put a list of token objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersTokensBulkUpdateRequest
*/
func (a *UsersAPIService) UsersTokensBulkUpdate(ctx context.Context) ApiUsersTokensBulkUpdateRequest {
	return ApiUsersTokensBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Token
func (a *UsersAPIService) UsersTokensBulkUpdateExecute(r ApiUsersTokensBulkUpdateRequest) ([]Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersTokensBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenRequest == nil {
		return localVarReturnValue, nil, reportError("tokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensCreateRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	tokenRequest *TokenRequest
}

func (r ApiUsersTokensCreateRequest) TokenRequest(tokenRequest TokenRequest) ApiUsersTokensCreateRequest {
	r.tokenRequest = &tokenRequest
	return r
}

func (r ApiUsersTokensCreateRequest) Execute() (*Token, *http.Response, error) {
	return r.ApiService.UsersTokensCreateExecute(r)
}

/*
UsersTokensCreate Method for UsersTokensCreate

Post a list of token objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersTokensCreateRequest
*/
func (a *UsersAPIService) UsersTokensCreate(ctx context.Context) ApiUsersTokensCreateRequest {
	return ApiUsersTokensCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Token
func (a *UsersAPIService) UsersTokensCreateExecute(r ApiUsersTokensCreateRequest) (*Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersTokensCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenRequest == nil {
		return localVarReturnValue, nil, reportError("tokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	id         int32
}

func (r ApiUsersTokensDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersTokensDestroyExecute(r)
}

/*
UsersTokensDestroy Method for UsersTokensDestroy

Delete a token object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this token.
	@return ApiUsersTokensDestroyRequest
*/
func (a *UsersAPIService) UsersTokensDestroy(ctx context.Context, id int32) ApiUsersTokensDestroyRequest {
	return ApiUsersTokensDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersTokensDestroyExecute(r ApiUsersTokensDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersTokensDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTokensListRequest struct {
	ctx              context.Context
	ApiService       *UsersAPIService
	created          *time.Time
	createdGte       *time.Time
	createdLte       *time.Time
	description      *[]string
	descriptionEmpty *bool
	descriptionIc    *[]string
	descriptionIe    *[]string
	descriptionIew   *[]string
	descriptionIsw   *[]string
	descriptionN     *[]string
	descriptionNic   *[]string
	descriptionNie   *[]string
	descriptionNiew  *[]string
	descriptionNisw  *[]string
	expires          *time.Time
	expiresGte       *time.Time
	expiresLte       *time.Time
	id               *[]int32
	idEmpty          *bool
	idGt             *[]int32
	idGte            *[]int32
	idLt             *[]int32
	idLte            *[]int32
	idN              *[]int32
	key              *[]string
	keyEmpty         *bool
	keyIc            *[]string
	keyIe            *[]string
	keyIew           *[]string
	keyIsw           *[]string
	keyN             *[]string
	keyNic           *[]string
	keyNie           *[]string
	keyNiew          *[]string
	keyNisw          *[]string
	lastUsed         *[]time.Time
	lastUsedEmpty    *bool
	lastUsedGt       *[]time.Time
	lastUsedGte      *[]time.Time
	lastUsedLt       *[]time.Time
	lastUsedLte      *[]time.Time
	lastUsedN        *[]time.Time
	limit            *int32
	offset           *int32
	ordering         *string
	q                *string
	user             *[]string
	userN            *[]string
	userId           *[]int32
	userIdN          *[]int32
	writeEnabled     *bool
}

func (r ApiUsersTokensListRequest) Created(created time.Time) ApiUsersTokensListRequest {
	r.created = &created
	return r
}

func (r ApiUsersTokensListRequest) CreatedGte(createdGte time.Time) ApiUsersTokensListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiUsersTokensListRequest) CreatedLte(createdLte time.Time) ApiUsersTokensListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiUsersTokensListRequest) Description(description []string) ApiUsersTokensListRequest {
	r.description = &description
	return r
}

func (r ApiUsersTokensListRequest) DescriptionEmpty(descriptionEmpty bool) ApiUsersTokensListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiUsersTokensListRequest) DescriptionIc(descriptionIc []string) ApiUsersTokensListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiUsersTokensListRequest) DescriptionIe(descriptionIe []string) ApiUsersTokensListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiUsersTokensListRequest) DescriptionIew(descriptionIew []string) ApiUsersTokensListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiUsersTokensListRequest) DescriptionIsw(descriptionIsw []string) ApiUsersTokensListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiUsersTokensListRequest) DescriptionN(descriptionN []string) ApiUsersTokensListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiUsersTokensListRequest) DescriptionNic(descriptionNic []string) ApiUsersTokensListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiUsersTokensListRequest) DescriptionNie(descriptionNie []string) ApiUsersTokensListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiUsersTokensListRequest) DescriptionNiew(descriptionNiew []string) ApiUsersTokensListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiUsersTokensListRequest) DescriptionNisw(descriptionNisw []string) ApiUsersTokensListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiUsersTokensListRequest) Expires(expires time.Time) ApiUsersTokensListRequest {
	r.expires = &expires
	return r
}

func (r ApiUsersTokensListRequest) ExpiresGte(expiresGte time.Time) ApiUsersTokensListRequest {
	r.expiresGte = &expiresGte
	return r
}

func (r ApiUsersTokensListRequest) ExpiresLte(expiresLte time.Time) ApiUsersTokensListRequest {
	r.expiresLte = &expiresLte
	return r
}

func (r ApiUsersTokensListRequest) Id(id []int32) ApiUsersTokensListRequest {
	r.id = &id
	return r
}

func (r ApiUsersTokensListRequest) IdEmpty(idEmpty bool) ApiUsersTokensListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiUsersTokensListRequest) IdGt(idGt []int32) ApiUsersTokensListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiUsersTokensListRequest) IdGte(idGte []int32) ApiUsersTokensListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiUsersTokensListRequest) IdLt(idLt []int32) ApiUsersTokensListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiUsersTokensListRequest) IdLte(idLte []int32) ApiUsersTokensListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiUsersTokensListRequest) IdN(idN []int32) ApiUsersTokensListRequest {
	r.idN = &idN
	return r
}

func (r ApiUsersTokensListRequest) Key(key []string) ApiUsersTokensListRequest {
	r.key = &key
	return r
}

func (r ApiUsersTokensListRequest) KeyEmpty(keyEmpty bool) ApiUsersTokensListRequest {
	r.keyEmpty = &keyEmpty
	return r
}

func (r ApiUsersTokensListRequest) KeyIc(keyIc []string) ApiUsersTokensListRequest {
	r.keyIc = &keyIc
	return r
}

func (r ApiUsersTokensListRequest) KeyIe(keyIe []string) ApiUsersTokensListRequest {
	r.keyIe = &keyIe
	return r
}

func (r ApiUsersTokensListRequest) KeyIew(keyIew []string) ApiUsersTokensListRequest {
	r.keyIew = &keyIew
	return r
}

func (r ApiUsersTokensListRequest) KeyIsw(keyIsw []string) ApiUsersTokensListRequest {
	r.keyIsw = &keyIsw
	return r
}

func (r ApiUsersTokensListRequest) KeyN(keyN []string) ApiUsersTokensListRequest {
	r.keyN = &keyN
	return r
}

func (r ApiUsersTokensListRequest) KeyNic(keyNic []string) ApiUsersTokensListRequest {
	r.keyNic = &keyNic
	return r
}

func (r ApiUsersTokensListRequest) KeyNie(keyNie []string) ApiUsersTokensListRequest {
	r.keyNie = &keyNie
	return r
}

func (r ApiUsersTokensListRequest) KeyNiew(keyNiew []string) ApiUsersTokensListRequest {
	r.keyNiew = &keyNiew
	return r
}

func (r ApiUsersTokensListRequest) KeyNisw(keyNisw []string) ApiUsersTokensListRequest {
	r.keyNisw = &keyNisw
	return r
}

func (r ApiUsersTokensListRequest) LastUsed(lastUsed []time.Time) ApiUsersTokensListRequest {
	r.lastUsed = &lastUsed
	return r
}

func (r ApiUsersTokensListRequest) LastUsedEmpty(lastUsedEmpty bool) ApiUsersTokensListRequest {
	r.lastUsedEmpty = &lastUsedEmpty
	return r
}

func (r ApiUsersTokensListRequest) LastUsedGt(lastUsedGt []time.Time) ApiUsersTokensListRequest {
	r.lastUsedGt = &lastUsedGt
	return r
}

func (r ApiUsersTokensListRequest) LastUsedGte(lastUsedGte []time.Time) ApiUsersTokensListRequest {
	r.lastUsedGte = &lastUsedGte
	return r
}

func (r ApiUsersTokensListRequest) LastUsedLt(lastUsedLt []time.Time) ApiUsersTokensListRequest {
	r.lastUsedLt = &lastUsedLt
	return r
}

func (r ApiUsersTokensListRequest) LastUsedLte(lastUsedLte []time.Time) ApiUsersTokensListRequest {
	r.lastUsedLte = &lastUsedLte
	return r
}

func (r ApiUsersTokensListRequest) LastUsedN(lastUsedN []time.Time) ApiUsersTokensListRequest {
	r.lastUsedN = &lastUsedN
	return r
}

// Number of results to return per page.
func (r ApiUsersTokensListRequest) Limit(limit int32) ApiUsersTokensListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiUsersTokensListRequest) Offset(offset int32) ApiUsersTokensListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiUsersTokensListRequest) Ordering(ordering string) ApiUsersTokensListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiUsersTokensListRequest) Q(q string) ApiUsersTokensListRequest {
	r.q = &q
	return r
}

// User (name)
func (r ApiUsersTokensListRequest) User(user []string) ApiUsersTokensListRequest {
	r.user = &user
	return r
}

// User (name)
func (r ApiUsersTokensListRequest) UserN(userN []string) ApiUsersTokensListRequest {
	r.userN = &userN
	return r
}

// User
func (r ApiUsersTokensListRequest) UserId(userId []int32) ApiUsersTokensListRequest {
	r.userId = &userId
	return r
}

// User
func (r ApiUsersTokensListRequest) UserIdN(userIdN []int32) ApiUsersTokensListRequest {
	r.userIdN = &userIdN
	return r
}

func (r ApiUsersTokensListRequest) WriteEnabled(writeEnabled bool) ApiUsersTokensListRequest {
	r.writeEnabled = &writeEnabled
	return r
}

func (r ApiUsersTokensListRequest) Execute() (*PaginatedTokenList, *http.Response, error) {
	return r.ApiService.UsersTokensListExecute(r)
}

/*
UsersTokensList Method for UsersTokensList

Get a list of token objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersTokensListRequest
*/
func (a *UsersAPIService) UsersTokensList(ctx context.Context) ApiUsersTokensListRequest {
	return ApiUsersTokensListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedTokenList
func (a *UsersAPIService) UsersTokensListExecute(r ApiUsersTokensListRequest) (*PaginatedTokenList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedTokenList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersTokensList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created", r.created, "")
	}
	if r.createdGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", r.createdGte, "")
	}
	if r.createdLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", r.createdLte, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.expires != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expires", r.expires, "")
	}
	if r.expiresGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expires__gte", r.expiresGte, "")
	}
	if r.expiresLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expires__lte", r.expiresLte, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.key != nil {
		t := *r.key
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "key", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "key", t, "multi")
		}
	}
	if r.keyEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key__empty", r.keyEmpty, "")
	}
	if r.keyIc != nil {
		t := *r.keyIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "key__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "key__ic", t, "multi")
		}
	}
	if r.keyIe != nil {
		t := *r.keyIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "key__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "key__ie", t, "multi")
		}
	}
	if r.keyIew != nil {
		t := *r.keyIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "key__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "key__iew", t, "multi")
		}
	}
	if r.keyIsw != nil {
		t := *r.keyIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "key__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "key__isw", t, "multi")
		}
	}
	if r.keyN != nil {
		t := *r.keyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "key__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "key__n", t, "multi")
		}
	}
	if r.keyNic != nil {
		t := *r.keyNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "key__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "key__nic", t, "multi")
		}
	}
	if r.keyNie != nil {
		t := *r.keyNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "key__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "key__nie", t, "multi")
		}
	}
	if r.keyNiew != nil {
		t := *r.keyNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "key__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "key__niew", t, "multi")
		}
	}
	if r.keyNisw != nil {
		t := *r.keyNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "key__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "key__nisw", t, "multi")
		}
	}
	if r.lastUsed != nil {
		t := *r.lastUsed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_used", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_used", t, "multi")
		}
	}
	if r.lastUsedEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_used__empty", r.lastUsedEmpty, "")
	}
	if r.lastUsedGt != nil {
		t := *r.lastUsedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_used__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_used__gt", t, "multi")
		}
	}
	if r.lastUsedGte != nil {
		t := *r.lastUsedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_used__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_used__gte", t, "multi")
		}
	}
	if r.lastUsedLt != nil {
		t := *r.lastUsedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_used__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_used__lt", t, "multi")
		}
	}
	if r.lastUsedLte != nil {
		t := *r.lastUsedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_used__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_used__lte", t, "multi")
		}
	}
	if r.lastUsedN != nil {
		t := *r.lastUsedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_used__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_used__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user", t, "multi")
		}
	}
	if r.userN != nil {
		t := *r.userN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user__n", t, "multi")
		}
	}
	if r.userId != nil {
		t := *r.userId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", t, "multi")
		}
	}
	if r.userIdN != nil {
		t := *r.userIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_id__n", t, "multi")
		}
	}
	if r.writeEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "write_enabled", r.writeEnabled, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensPartialUpdateRequest struct {
	ctx                 context.Context
	ApiService          *UsersAPIService
	id                  int32
	patchedTokenRequest *PatchedTokenRequest
}

func (r ApiUsersTokensPartialUpdateRequest) PatchedTokenRequest(patchedTokenRequest PatchedTokenRequest) ApiUsersTokensPartialUpdateRequest {
	r.patchedTokenRequest = &patchedTokenRequest
	return r
}

func (r ApiUsersTokensPartialUpdateRequest) Execute() (*Token, *http.Response, error) {
	return r.ApiService.UsersTokensPartialUpdateExecute(r)
}

/*
UsersTokensPartialUpdate Method for UsersTokensPartialUpdate

Patch a token object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this token.
	@return ApiUsersTokensPartialUpdateRequest
*/
func (a *UsersAPIService) UsersTokensPartialUpdate(ctx context.Context, id int32) ApiUsersTokensPartialUpdateRequest {
	return ApiUsersTokensPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Token
func (a *UsersAPIService) UsersTokensPartialUpdateExecute(r ApiUsersTokensPartialUpdateRequest) (*Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersTokensPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTokenRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensProvisionCreateRequest struct {
	ctx                   context.Context
	ApiService            *UsersAPIService
	tokenProvisionRequest *TokenProvisionRequest
}

func (r ApiUsersTokensProvisionCreateRequest) TokenProvisionRequest(tokenProvisionRequest TokenProvisionRequest) ApiUsersTokensProvisionCreateRequest {
	r.tokenProvisionRequest = &tokenProvisionRequest
	return r
}

func (r ApiUsersTokensProvisionCreateRequest) Execute() (*TokenProvision, *http.Response, error) {
	return r.ApiService.UsersTokensProvisionCreateExecute(r)
}

/*
UsersTokensProvisionCreate Method for UsersTokensProvisionCreate

Non-authenticated REST API endpoint via which a user may create a Token.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersTokensProvisionCreateRequest
*/
func (a *UsersAPIService) UsersTokensProvisionCreate(ctx context.Context) ApiUsersTokensProvisionCreateRequest {
	return ApiUsersTokensProvisionCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TokenProvision
func (a *UsersAPIService) UsersTokensProvisionCreateExecute(r ApiUsersTokensProvisionCreateRequest) (*TokenProvision, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TokenProvision
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersTokensProvisionCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/tokens/provision/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenProvisionRequest == nil {
		return localVarReturnValue, nil, reportError("tokenProvisionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenProvisionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensRetrieveRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	id         int32
}

func (r ApiUsersTokensRetrieveRequest) Execute() (*Token, *http.Response, error) {
	return r.ApiService.UsersTokensRetrieveExecute(r)
}

/*
UsersTokensRetrieve Method for UsersTokensRetrieve

Get a token object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this token.
	@return ApiUsersTokensRetrieveRequest
*/
func (a *UsersAPIService) UsersTokensRetrieve(ctx context.Context, id int32) ApiUsersTokensRetrieveRequest {
	return ApiUsersTokensRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Token
func (a *UsersAPIService) UsersTokensRetrieveExecute(r ApiUsersTokensRetrieveRequest) (*Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersTokensRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersAPIService
	id           int32
	tokenRequest *TokenRequest
}

func (r ApiUsersTokensUpdateRequest) TokenRequest(tokenRequest TokenRequest) ApiUsersTokensUpdateRequest {
	r.tokenRequest = &tokenRequest
	return r
}

func (r ApiUsersTokensUpdateRequest) Execute() (*Token, *http.Response, error) {
	return r.ApiService.UsersTokensUpdateExecute(r)
}

/*
UsersTokensUpdate Method for UsersTokensUpdate

Put a token object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this token.
	@return ApiUsersTokensUpdateRequest
*/
func (a *UsersAPIService) UsersTokensUpdate(ctx context.Context, id int32) ApiUsersTokensUpdateRequest {
	return ApiUsersTokensUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Token
func (a *UsersAPIService) UsersTokensUpdateExecute(r ApiUsersTokensUpdateRequest) (*Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersTokensUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenRequest == nil {
		return localVarReturnValue, nil, reportError("tokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersBulkDestroyRequest struct {
	ctx         context.Context
	ApiService  *UsersAPIService
	userRequest *[]UserRequest
}

func (r ApiUsersUsersBulkDestroyRequest) UserRequest(userRequest []UserRequest) ApiUsersUsersBulkDestroyRequest {
	r.userRequest = &userRequest
	return r
}

func (r ApiUsersUsersBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersUsersBulkDestroyExecute(r)
}

/*
UsersUsersBulkDestroy Method for UsersUsersBulkDestroy

Delete a list of user objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersUsersBulkDestroyRequest
*/
func (a *UsersAPIService) UsersUsersBulkDestroy(ctx context.Context) ApiUsersUsersBulkDestroyRequest {
	return ApiUsersUsersBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersUsersBulkDestroyExecute(r ApiUsersUsersBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersUsersBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userRequest == nil {
		return nil, reportError("userRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUsersBulkPartialUpdateRequest struct {
	ctx         context.Context
	ApiService  *UsersAPIService
	userRequest *[]UserRequest
}

func (r ApiUsersUsersBulkPartialUpdateRequest) UserRequest(userRequest []UserRequest) ApiUsersUsersBulkPartialUpdateRequest {
	r.userRequest = &userRequest
	return r
}

func (r ApiUsersUsersBulkPartialUpdateRequest) Execute() ([]User, *http.Response, error) {
	return r.ApiService.UsersUsersBulkPartialUpdateExecute(r)
}

/*
UsersUsersBulkPartialUpdate Method for UsersUsersBulkPartialUpdate

Patch a list of user objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersUsersBulkPartialUpdateRequest
*/
func (a *UsersAPIService) UsersUsersBulkPartialUpdate(ctx context.Context) ApiUsersUsersBulkPartialUpdateRequest {
	return ApiUsersUsersBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []User
func (a *UsersAPIService) UsersUsersBulkPartialUpdateExecute(r ApiUsersUsersBulkPartialUpdateRequest) ([]User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersUsersBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userRequest == nil {
		return localVarReturnValue, nil, reportError("userRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersBulkUpdateRequest struct {
	ctx         context.Context
	ApiService  *UsersAPIService
	userRequest *[]UserRequest
}

func (r ApiUsersUsersBulkUpdateRequest) UserRequest(userRequest []UserRequest) ApiUsersUsersBulkUpdateRequest {
	r.userRequest = &userRequest
	return r
}

func (r ApiUsersUsersBulkUpdateRequest) Execute() ([]User, *http.Response, error) {
	return r.ApiService.UsersUsersBulkUpdateExecute(r)
}

/*
UsersUsersBulkUpdate Method for UsersUsersBulkUpdate

Put a list of user objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersUsersBulkUpdateRequest
*/
func (a *UsersAPIService) UsersUsersBulkUpdate(ctx context.Context) ApiUsersUsersBulkUpdateRequest {
	return ApiUsersUsersBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []User
func (a *UsersAPIService) UsersUsersBulkUpdateExecute(r ApiUsersUsersBulkUpdateRequest) ([]User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersUsersBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userRequest == nil {
		return localVarReturnValue, nil, reportError("userRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersCreateRequest struct {
	ctx         context.Context
	ApiService  *UsersAPIService
	userRequest *UserRequest
}

func (r ApiUsersUsersCreateRequest) UserRequest(userRequest UserRequest) ApiUsersUsersCreateRequest {
	r.userRequest = &userRequest
	return r
}

func (r ApiUsersUsersCreateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersCreateExecute(r)
}

/*
UsersUsersCreate Method for UsersUsersCreate

Post a list of user objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersUsersCreateRequest
*/
func (a *UsersAPIService) UsersUsersCreate(ctx context.Context) ApiUsersUsersCreateRequest {
	return ApiUsersUsersCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return User
func (a *UsersAPIService) UsersUsersCreateExecute(r ApiUsersUsersCreateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersUsersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userRequest == nil {
		return localVarReturnValue, nil, reportError("userRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	id         int32
}

func (r ApiUsersUsersDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersUsersDestroyExecute(r)
}

/*
UsersUsersDestroy Method for UsersUsersDestroy

Delete a user object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this user.
	@return ApiUsersUsersDestroyRequest
*/
func (a *UsersAPIService) UsersUsersDestroy(ctx context.Context, id int32) ApiUsersUsersDestroyRequest {
	return ApiUsersUsersDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *UsersAPIService) UsersUsersDestroyExecute(r ApiUsersUsersDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersUsersDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUsersListRequest struct {
	ctx             context.Context
	ApiService      *UsersAPIService
	dateJoined      *[]time.Time
	dateJoinedEmpty *bool
	dateJoinedGt    *[]time.Time
	dateJoinedGte   *[]time.Time
	dateJoinedLt    *[]time.Time
	dateJoinedLte   *[]time.Time
	dateJoinedN     *[]time.Time
	email           *[]string
	emailEmpty      *bool
	emailIc         *[]string
	emailIe         *[]string
	emailIew        *[]string
	emailIsw        *[]string
	emailN          *[]string
	emailNic        *[]string
	emailNie        *[]string
	emailNiew       *[]string
	emailNisw       *[]string
	firstName       *[]string
	firstNameEmpty  *bool
	firstNameIc     *[]string
	firstNameIe     *[]string
	firstNameIew    *[]string
	firstNameIsw    *[]string
	firstNameN      *[]string
	firstNameNic    *[]string
	firstNameNie    *[]string
	firstNameNiew   *[]string
	firstNameNisw   *[]string
	group           *[]string
	groupN          *[]string
	groupId         *[]int32
	groupIdN        *[]int32
	id              *[]int32
	idEmpty         *bool
	idGt            *[]int32
	idGte           *[]int32
	idLt            *[]int32
	idLte           *[]int32
	idN             *[]int32
	isActive        *bool
	isStaff         *bool
	isSuperuser     *bool
	lastLogin       *[]time.Time
	lastLoginEmpty  *bool
	lastLoginGt     *[]time.Time
	lastLoginGte    *[]time.Time
	lastLoginLt     *[]time.Time
	lastLoginLte    *[]time.Time
	lastLoginN      *[]time.Time
	lastName        *[]string
	lastNameEmpty   *bool
	lastNameIc      *[]string
	lastNameIe      *[]string
	lastNameIew     *[]string
	lastNameIsw     *[]string
	lastNameN       *[]string
	lastNameNic     *[]string
	lastNameNie     *[]string
	lastNameNiew    *[]string
	lastNameNisw    *[]string
	limit           *int32
	offset          *int32
	ordering        *string
	permissionId    *[]int32
	permissionIdN   *[]int32
	q               *string
	username        *[]string
	usernameEmpty   *bool
	usernameIc      *[]string
	usernameIe      *[]string
	usernameIew     *[]string
	usernameIsw     *[]string
	usernameN       *[]string
	usernameNic     *[]string
	usernameNie     *[]string
	usernameNiew    *[]string
	usernameNisw    *[]string
}

func (r ApiUsersUsersListRequest) DateJoined(dateJoined []time.Time) ApiUsersUsersListRequest {
	r.dateJoined = &dateJoined
	return r
}

func (r ApiUsersUsersListRequest) DateJoinedEmpty(dateJoinedEmpty bool) ApiUsersUsersListRequest {
	r.dateJoinedEmpty = &dateJoinedEmpty
	return r
}

func (r ApiUsersUsersListRequest) DateJoinedGt(dateJoinedGt []time.Time) ApiUsersUsersListRequest {
	r.dateJoinedGt = &dateJoinedGt
	return r
}

func (r ApiUsersUsersListRequest) DateJoinedGte(dateJoinedGte []time.Time) ApiUsersUsersListRequest {
	r.dateJoinedGte = &dateJoinedGte
	return r
}

func (r ApiUsersUsersListRequest) DateJoinedLt(dateJoinedLt []time.Time) ApiUsersUsersListRequest {
	r.dateJoinedLt = &dateJoinedLt
	return r
}

func (r ApiUsersUsersListRequest) DateJoinedLte(dateJoinedLte []time.Time) ApiUsersUsersListRequest {
	r.dateJoinedLte = &dateJoinedLte
	return r
}

func (r ApiUsersUsersListRequest) DateJoinedN(dateJoinedN []time.Time) ApiUsersUsersListRequest {
	r.dateJoinedN = &dateJoinedN
	return r
}

func (r ApiUsersUsersListRequest) Email(email []string) ApiUsersUsersListRequest {
	r.email = &email
	return r
}

func (r ApiUsersUsersListRequest) EmailEmpty(emailEmpty bool) ApiUsersUsersListRequest {
	r.emailEmpty = &emailEmpty
	return r
}

func (r ApiUsersUsersListRequest) EmailIc(emailIc []string) ApiUsersUsersListRequest {
	r.emailIc = &emailIc
	return r
}

func (r ApiUsersUsersListRequest) EmailIe(emailIe []string) ApiUsersUsersListRequest {
	r.emailIe = &emailIe
	return r
}

func (r ApiUsersUsersListRequest) EmailIew(emailIew []string) ApiUsersUsersListRequest {
	r.emailIew = &emailIew
	return r
}

func (r ApiUsersUsersListRequest) EmailIsw(emailIsw []string) ApiUsersUsersListRequest {
	r.emailIsw = &emailIsw
	return r
}

func (r ApiUsersUsersListRequest) EmailN(emailN []string) ApiUsersUsersListRequest {
	r.emailN = &emailN
	return r
}

func (r ApiUsersUsersListRequest) EmailNic(emailNic []string) ApiUsersUsersListRequest {
	r.emailNic = &emailNic
	return r
}

func (r ApiUsersUsersListRequest) EmailNie(emailNie []string) ApiUsersUsersListRequest {
	r.emailNie = &emailNie
	return r
}

func (r ApiUsersUsersListRequest) EmailNiew(emailNiew []string) ApiUsersUsersListRequest {
	r.emailNiew = &emailNiew
	return r
}

func (r ApiUsersUsersListRequest) EmailNisw(emailNisw []string) ApiUsersUsersListRequest {
	r.emailNisw = &emailNisw
	return r
}

func (r ApiUsersUsersListRequest) FirstName(firstName []string) ApiUsersUsersListRequest {
	r.firstName = &firstName
	return r
}

func (r ApiUsersUsersListRequest) FirstNameEmpty(firstNameEmpty bool) ApiUsersUsersListRequest {
	r.firstNameEmpty = &firstNameEmpty
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIc(firstNameIc []string) ApiUsersUsersListRequest {
	r.firstNameIc = &firstNameIc
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIe(firstNameIe []string) ApiUsersUsersListRequest {
	r.firstNameIe = &firstNameIe
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIew(firstNameIew []string) ApiUsersUsersListRequest {
	r.firstNameIew = &firstNameIew
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIsw(firstNameIsw []string) ApiUsersUsersListRequest {
	r.firstNameIsw = &firstNameIsw
	return r
}

func (r ApiUsersUsersListRequest) FirstNameN(firstNameN []string) ApiUsersUsersListRequest {
	r.firstNameN = &firstNameN
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNic(firstNameNic []string) ApiUsersUsersListRequest {
	r.firstNameNic = &firstNameNic
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNie(firstNameNie []string) ApiUsersUsersListRequest {
	r.firstNameNie = &firstNameNie
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNiew(firstNameNiew []string) ApiUsersUsersListRequest {
	r.firstNameNiew = &firstNameNiew
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNisw(firstNameNisw []string) ApiUsersUsersListRequest {
	r.firstNameNisw = &firstNameNisw
	return r
}

// Group (name)
func (r ApiUsersUsersListRequest) Group(group []string) ApiUsersUsersListRequest {
	r.group = &group
	return r
}

// Group (name)
func (r ApiUsersUsersListRequest) GroupN(groupN []string) ApiUsersUsersListRequest {
	r.groupN = &groupN
	return r
}

// Group
func (r ApiUsersUsersListRequest) GroupId(groupId []int32) ApiUsersUsersListRequest {
	r.groupId = &groupId
	return r
}

// Group
func (r ApiUsersUsersListRequest) GroupIdN(groupIdN []int32) ApiUsersUsersListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiUsersUsersListRequest) Id(id []int32) ApiUsersUsersListRequest {
	r.id = &id
	return r
}

func (r ApiUsersUsersListRequest) IdEmpty(idEmpty bool) ApiUsersUsersListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiUsersUsersListRequest) IdGt(idGt []int32) ApiUsersUsersListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiUsersUsersListRequest) IdGte(idGte []int32) ApiUsersUsersListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiUsersUsersListRequest) IdLt(idLt []int32) ApiUsersUsersListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiUsersUsersListRequest) IdLte(idLte []int32) ApiUsersUsersListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiUsersUsersListRequest) IdN(idN []int32) ApiUsersUsersListRequest {
	r.idN = &idN
	return r
}

func (r ApiUsersUsersListRequest) IsActive(isActive bool) ApiUsersUsersListRequest {
	r.isActive = &isActive
	return r
}

func (r ApiUsersUsersListRequest) IsStaff(isStaff bool) ApiUsersUsersListRequest {
	r.isStaff = &isStaff
	return r
}

func (r ApiUsersUsersListRequest) IsSuperuser(isSuperuser bool) ApiUsersUsersListRequest {
	r.isSuperuser = &isSuperuser
	return r
}

func (r ApiUsersUsersListRequest) LastLogin(lastLogin []time.Time) ApiUsersUsersListRequest {
	r.lastLogin = &lastLogin
	return r
}

func (r ApiUsersUsersListRequest) LastLoginEmpty(lastLoginEmpty bool) ApiUsersUsersListRequest {
	r.lastLoginEmpty = &lastLoginEmpty
	return r
}

func (r ApiUsersUsersListRequest) LastLoginGt(lastLoginGt []time.Time) ApiUsersUsersListRequest {
	r.lastLoginGt = &lastLoginGt
	return r
}

func (r ApiUsersUsersListRequest) LastLoginGte(lastLoginGte []time.Time) ApiUsersUsersListRequest {
	r.lastLoginGte = &lastLoginGte
	return r
}

func (r ApiUsersUsersListRequest) LastLoginLt(lastLoginLt []time.Time) ApiUsersUsersListRequest {
	r.lastLoginLt = &lastLoginLt
	return r
}

func (r ApiUsersUsersListRequest) LastLoginLte(lastLoginLte []time.Time) ApiUsersUsersListRequest {
	r.lastLoginLte = &lastLoginLte
	return r
}

func (r ApiUsersUsersListRequest) LastLoginN(lastLoginN []time.Time) ApiUsersUsersListRequest {
	r.lastLoginN = &lastLoginN
	return r
}

func (r ApiUsersUsersListRequest) LastName(lastName []string) ApiUsersUsersListRequest {
	r.lastName = &lastName
	return r
}

func (r ApiUsersUsersListRequest) LastNameEmpty(lastNameEmpty bool) ApiUsersUsersListRequest {
	r.lastNameEmpty = &lastNameEmpty
	return r
}

func (r ApiUsersUsersListRequest) LastNameIc(lastNameIc []string) ApiUsersUsersListRequest {
	r.lastNameIc = &lastNameIc
	return r
}

func (r ApiUsersUsersListRequest) LastNameIe(lastNameIe []string) ApiUsersUsersListRequest {
	r.lastNameIe = &lastNameIe
	return r
}

func (r ApiUsersUsersListRequest) LastNameIew(lastNameIew []string) ApiUsersUsersListRequest {
	r.lastNameIew = &lastNameIew
	return r
}

func (r ApiUsersUsersListRequest) LastNameIsw(lastNameIsw []string) ApiUsersUsersListRequest {
	r.lastNameIsw = &lastNameIsw
	return r
}

func (r ApiUsersUsersListRequest) LastNameN(lastNameN []string) ApiUsersUsersListRequest {
	r.lastNameN = &lastNameN
	return r
}

func (r ApiUsersUsersListRequest) LastNameNic(lastNameNic []string) ApiUsersUsersListRequest {
	r.lastNameNic = &lastNameNic
	return r
}

func (r ApiUsersUsersListRequest) LastNameNie(lastNameNie []string) ApiUsersUsersListRequest {
	r.lastNameNie = &lastNameNie
	return r
}

func (r ApiUsersUsersListRequest) LastNameNiew(lastNameNiew []string) ApiUsersUsersListRequest {
	r.lastNameNiew = &lastNameNiew
	return r
}

func (r ApiUsersUsersListRequest) LastNameNisw(lastNameNisw []string) ApiUsersUsersListRequest {
	r.lastNameNisw = &lastNameNisw
	return r
}

// Number of results to return per page.
func (r ApiUsersUsersListRequest) Limit(limit int32) ApiUsersUsersListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiUsersUsersListRequest) Offset(offset int32) ApiUsersUsersListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiUsersUsersListRequest) Ordering(ordering string) ApiUsersUsersListRequest {
	r.ordering = &ordering
	return r
}

// Permission (ID)
func (r ApiUsersUsersListRequest) PermissionId(permissionId []int32) ApiUsersUsersListRequest {
	r.permissionId = &permissionId
	return r
}

// Permission (ID)
func (r ApiUsersUsersListRequest) PermissionIdN(permissionIdN []int32) ApiUsersUsersListRequest {
	r.permissionIdN = &permissionIdN
	return r
}

// Search
func (r ApiUsersUsersListRequest) Q(q string) ApiUsersUsersListRequest {
	r.q = &q
	return r
}

func (r ApiUsersUsersListRequest) Username(username []string) ApiUsersUsersListRequest {
	r.username = &username
	return r
}

func (r ApiUsersUsersListRequest) UsernameEmpty(usernameEmpty bool) ApiUsersUsersListRequest {
	r.usernameEmpty = &usernameEmpty
	return r
}

func (r ApiUsersUsersListRequest) UsernameIc(usernameIc []string) ApiUsersUsersListRequest {
	r.usernameIc = &usernameIc
	return r
}

func (r ApiUsersUsersListRequest) UsernameIe(usernameIe []string) ApiUsersUsersListRequest {
	r.usernameIe = &usernameIe
	return r
}

func (r ApiUsersUsersListRequest) UsernameIew(usernameIew []string) ApiUsersUsersListRequest {
	r.usernameIew = &usernameIew
	return r
}

func (r ApiUsersUsersListRequest) UsernameIsw(usernameIsw []string) ApiUsersUsersListRequest {
	r.usernameIsw = &usernameIsw
	return r
}

func (r ApiUsersUsersListRequest) UsernameN(usernameN []string) ApiUsersUsersListRequest {
	r.usernameN = &usernameN
	return r
}

func (r ApiUsersUsersListRequest) UsernameNic(usernameNic []string) ApiUsersUsersListRequest {
	r.usernameNic = &usernameNic
	return r
}

func (r ApiUsersUsersListRequest) UsernameNie(usernameNie []string) ApiUsersUsersListRequest {
	r.usernameNie = &usernameNie
	return r
}

func (r ApiUsersUsersListRequest) UsernameNiew(usernameNiew []string) ApiUsersUsersListRequest {
	r.usernameNiew = &usernameNiew
	return r
}

func (r ApiUsersUsersListRequest) UsernameNisw(usernameNisw []string) ApiUsersUsersListRequest {
	r.usernameNisw = &usernameNisw
	return r
}

func (r ApiUsersUsersListRequest) Execute() (*PaginatedUserList, *http.Response, error) {
	return r.ApiService.UsersUsersListExecute(r)
}

/*
UsersUsersList Method for UsersUsersList

Get a list of user objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUsersUsersListRequest
*/
func (a *UsersAPIService) UsersUsersList(ctx context.Context) ApiUsersUsersListRequest {
	return ApiUsersUsersListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedUserList
func (a *UsersAPIService) UsersUsersListExecute(r ApiUsersUsersListRequest) (*PaginatedUserList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedUserList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersUsersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateJoined != nil {
		t := *r.dateJoined
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined", t, "multi")
		}
	}
	if r.dateJoinedEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined__empty", r.dateJoinedEmpty, "")
	}
	if r.dateJoinedGt != nil {
		t := *r.dateJoinedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined__gt", t, "multi")
		}
	}
	if r.dateJoinedGte != nil {
		t := *r.dateJoinedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined__gte", t, "multi")
		}
	}
	if r.dateJoinedLt != nil {
		t := *r.dateJoinedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined__lt", t, "multi")
		}
	}
	if r.dateJoinedLte != nil {
		t := *r.dateJoinedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined__lte", t, "multi")
		}
	}
	if r.dateJoinedN != nil {
		t := *r.dateJoinedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_joined__n", t, "multi")
		}
	}
	if r.email != nil {
		t := *r.email
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "email", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "email", t, "multi")
		}
	}
	if r.emailEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email__empty", r.emailEmpty, "")
	}
	if r.emailIc != nil {
		t := *r.emailIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "email__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "email__ic", t, "multi")
		}
	}
	if r.emailIe != nil {
		t := *r.emailIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "email__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "email__ie", t, "multi")
		}
	}
	if r.emailIew != nil {
		t := *r.emailIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "email__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "email__iew", t, "multi")
		}
	}
	if r.emailIsw != nil {
		t := *r.emailIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "email__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "email__isw", t, "multi")
		}
	}
	if r.emailN != nil {
		t := *r.emailN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "email__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "email__n", t, "multi")
		}
	}
	if r.emailNic != nil {
		t := *r.emailNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "email__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "email__nic", t, "multi")
		}
	}
	if r.emailNie != nil {
		t := *r.emailNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "email__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "email__nie", t, "multi")
		}
	}
	if r.emailNiew != nil {
		t := *r.emailNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "email__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "email__niew", t, "multi")
		}
	}
	if r.emailNisw != nil {
		t := *r.emailNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "email__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "email__nisw", t, "multi")
		}
	}
	if r.firstName != nil {
		t := *r.firstName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "first_name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "first_name", t, "multi")
		}
	}
	if r.firstNameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__empty", r.firstNameEmpty, "")
	}
	if r.firstNameIc != nil {
		t := *r.firstNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__ic", t, "multi")
		}
	}
	if r.firstNameIe != nil {
		t := *r.firstNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__ie", t, "multi")
		}
	}
	if r.firstNameIew != nil {
		t := *r.firstNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__iew", t, "multi")
		}
	}
	if r.firstNameIsw != nil {
		t := *r.firstNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__isw", t, "multi")
		}
	}
	if r.firstNameN != nil {
		t := *r.firstNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__n", t, "multi")
		}
	}
	if r.firstNameNic != nil {
		t := *r.firstNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__nic", t, "multi")
		}
	}
	if r.firstNameNie != nil {
		t := *r.firstNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__nie", t, "multi")
		}
	}
	if r.firstNameNiew != nil {
		t := *r.firstNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__niew", t, "multi")
		}
	}
	if r.firstNameNisw != nil {
		t := *r.firstNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "first_name__nisw", t, "multi")
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group", t, "multi")
		}
	}
	if r.groupN != nil {
		t := *r.groupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", t, "multi")
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", t, "multi")
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.isActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_active", r.isActive, "")
	}
	if r.isStaff != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_staff", r.isStaff, "")
	}
	if r.isSuperuser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_superuser", r.isSuperuser, "")
	}
	if r.lastLogin != nil {
		t := *r.lastLogin
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_login", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_login", t, "multi")
		}
	}
	if r.lastLoginEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_login__empty", r.lastLoginEmpty, "")
	}
	if r.lastLoginGt != nil {
		t := *r.lastLoginGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_login__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_login__gt", t, "multi")
		}
	}
	if r.lastLoginGte != nil {
		t := *r.lastLoginGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_login__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_login__gte", t, "multi")
		}
	}
	if r.lastLoginLt != nil {
		t := *r.lastLoginLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_login__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_login__lt", t, "multi")
		}
	}
	if r.lastLoginLte != nil {
		t := *r.lastLoginLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_login__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_login__lte", t, "multi")
		}
	}
	if r.lastLoginN != nil {
		t := *r.lastLoginN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_login__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_login__n", t, "multi")
		}
	}
	if r.lastName != nil {
		t := *r.lastName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_name", t, "multi")
		}
	}
	if r.lastNameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__empty", r.lastNameEmpty, "")
	}
	if r.lastNameIc != nil {
		t := *r.lastNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__ic", t, "multi")
		}
	}
	if r.lastNameIe != nil {
		t := *r.lastNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__ie", t, "multi")
		}
	}
	if r.lastNameIew != nil {
		t := *r.lastNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__iew", t, "multi")
		}
	}
	if r.lastNameIsw != nil {
		t := *r.lastNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__isw", t, "multi")
		}
	}
	if r.lastNameN != nil {
		t := *r.lastNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__n", t, "multi")
		}
	}
	if r.lastNameNic != nil {
		t := *r.lastNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__nic", t, "multi")
		}
	}
	if r.lastNameNie != nil {
		t := *r.lastNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__nie", t, "multi")
		}
	}
	if r.lastNameNiew != nil {
		t := *r.lastNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__niew", t, "multi")
		}
	}
	if r.lastNameNisw != nil {
		t := *r.lastNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_name__nisw", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.permissionId != nil {
		t := *r.permissionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id", t, "multi")
		}
	}
	if r.permissionIdN != nil {
		t := *r.permissionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "permission_id__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.username != nil {
		t := *r.username
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "username", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "username", t, "multi")
		}
	}
	if r.usernameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username__empty", r.usernameEmpty, "")
	}
	if r.usernameIc != nil {
		t := *r.usernameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "username__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "username__ic", t, "multi")
		}
	}
	if r.usernameIe != nil {
		t := *r.usernameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "username__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "username__ie", t, "multi")
		}
	}
	if r.usernameIew != nil {
		t := *r.usernameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "username__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "username__iew", t, "multi")
		}
	}
	if r.usernameIsw != nil {
		t := *r.usernameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "username__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "username__isw", t, "multi")
		}
	}
	if r.usernameN != nil {
		t := *r.usernameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "username__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "username__n", t, "multi")
		}
	}
	if r.usernameNic != nil {
		t := *r.usernameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "username__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "username__nic", t, "multi")
		}
	}
	if r.usernameNie != nil {
		t := *r.usernameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "username__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "username__nie", t, "multi")
		}
	}
	if r.usernameNiew != nil {
		t := *r.usernameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "username__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "username__niew", t, "multi")
		}
	}
	if r.usernameNisw != nil {
		t := *r.usernameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "username__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "username__nisw", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersPartialUpdateRequest struct {
	ctx                context.Context
	ApiService         *UsersAPIService
	id                 int32
	patchedUserRequest *PatchedUserRequest
}

func (r ApiUsersUsersPartialUpdateRequest) PatchedUserRequest(patchedUserRequest PatchedUserRequest) ApiUsersUsersPartialUpdateRequest {
	r.patchedUserRequest = &patchedUserRequest
	return r
}

func (r ApiUsersUsersPartialUpdateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersPartialUpdateExecute(r)
}

/*
UsersUsersPartialUpdate Method for UsersUsersPartialUpdate

Patch a user object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this user.
	@return ApiUsersUsersPartialUpdateRequest
*/
func (a *UsersAPIService) UsersUsersPartialUpdate(ctx context.Context, id int32) ApiUsersUsersPartialUpdateRequest {
	return ApiUsersUsersPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return User
func (a *UsersAPIService) UsersUsersPartialUpdateExecute(r ApiUsersUsersPartialUpdateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersUsersPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedUserRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersRetrieveRequest struct {
	ctx        context.Context
	ApiService *UsersAPIService
	id         int32
}

func (r ApiUsersUsersRetrieveRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersRetrieveExecute(r)
}

/*
UsersUsersRetrieve Method for UsersUsersRetrieve

Get a user object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this user.
	@return ApiUsersUsersRetrieveRequest
*/
func (a *UsersAPIService) UsersUsersRetrieve(ctx context.Context, id int32) ApiUsersUsersRetrieveRequest {
	return ApiUsersUsersRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return User
func (a *UsersAPIService) UsersUsersRetrieveExecute(r ApiUsersUsersRetrieveRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersUsersRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersUpdateRequest struct {
	ctx         context.Context
	ApiService  *UsersAPIService
	id          int32
	userRequest *UserRequest
}

func (r ApiUsersUsersUpdateRequest) UserRequest(userRequest UserRequest) ApiUsersUsersUpdateRequest {
	r.userRequest = &userRequest
	return r
}

func (r ApiUsersUsersUpdateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersUpdateExecute(r)
}

/*
UsersUsersUpdate Method for UsersUsersUpdate

Put a user object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this user.
	@return ApiUsersUsersUpdateRequest
*/
func (a *UsersAPIService) UsersUsersUpdate(ctx context.Context, id int32) ApiUsersUsersUpdateRequest {
	return ApiUsersUsersUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return User
func (a *UsersAPIService) UsersUsersUpdateExecute(r ApiUsersUsersUpdateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.UsersUsersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userRequest == nil {
		return localVarReturnValue, nil, reportError("userRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
