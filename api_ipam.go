/*
NetBox REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 4.0.11 (4.0)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netbox

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
	"time"
)

// IpamAPIService IpamAPI service
type IpamAPIService service

type ApiIpamAggregatesBulkDestroyRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	aggregateRequest *[]AggregateRequest
}

func (r ApiIpamAggregatesBulkDestroyRequest) AggregateRequest(aggregateRequest []AggregateRequest) ApiIpamAggregatesBulkDestroyRequest {
	r.aggregateRequest = &aggregateRequest
	return r
}

func (r ApiIpamAggregatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAggregatesBulkDestroyExecute(r)
}

/*
IpamAggregatesBulkDestroy Method for IpamAggregatesBulkDestroy

Delete a list of aggregate objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAggregatesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamAggregatesBulkDestroy(ctx context.Context) ApiIpamAggregatesBulkDestroyRequest {
	return ApiIpamAggregatesBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAggregatesBulkDestroyExecute(r ApiIpamAggregatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aggregateRequest == nil {
		return nil, reportError("aggregateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAggregatesBulkPartialUpdateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	aggregateRequest *[]AggregateRequest
}

func (r ApiIpamAggregatesBulkPartialUpdateRequest) AggregateRequest(aggregateRequest []AggregateRequest) ApiIpamAggregatesBulkPartialUpdateRequest {
	r.aggregateRequest = &aggregateRequest
	return r
}

func (r ApiIpamAggregatesBulkPartialUpdateRequest) Execute() ([]Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesBulkPartialUpdateExecute(r)
}

/*
IpamAggregatesBulkPartialUpdate Method for IpamAggregatesBulkPartialUpdate

Patch a list of aggregate objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAggregatesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAggregatesBulkPartialUpdate(ctx context.Context) ApiIpamAggregatesBulkPartialUpdateRequest {
	return ApiIpamAggregatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Aggregate
func (a *IpamAPIService) IpamAggregatesBulkPartialUpdateExecute(r ApiIpamAggregatesBulkPartialUpdateRequest) ([]Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aggregateRequest == nil {
		return localVarReturnValue, nil, reportError("aggregateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesBulkUpdateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	aggregateRequest *[]AggregateRequest
}

func (r ApiIpamAggregatesBulkUpdateRequest) AggregateRequest(aggregateRequest []AggregateRequest) ApiIpamAggregatesBulkUpdateRequest {
	r.aggregateRequest = &aggregateRequest
	return r
}

func (r ApiIpamAggregatesBulkUpdateRequest) Execute() ([]Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesBulkUpdateExecute(r)
}

/*
IpamAggregatesBulkUpdate Method for IpamAggregatesBulkUpdate

Put a list of aggregate objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAggregatesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamAggregatesBulkUpdate(ctx context.Context) ApiIpamAggregatesBulkUpdateRequest {
	return ApiIpamAggregatesBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Aggregate
func (a *IpamAPIService) IpamAggregatesBulkUpdateExecute(r ApiIpamAggregatesBulkUpdateRequest) ([]Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aggregateRequest == nil {
		return localVarReturnValue, nil, reportError("aggregateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesCreateRequest struct {
	ctx                      context.Context
	ApiService               *IpamAPIService
	writableAggregateRequest *WritableAggregateRequest
}

func (r ApiIpamAggregatesCreateRequest) WritableAggregateRequest(writableAggregateRequest WritableAggregateRequest) ApiIpamAggregatesCreateRequest {
	r.writableAggregateRequest = &writableAggregateRequest
	return r
}

func (r ApiIpamAggregatesCreateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesCreateExecute(r)
}

/*
IpamAggregatesCreate Method for IpamAggregatesCreate

Post a list of aggregate objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAggregatesCreateRequest
*/
func (a *IpamAPIService) IpamAggregatesCreate(ctx context.Context) ApiIpamAggregatesCreateRequest {
	return ApiIpamAggregatesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Aggregate
func (a *IpamAPIService) IpamAggregatesCreateExecute(r ApiIpamAggregatesCreateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableAggregateRequest == nil {
		return localVarReturnValue, nil, reportError("writableAggregateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableAggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamAggregatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAggregatesDestroyExecute(r)
}

/*
IpamAggregatesDestroy Method for IpamAggregatesDestroy

Delete a aggregate object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this aggregate.
	@return ApiIpamAggregatesDestroyRequest
*/
func (a *IpamAPIService) IpamAggregatesDestroy(ctx context.Context, id int32) ApiIpamAggregatesDestroyRequest {
	return ApiIpamAggregatesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAggregatesDestroyExecute(r ApiIpamAggregatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAggregatesListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	dateAdded         *[]string
	dateAddedEmpty    *bool
	dateAddedGt       *[]string
	dateAddedGte      *[]string
	dateAddedLt       *[]string
	dateAddedLte      *[]string
	dateAddedN        *[]string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	family            *float32
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	modifiedByRequest *string
	offset            *int32
	ordering          *string
	prefix            *string
	q                 *string
	rir               *[]string
	rirN              *[]string
	rirId             *[]int32
	rirIdN            *[]int32
	tag               *[]string
	tagN              *[]string
	tenant            *[]string
	tenantN           *[]string
	tenantGroup       *[]string
	tenantGroupN      *[]string
	tenantGroupId     *[]string
	tenantGroupIdN    *[]string
	tenantId          *[]*int32
	tenantIdN         *[]*int32
	updatedByRequest  *string
}

func (r ApiIpamAggregatesListRequest) Created(created []time.Time) ApiIpamAggregatesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamAggregatesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedGt(createdGt []time.Time) ApiIpamAggregatesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedGte(createdGte []time.Time) ApiIpamAggregatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedLt(createdLt []time.Time) ApiIpamAggregatesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedLte(createdLte []time.Time) ApiIpamAggregatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedN(createdN []time.Time) ApiIpamAggregatesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedByRequest(createdByRequest string) ApiIpamAggregatesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamAggregatesListRequest) DateAdded(dateAdded []string) ApiIpamAggregatesListRequest {
	r.dateAdded = &dateAdded
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedEmpty(dateAddedEmpty bool) ApiIpamAggregatesListRequest {
	r.dateAddedEmpty = &dateAddedEmpty
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedGt(dateAddedGt []string) ApiIpamAggregatesListRequest {
	r.dateAddedGt = &dateAddedGt
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedGte(dateAddedGte []string) ApiIpamAggregatesListRequest {
	r.dateAddedGte = &dateAddedGte
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedLt(dateAddedLt []string) ApiIpamAggregatesListRequest {
	r.dateAddedLt = &dateAddedLt
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedLte(dateAddedLte []string) ApiIpamAggregatesListRequest {
	r.dateAddedLte = &dateAddedLte
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedN(dateAddedN []string) ApiIpamAggregatesListRequest {
	r.dateAddedN = &dateAddedN
	return r
}

func (r ApiIpamAggregatesListRequest) Description(description []string) ApiIpamAggregatesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamAggregatesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionIc(descriptionIc []string) ApiIpamAggregatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionIe(descriptionIe []string) ApiIpamAggregatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionIew(descriptionIew []string) ApiIpamAggregatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamAggregatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionN(descriptionN []string) ApiIpamAggregatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionNic(descriptionNic []string) ApiIpamAggregatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionNie(descriptionNie []string) ApiIpamAggregatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamAggregatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamAggregatesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamAggregatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamAggregatesListRequest) Family(family float32) ApiIpamAggregatesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamAggregatesListRequest) Id(id []int32) ApiIpamAggregatesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamAggregatesListRequest) IdEmpty(idEmpty bool) ApiIpamAggregatesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamAggregatesListRequest) IdGt(idGt []int32) ApiIpamAggregatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamAggregatesListRequest) IdGte(idGte []int32) ApiIpamAggregatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamAggregatesListRequest) IdLt(idLt []int32) ApiIpamAggregatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamAggregatesListRequest) IdLte(idLte []int32) ApiIpamAggregatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamAggregatesListRequest) IdN(idN []int32) ApiIpamAggregatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamAggregatesListRequest) Limit(limit int32) ApiIpamAggregatesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamAggregatesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamAggregatesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiIpamAggregatesListRequest) Offset(offset int32) ApiIpamAggregatesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamAggregatesListRequest) Ordering(ordering string) ApiIpamAggregatesListRequest {
	r.ordering = &ordering
	return r
}

// Prefix
func (r ApiIpamAggregatesListRequest) Prefix(prefix string) ApiIpamAggregatesListRequest {
	r.prefix = &prefix
	return r
}

// Search
func (r ApiIpamAggregatesListRequest) Q(q string) ApiIpamAggregatesListRequest {
	r.q = &q
	return r
}

// RIR (slug)
func (r ApiIpamAggregatesListRequest) Rir(rir []string) ApiIpamAggregatesListRequest {
	r.rir = &rir
	return r
}

// RIR (slug)
func (r ApiIpamAggregatesListRequest) RirN(rirN []string) ApiIpamAggregatesListRequest {
	r.rirN = &rirN
	return r
}

// RIR (ID)
func (r ApiIpamAggregatesListRequest) RirId(rirId []int32) ApiIpamAggregatesListRequest {
	r.rirId = &rirId
	return r
}

// RIR (ID)
func (r ApiIpamAggregatesListRequest) RirIdN(rirIdN []int32) ApiIpamAggregatesListRequest {
	r.rirIdN = &rirIdN
	return r
}

func (r ApiIpamAggregatesListRequest) Tag(tag []string) ApiIpamAggregatesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamAggregatesListRequest) TagN(tagN []string) ApiIpamAggregatesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamAggregatesListRequest) Tenant(tenant []string) ApiIpamAggregatesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamAggregatesListRequest) TenantN(tenantN []string) ApiIpamAggregatesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroup(tenantGroup []string) ApiIpamAggregatesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamAggregatesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamAggregatesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamAggregatesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamAggregatesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamAggregatesListRequest) TenantId(tenantId []*int32) ApiIpamAggregatesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamAggregatesListRequest) TenantIdN(tenantIdN []*int32) ApiIpamAggregatesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamAggregatesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamAggregatesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamAggregatesListRequest) Execute() (*PaginatedAggregateList, *http.Response, error) {
	return r.ApiService.IpamAggregatesListExecute(r)
}

/*
IpamAggregatesList Method for IpamAggregatesList

Get a list of aggregate objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAggregatesListRequest
*/
func (a *IpamAPIService) IpamAggregatesList(ctx context.Context) ApiIpamAggregatesListRequest {
	return ApiIpamAggregatesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedAggregateList
func (a *IpamAPIService) IpamAggregatesListExecute(r ApiIpamAggregatesListRequest) (*PaginatedAggregateList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedAggregateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.dateAdded != nil {
		t := *r.dateAdded
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added", t, "multi")
		}
	}
	if r.dateAddedEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__empty", r.dateAddedEmpty, "")
	}
	if r.dateAddedGt != nil {
		t := *r.dateAddedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__gt", t, "multi")
		}
	}
	if r.dateAddedGte != nil {
		t := *r.dateAddedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__gte", t, "multi")
		}
	}
	if r.dateAddedLt != nil {
		t := *r.dateAddedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__lt", t, "multi")
		}
	}
	if r.dateAddedLte != nil {
		t := *r.dateAddedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__lte", t, "multi")
		}
	}
	if r.dateAddedN != nil {
		t := *r.dateAddedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "date_added__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.family != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "family", r.family, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rir != nil {
		t := *r.rir
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir", t, "multi")
		}
	}
	if r.rirN != nil {
		t := *r.rirN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", t, "multi")
		}
	}
	if r.rirId != nil {
		t := *r.rirId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", t, "multi")
		}
	}
	if r.rirIdN != nil {
		t := *r.rirIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesPartialUpdateRequest struct {
	ctx                             context.Context
	ApiService                      *IpamAPIService
	id                              int32
	patchedWritableAggregateRequest *PatchedWritableAggregateRequest
}

func (r ApiIpamAggregatesPartialUpdateRequest) PatchedWritableAggregateRequest(patchedWritableAggregateRequest PatchedWritableAggregateRequest) ApiIpamAggregatesPartialUpdateRequest {
	r.patchedWritableAggregateRequest = &patchedWritableAggregateRequest
	return r
}

func (r ApiIpamAggregatesPartialUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesPartialUpdateExecute(r)
}

/*
IpamAggregatesPartialUpdate Method for IpamAggregatesPartialUpdate

Patch a aggregate object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this aggregate.
	@return ApiIpamAggregatesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAggregatesPartialUpdate(ctx context.Context, id int32) ApiIpamAggregatesPartialUpdateRequest {
	return ApiIpamAggregatesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Aggregate
func (a *IpamAPIService) IpamAggregatesPartialUpdateExecute(r ApiIpamAggregatesPartialUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableAggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamAggregatesRetrieveRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesRetrieveExecute(r)
}

/*
IpamAggregatesRetrieve Method for IpamAggregatesRetrieve

Get a aggregate object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this aggregate.
	@return ApiIpamAggregatesRetrieveRequest
*/
func (a *IpamAPIService) IpamAggregatesRetrieve(ctx context.Context, id int32) ApiIpamAggregatesRetrieveRequest {
	return ApiIpamAggregatesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Aggregate
func (a *IpamAPIService) IpamAggregatesRetrieveExecute(r ApiIpamAggregatesRetrieveRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesUpdateRequest struct {
	ctx                      context.Context
	ApiService               *IpamAPIService
	id                       int32
	writableAggregateRequest *WritableAggregateRequest
}

func (r ApiIpamAggregatesUpdateRequest) WritableAggregateRequest(writableAggregateRequest WritableAggregateRequest) ApiIpamAggregatesUpdateRequest {
	r.writableAggregateRequest = &writableAggregateRequest
	return r
}

func (r ApiIpamAggregatesUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesUpdateExecute(r)
}

/*
IpamAggregatesUpdate Method for IpamAggregatesUpdate

Put a aggregate object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this aggregate.
	@return ApiIpamAggregatesUpdateRequest
*/
func (a *IpamAPIService) IpamAggregatesUpdate(ctx context.Context, id int32) ApiIpamAggregatesUpdateRequest {
	return ApiIpamAggregatesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Aggregate
func (a *IpamAPIService) IpamAggregatesUpdateExecute(r ApiIpamAggregatesUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAggregatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableAggregateRequest == nil {
		return localVarReturnValue, nil, reportError("writableAggregateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableAggregateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesAvailableAsnsCreateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
	aSNRequest *[]ASNRequest
}

func (r ApiIpamAsnRangesAvailableAsnsCreateRequest) ASNRequest(aSNRequest []ASNRequest) ApiIpamAsnRangesAvailableAsnsCreateRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnRangesAvailableAsnsCreateRequest) Execute() ([]ASN, *http.Response, error) {
	return r.ApiService.IpamAsnRangesAvailableAsnsCreateExecute(r)
}

/*
IpamAsnRangesAvailableAsnsCreate Method for IpamAsnRangesAvailableAsnsCreate

Post a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamAsnRangesAvailableAsnsCreateRequest
*/
func (a *IpamAPIService) IpamAsnRangesAvailableAsnsCreate(ctx context.Context, id int32) ApiIpamAsnRangesAvailableAsnsCreateRequest {
	return ApiIpamAsnRangesAvailableAsnsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []ASN
func (a *IpamAPIService) IpamAsnRangesAvailableAsnsCreateExecute(r ApiIpamAsnRangesAvailableAsnsCreateRequest) ([]ASN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesAvailableAsnsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/available-asns/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesAvailableAsnsListRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamAsnRangesAvailableAsnsListRequest) Execute() ([]AvailableASN, *http.Response, error) {
	return r.ApiService.IpamAsnRangesAvailableAsnsListExecute(r)
}

/*
IpamAsnRangesAvailableAsnsList Method for IpamAsnRangesAvailableAsnsList

Get a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamAsnRangesAvailableAsnsListRequest
*/
func (a *IpamAPIService) IpamAsnRangesAvailableAsnsList(ctx context.Context, id int32) ApiIpamAsnRangesAvailableAsnsListRequest {
	return ApiIpamAsnRangesAvailableAsnsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []AvailableASN
func (a *IpamAPIService) IpamAsnRangesAvailableAsnsListExecute(r ApiIpamAsnRangesAvailableAsnsListRequest) ([]AvailableASN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AvailableASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesAvailableAsnsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/available-asns/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesBulkDestroyRequest struct {
	ctx             context.Context
	ApiService      *IpamAPIService
	aSNRangeRequest *[]ASNRangeRequest
}

func (r ApiIpamAsnRangesBulkDestroyRequest) ASNRangeRequest(aSNRangeRequest []ASNRangeRequest) ApiIpamAsnRangesBulkDestroyRequest {
	r.aSNRangeRequest = &aSNRangeRequest
	return r
}

func (r ApiIpamAsnRangesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAsnRangesBulkDestroyExecute(r)
}

/*
IpamAsnRangesBulkDestroy Method for IpamAsnRangesBulkDestroy

Delete a list of ASN range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnRangesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamAsnRangesBulkDestroy(ctx context.Context) ApiIpamAsnRangesBulkDestroyRequest {
	return ApiIpamAsnRangesBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAsnRangesBulkDestroyExecute(r ApiIpamAsnRangesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRangeRequest == nil {
		return nil, reportError("aSNRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAsnRangesBulkPartialUpdateRequest struct {
	ctx             context.Context
	ApiService      *IpamAPIService
	aSNRangeRequest *[]ASNRangeRequest
}

func (r ApiIpamAsnRangesBulkPartialUpdateRequest) ASNRangeRequest(aSNRangeRequest []ASNRangeRequest) ApiIpamAsnRangesBulkPartialUpdateRequest {
	r.aSNRangeRequest = &aSNRangeRequest
	return r
}

func (r ApiIpamAsnRangesBulkPartialUpdateRequest) Execute() ([]ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesBulkPartialUpdateExecute(r)
}

/*
IpamAsnRangesBulkPartialUpdate Method for IpamAsnRangesBulkPartialUpdate

Patch a list of ASN range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnRangesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAsnRangesBulkPartialUpdate(ctx context.Context) ApiIpamAsnRangesBulkPartialUpdateRequest {
	return ApiIpamAsnRangesBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ASNRange
func (a *IpamAPIService) IpamAsnRangesBulkPartialUpdateExecute(r ApiIpamAsnRangesBulkPartialUpdateRequest) ([]ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRangeRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesBulkUpdateRequest struct {
	ctx             context.Context
	ApiService      *IpamAPIService
	aSNRangeRequest *[]ASNRangeRequest
}

func (r ApiIpamAsnRangesBulkUpdateRequest) ASNRangeRequest(aSNRangeRequest []ASNRangeRequest) ApiIpamAsnRangesBulkUpdateRequest {
	r.aSNRangeRequest = &aSNRangeRequest
	return r
}

func (r ApiIpamAsnRangesBulkUpdateRequest) Execute() ([]ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesBulkUpdateExecute(r)
}

/*
IpamAsnRangesBulkUpdate Method for IpamAsnRangesBulkUpdate

Put a list of ASN range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnRangesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamAsnRangesBulkUpdate(ctx context.Context) ApiIpamAsnRangesBulkUpdateRequest {
	return ApiIpamAsnRangesBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ASNRange
func (a *IpamAPIService) IpamAsnRangesBulkUpdateExecute(r ApiIpamAsnRangesBulkUpdateRequest) ([]ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRangeRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesCreateRequest struct {
	ctx             context.Context
	ApiService      *IpamAPIService
	aSNRangeRequest *ASNRangeRequest
}

func (r ApiIpamAsnRangesCreateRequest) ASNRangeRequest(aSNRangeRequest ASNRangeRequest) ApiIpamAsnRangesCreateRequest {
	r.aSNRangeRequest = &aSNRangeRequest
	return r
}

func (r ApiIpamAsnRangesCreateRequest) Execute() (*ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesCreateExecute(r)
}

/*
IpamAsnRangesCreate Method for IpamAsnRangesCreate

Post a list of ASN range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnRangesCreateRequest
*/
func (a *IpamAPIService) IpamAsnRangesCreate(ctx context.Context) ApiIpamAsnRangesCreateRequest {
	return ApiIpamAsnRangesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ASNRange
func (a *IpamAPIService) IpamAsnRangesCreateExecute(r ApiIpamAsnRangesCreateRequest) (*ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRangeRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamAsnRangesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAsnRangesDestroyExecute(r)
}

/*
IpamAsnRangesDestroy Method for IpamAsnRangesDestroy

Delete a ASN range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN range.
	@return ApiIpamAsnRangesDestroyRequest
*/
func (a *IpamAPIService) IpamAsnRangesDestroy(ctx context.Context, id int32) ApiIpamAsnRangesDestroyRequest {
	return ApiIpamAsnRangesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAsnRangesDestroyExecute(r ApiIpamAsnRangesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAsnRangesListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	end               *[]int32
	endEmpty          *bool
	endGt             *[]int32
	endGte            *[]int32
	endLt             *[]int32
	endLte            *[]int32
	endN              *[]int32
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	modifiedByRequest *string
	name              *[]string
	nameEmpty         *bool
	nameIc            *[]string
	nameIe            *[]string
	nameIew           *[]string
	nameIsw           *[]string
	nameN             *[]string
	nameNic           *[]string
	nameNie           *[]string
	nameNiew          *[]string
	nameNisw          *[]string
	offset            *int32
	ordering          *string
	q                 *string
	rir               *[]string
	rirN              *[]string
	rirId             *[]int32
	rirIdN            *[]int32
	slug              *[]string
	slugEmpty         *bool
	slugIc            *[]string
	slugIe            *[]string
	slugIew           *[]string
	slugIsw           *[]string
	slugN             *[]string
	slugNic           *[]string
	slugNie           *[]string
	slugNiew          *[]string
	slugNisw          *[]string
	start             *[]int32
	startEmpty        *bool
	startGt           *[]int32
	startGte          *[]int32
	startLt           *[]int32
	startLte          *[]int32
	startN            *[]int32
	tag               *[]string
	tagN              *[]string
	tenant            *[]string
	tenantN           *[]string
	tenantGroup       *[]string
	tenantGroupN      *[]string
	tenantGroupId     *[]string
	tenantGroupIdN    *[]string
	tenantId          *[]*int32
	tenantIdN         *[]*int32
	updatedByRequest  *string
}

func (r ApiIpamAsnRangesListRequest) Created(created []time.Time) ApiIpamAsnRangesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamAsnRangesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedGt(createdGt []time.Time) ApiIpamAsnRangesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedGte(createdGte []time.Time) ApiIpamAsnRangesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedLt(createdLt []time.Time) ApiIpamAsnRangesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedLte(createdLte []time.Time) ApiIpamAsnRangesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedN(createdN []time.Time) ApiIpamAsnRangesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamAsnRangesListRequest) CreatedByRequest(createdByRequest string) ApiIpamAsnRangesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamAsnRangesListRequest) Description(description []string) ApiIpamAsnRangesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamAsnRangesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionIc(descriptionIc []string) ApiIpamAsnRangesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionIe(descriptionIe []string) ApiIpamAsnRangesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionIew(descriptionIew []string) ApiIpamAsnRangesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamAsnRangesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionN(descriptionN []string) ApiIpamAsnRangesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionNic(descriptionNic []string) ApiIpamAsnRangesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionNie(descriptionNie []string) ApiIpamAsnRangesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamAsnRangesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamAsnRangesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamAsnRangesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamAsnRangesListRequest) End(end []int32) ApiIpamAsnRangesListRequest {
	r.end = &end
	return r
}

func (r ApiIpamAsnRangesListRequest) EndEmpty(endEmpty bool) ApiIpamAsnRangesListRequest {
	r.endEmpty = &endEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) EndGt(endGt []int32) ApiIpamAsnRangesListRequest {
	r.endGt = &endGt
	return r
}

func (r ApiIpamAsnRangesListRequest) EndGte(endGte []int32) ApiIpamAsnRangesListRequest {
	r.endGte = &endGte
	return r
}

func (r ApiIpamAsnRangesListRequest) EndLt(endLt []int32) ApiIpamAsnRangesListRequest {
	r.endLt = &endLt
	return r
}

func (r ApiIpamAsnRangesListRequest) EndLte(endLte []int32) ApiIpamAsnRangesListRequest {
	r.endLte = &endLte
	return r
}

func (r ApiIpamAsnRangesListRequest) EndN(endN []int32) ApiIpamAsnRangesListRequest {
	r.endN = &endN
	return r
}

func (r ApiIpamAsnRangesListRequest) Id(id []int32) ApiIpamAsnRangesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamAsnRangesListRequest) IdEmpty(idEmpty bool) ApiIpamAsnRangesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) IdGt(idGt []int32) ApiIpamAsnRangesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamAsnRangesListRequest) IdGte(idGte []int32) ApiIpamAsnRangesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamAsnRangesListRequest) IdLt(idLt []int32) ApiIpamAsnRangesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamAsnRangesListRequest) IdLte(idLte []int32) ApiIpamAsnRangesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamAsnRangesListRequest) IdN(idN []int32) ApiIpamAsnRangesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamAsnRangesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamAsnRangesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamAsnRangesListRequest) Limit(limit int32) ApiIpamAsnRangesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamAsnRangesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamAsnRangesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamAsnRangesListRequest) Name(name []string) ApiIpamAsnRangesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamAsnRangesListRequest) NameEmpty(nameEmpty bool) ApiIpamAsnRangesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) NameIc(nameIc []string) ApiIpamAsnRangesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamAsnRangesListRequest) NameIe(nameIe []string) ApiIpamAsnRangesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamAsnRangesListRequest) NameIew(nameIew []string) ApiIpamAsnRangesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamAsnRangesListRequest) NameIsw(nameIsw []string) ApiIpamAsnRangesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamAsnRangesListRequest) NameN(nameN []string) ApiIpamAsnRangesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamAsnRangesListRequest) NameNic(nameNic []string) ApiIpamAsnRangesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamAsnRangesListRequest) NameNie(nameNie []string) ApiIpamAsnRangesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamAsnRangesListRequest) NameNiew(nameNiew []string) ApiIpamAsnRangesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamAsnRangesListRequest) NameNisw(nameNisw []string) ApiIpamAsnRangesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamAsnRangesListRequest) Offset(offset int32) ApiIpamAsnRangesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamAsnRangesListRequest) Ordering(ordering string) ApiIpamAsnRangesListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamAsnRangesListRequest) Q(q string) ApiIpamAsnRangesListRequest {
	r.q = &q
	return r
}

// RIR (slug)
func (r ApiIpamAsnRangesListRequest) Rir(rir []string) ApiIpamAsnRangesListRequest {
	r.rir = &rir
	return r
}

// RIR (slug)
func (r ApiIpamAsnRangesListRequest) RirN(rirN []string) ApiIpamAsnRangesListRequest {
	r.rirN = &rirN
	return r
}

// RIR (ID)
func (r ApiIpamAsnRangesListRequest) RirId(rirId []int32) ApiIpamAsnRangesListRequest {
	r.rirId = &rirId
	return r
}

// RIR (ID)
func (r ApiIpamAsnRangesListRequest) RirIdN(rirIdN []int32) ApiIpamAsnRangesListRequest {
	r.rirIdN = &rirIdN
	return r
}

func (r ApiIpamAsnRangesListRequest) Slug(slug []string) ApiIpamAsnRangesListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugEmpty(slugEmpty bool) ApiIpamAsnRangesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugIc(slugIc []string) ApiIpamAsnRangesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugIe(slugIe []string) ApiIpamAsnRangesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugIew(slugIew []string) ApiIpamAsnRangesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugIsw(slugIsw []string) ApiIpamAsnRangesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugN(slugN []string) ApiIpamAsnRangesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugNic(slugNic []string) ApiIpamAsnRangesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugNie(slugNie []string) ApiIpamAsnRangesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugNiew(slugNiew []string) ApiIpamAsnRangesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamAsnRangesListRequest) SlugNisw(slugNisw []string) ApiIpamAsnRangesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamAsnRangesListRequest) Start(start []int32) ApiIpamAsnRangesListRequest {
	r.start = &start
	return r
}

func (r ApiIpamAsnRangesListRequest) StartEmpty(startEmpty bool) ApiIpamAsnRangesListRequest {
	r.startEmpty = &startEmpty
	return r
}

func (r ApiIpamAsnRangesListRequest) StartGt(startGt []int32) ApiIpamAsnRangesListRequest {
	r.startGt = &startGt
	return r
}

func (r ApiIpamAsnRangesListRequest) StartGte(startGte []int32) ApiIpamAsnRangesListRequest {
	r.startGte = &startGte
	return r
}

func (r ApiIpamAsnRangesListRequest) StartLt(startLt []int32) ApiIpamAsnRangesListRequest {
	r.startLt = &startLt
	return r
}

func (r ApiIpamAsnRangesListRequest) StartLte(startLte []int32) ApiIpamAsnRangesListRequest {
	r.startLte = &startLte
	return r
}

func (r ApiIpamAsnRangesListRequest) StartN(startN []int32) ApiIpamAsnRangesListRequest {
	r.startN = &startN
	return r
}

func (r ApiIpamAsnRangesListRequest) Tag(tag []string) ApiIpamAsnRangesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamAsnRangesListRequest) TagN(tagN []string) ApiIpamAsnRangesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamAsnRangesListRequest) Tenant(tenant []string) ApiIpamAsnRangesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamAsnRangesListRequest) TenantN(tenantN []string) ApiIpamAsnRangesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamAsnRangesListRequest) TenantGroup(tenantGroup []string) ApiIpamAsnRangesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamAsnRangesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamAsnRangesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamAsnRangesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamAsnRangesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamAsnRangesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamAsnRangesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamAsnRangesListRequest) TenantId(tenantId []*int32) ApiIpamAsnRangesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamAsnRangesListRequest) TenantIdN(tenantIdN []*int32) ApiIpamAsnRangesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamAsnRangesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamAsnRangesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamAsnRangesListRequest) Execute() (*PaginatedASNRangeList, *http.Response, error) {
	return r.ApiService.IpamAsnRangesListExecute(r)
}

/*
IpamAsnRangesList Method for IpamAsnRangesList

Get a list of ASN range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnRangesListRequest
*/
func (a *IpamAPIService) IpamAsnRangesList(ctx context.Context) ApiIpamAsnRangesListRequest {
	return ApiIpamAsnRangesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedASNRangeList
func (a *IpamAPIService) IpamAsnRangesListExecute(r ApiIpamAsnRangesListRequest) (*PaginatedASNRangeList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedASNRangeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.end != nil {
		t := *r.end
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end", t, "multi")
		}
	}
	if r.endEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end__empty", r.endEmpty, "")
	}
	if r.endGt != nil {
		t := *r.endGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end__gt", t, "multi")
		}
	}
	if r.endGte != nil {
		t := *r.endGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end__gte", t, "multi")
		}
	}
	if r.endLt != nil {
		t := *r.endLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end__lt", t, "multi")
		}
	}
	if r.endLte != nil {
		t := *r.endLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end__lte", t, "multi")
		}
	}
	if r.endN != nil {
		t := *r.endN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end__n", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rir != nil {
		t := *r.rir
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir", t, "multi")
		}
	}
	if r.rirN != nil {
		t := *r.rirN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", t, "multi")
		}
	}
	if r.rirId != nil {
		t := *r.rirId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", t, "multi")
		}
	}
	if r.rirIdN != nil {
		t := *r.rirIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", t, "multi")
		}
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug", t, "multi")
		}
	}
	if r.slugEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slug__empty", r.slugEmpty, "")
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", t, "multi")
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", t, "multi")
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", t, "multi")
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", t, "multi")
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", t, "multi")
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", t, "multi")
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", t, "multi")
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", t, "multi")
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", t, "multi")
		}
	}
	if r.start != nil {
		t := *r.start
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start", t, "multi")
		}
	}
	if r.startEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start__empty", r.startEmpty, "")
	}
	if r.startGt != nil {
		t := *r.startGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start__gt", t, "multi")
		}
	}
	if r.startGte != nil {
		t := *r.startGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start__gte", t, "multi")
		}
	}
	if r.startLt != nil {
		t := *r.startLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start__lt", t, "multi")
		}
	}
	if r.startLte != nil {
		t := *r.startLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start__lte", t, "multi")
		}
	}
	if r.startN != nil {
		t := *r.startN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start__n", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesPartialUpdateRequest struct {
	ctx                    context.Context
	ApiService             *IpamAPIService
	id                     int32
	patchedASNRangeRequest *PatchedASNRangeRequest
}

func (r ApiIpamAsnRangesPartialUpdateRequest) PatchedASNRangeRequest(patchedASNRangeRequest PatchedASNRangeRequest) ApiIpamAsnRangesPartialUpdateRequest {
	r.patchedASNRangeRequest = &patchedASNRangeRequest
	return r
}

func (r ApiIpamAsnRangesPartialUpdateRequest) Execute() (*ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesPartialUpdateExecute(r)
}

/*
IpamAsnRangesPartialUpdate Method for IpamAsnRangesPartialUpdate

Patch a ASN range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN range.
	@return ApiIpamAsnRangesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAsnRangesPartialUpdate(ctx context.Context, id int32) ApiIpamAsnRangesPartialUpdateRequest {
	return ApiIpamAsnRangesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ASNRange
func (a *IpamAPIService) IpamAsnRangesPartialUpdateExecute(r ApiIpamAsnRangesPartialUpdateRequest) (*ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedASNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamAsnRangesRetrieveRequest) Execute() (*ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesRetrieveExecute(r)
}

/*
IpamAsnRangesRetrieve Method for IpamAsnRangesRetrieve

Get a ASN range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN range.
	@return ApiIpamAsnRangesRetrieveRequest
*/
func (a *IpamAPIService) IpamAsnRangesRetrieve(ctx context.Context, id int32) ApiIpamAsnRangesRetrieveRequest {
	return ApiIpamAsnRangesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ASNRange
func (a *IpamAPIService) IpamAsnRangesRetrieveExecute(r ApiIpamAsnRangesRetrieveRequest) (*ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnRangesUpdateRequest struct {
	ctx             context.Context
	ApiService      *IpamAPIService
	id              int32
	aSNRangeRequest *ASNRangeRequest
}

func (r ApiIpamAsnRangesUpdateRequest) ASNRangeRequest(aSNRangeRequest ASNRangeRequest) ApiIpamAsnRangesUpdateRequest {
	r.aSNRangeRequest = &aSNRangeRequest
	return r
}

func (r ApiIpamAsnRangesUpdateRequest) Execute() (*ASNRange, *http.Response, error) {
	return r.ApiService.IpamAsnRangesUpdateExecute(r)
}

/*
IpamAsnRangesUpdate Method for IpamAsnRangesUpdate

Put a ASN range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN range.
	@return ApiIpamAsnRangesUpdateRequest
*/
func (a *IpamAPIService) IpamAsnRangesUpdate(ctx context.Context, id int32) ApiIpamAsnRangesUpdateRequest {
	return ApiIpamAsnRangesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ASNRange
func (a *IpamAPIService) IpamAsnRangesUpdateExecute(r ApiIpamAsnRangesUpdateRequest) (*ASNRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ASNRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnRangesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asn-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRangeRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsBulkDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	aSNRequest *[]ASNRequest
}

func (r ApiIpamAsnsBulkDestroyRequest) ASNRequest(aSNRequest []ASNRequest) ApiIpamAsnsBulkDestroyRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAsnsBulkDestroyExecute(r)
}

/*
IpamAsnsBulkDestroy Method for IpamAsnsBulkDestroy

Delete a list of ASN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamAsnsBulkDestroy(ctx context.Context) ApiIpamAsnsBulkDestroyRequest {
	return ApiIpamAsnsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAsnsBulkDestroyExecute(r ApiIpamAsnsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAsnsBulkPartialUpdateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	aSNRequest *[]ASNRequest
}

func (r ApiIpamAsnsBulkPartialUpdateRequest) ASNRequest(aSNRequest []ASNRequest) ApiIpamAsnsBulkPartialUpdateRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnsBulkPartialUpdateRequest) Execute() ([]ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsBulkPartialUpdateExecute(r)
}

/*
IpamAsnsBulkPartialUpdate Method for IpamAsnsBulkPartialUpdate

Patch a list of ASN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAsnsBulkPartialUpdate(ctx context.Context) ApiIpamAsnsBulkPartialUpdateRequest {
	return ApiIpamAsnsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ASN
func (a *IpamAPIService) IpamAsnsBulkPartialUpdateExecute(r ApiIpamAsnsBulkPartialUpdateRequest) ([]ASN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsBulkUpdateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	aSNRequest *[]ASNRequest
}

func (r ApiIpamAsnsBulkUpdateRequest) ASNRequest(aSNRequest []ASNRequest) ApiIpamAsnsBulkUpdateRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnsBulkUpdateRequest) Execute() ([]ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsBulkUpdateExecute(r)
}

/*
IpamAsnsBulkUpdate Method for IpamAsnsBulkUpdate

Put a list of ASN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamAsnsBulkUpdate(ctx context.Context) ApiIpamAsnsBulkUpdateRequest {
	return ApiIpamAsnsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ASN
func (a *IpamAPIService) IpamAsnsBulkUpdateExecute(r ApiIpamAsnsBulkUpdateRequest) ([]ASN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsCreateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	aSNRequest *ASNRequest
}

func (r ApiIpamAsnsCreateRequest) ASNRequest(aSNRequest ASNRequest) ApiIpamAsnsCreateRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnsCreateRequest) Execute() (*ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsCreateExecute(r)
}

/*
IpamAsnsCreate Method for IpamAsnsCreate

Post a list of ASN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnsCreateRequest
*/
func (a *IpamAPIService) IpamAsnsCreate(ctx context.Context) ApiIpamAsnsCreateRequest {
	return ApiIpamAsnsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ASN
func (a *IpamAPIService) IpamAsnsCreateExecute(r ApiIpamAsnsCreateRequest) (*ASN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamAsnsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAsnsDestroyExecute(r)
}

/*
IpamAsnsDestroy Method for IpamAsnsDestroy

Delete a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN.
	@return ApiIpamAsnsDestroyRequest
*/
func (a *IpamAPIService) IpamAsnsDestroy(ctx context.Context, id int32) ApiIpamAsnsDestroyRequest {
	return ApiIpamAsnsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamAsnsDestroyExecute(r ApiIpamAsnsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAsnsListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	asn               *[]int32
	asnEmpty          *bool
	asnGt             *[]int32
	asnGte            *[]int32
	asnLt             *[]int32
	asnLte            *[]int32
	asnN              *[]int32
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	modifiedByRequest *string
	offset            *int32
	ordering          *string
	provider          *[]string
	providerN         *[]string
	providerId        *[]int32
	providerIdN       *[]int32
	q                 *string
	rir               *[]string
	rirN              *[]string
	rirId             *[]int32
	rirIdN            *[]int32
	site              *[]string
	siteN             *[]string
	siteId            *[]int32
	siteIdN           *[]int32
	tag               *[]string
	tagN              *[]string
	tenant            *[]string
	tenantN           *[]string
	tenantGroup       *[]string
	tenantGroupN      *[]string
	tenantGroupId     *[]string
	tenantGroupIdN    *[]string
	tenantId          *[]*int32
	tenantIdN         *[]*int32
	updatedByRequest  *string
}

func (r ApiIpamAsnsListRequest) Asn(asn []int32) ApiIpamAsnsListRequest {
	r.asn = &asn
	return r
}

func (r ApiIpamAsnsListRequest) AsnEmpty(asnEmpty bool) ApiIpamAsnsListRequest {
	r.asnEmpty = &asnEmpty
	return r
}

func (r ApiIpamAsnsListRequest) AsnGt(asnGt []int32) ApiIpamAsnsListRequest {
	r.asnGt = &asnGt
	return r
}

func (r ApiIpamAsnsListRequest) AsnGte(asnGte []int32) ApiIpamAsnsListRequest {
	r.asnGte = &asnGte
	return r
}

func (r ApiIpamAsnsListRequest) AsnLt(asnLt []int32) ApiIpamAsnsListRequest {
	r.asnLt = &asnLt
	return r
}

func (r ApiIpamAsnsListRequest) AsnLte(asnLte []int32) ApiIpamAsnsListRequest {
	r.asnLte = &asnLte
	return r
}

func (r ApiIpamAsnsListRequest) AsnN(asnN []int32) ApiIpamAsnsListRequest {
	r.asnN = &asnN
	return r
}

func (r ApiIpamAsnsListRequest) Created(created []time.Time) ApiIpamAsnsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamAsnsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamAsnsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamAsnsListRequest) CreatedGt(createdGt []time.Time) ApiIpamAsnsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamAsnsListRequest) CreatedGte(createdGte []time.Time) ApiIpamAsnsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamAsnsListRequest) CreatedLt(createdLt []time.Time) ApiIpamAsnsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamAsnsListRequest) CreatedLte(createdLte []time.Time) ApiIpamAsnsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamAsnsListRequest) CreatedN(createdN []time.Time) ApiIpamAsnsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamAsnsListRequest) CreatedByRequest(createdByRequest string) ApiIpamAsnsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamAsnsListRequest) Description(description []string) ApiIpamAsnsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamAsnsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionIc(descriptionIc []string) ApiIpamAsnsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionIe(descriptionIe []string) ApiIpamAsnsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionIew(descriptionIew []string) ApiIpamAsnsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamAsnsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionN(descriptionN []string) ApiIpamAsnsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionNic(descriptionNic []string) ApiIpamAsnsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionNie(descriptionNie []string) ApiIpamAsnsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamAsnsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamAsnsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamAsnsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamAsnsListRequest) Id(id []int32) ApiIpamAsnsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamAsnsListRequest) IdEmpty(idEmpty bool) ApiIpamAsnsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamAsnsListRequest) IdGt(idGt []int32) ApiIpamAsnsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamAsnsListRequest) IdGte(idGte []int32) ApiIpamAsnsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamAsnsListRequest) IdLt(idLt []int32) ApiIpamAsnsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamAsnsListRequest) IdLte(idLte []int32) ApiIpamAsnsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamAsnsListRequest) IdN(idN []int32) ApiIpamAsnsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamAsnsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamAsnsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamAsnsListRequest) Limit(limit int32) ApiIpamAsnsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamAsnsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamAsnsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiIpamAsnsListRequest) Offset(offset int32) ApiIpamAsnsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamAsnsListRequest) Ordering(ordering string) ApiIpamAsnsListRequest {
	r.ordering = &ordering
	return r
}

// Provider (slug)
func (r ApiIpamAsnsListRequest) Provider(provider []string) ApiIpamAsnsListRequest {
	r.provider = &provider
	return r
}

// Provider (slug)
func (r ApiIpamAsnsListRequest) ProviderN(providerN []string) ApiIpamAsnsListRequest {
	r.providerN = &providerN
	return r
}

// Provider (ID)
func (r ApiIpamAsnsListRequest) ProviderId(providerId []int32) ApiIpamAsnsListRequest {
	r.providerId = &providerId
	return r
}

// Provider (ID)
func (r ApiIpamAsnsListRequest) ProviderIdN(providerIdN []int32) ApiIpamAsnsListRequest {
	r.providerIdN = &providerIdN
	return r
}

// Search
func (r ApiIpamAsnsListRequest) Q(q string) ApiIpamAsnsListRequest {
	r.q = &q
	return r
}

// RIR (slug)
func (r ApiIpamAsnsListRequest) Rir(rir []string) ApiIpamAsnsListRequest {
	r.rir = &rir
	return r
}

// RIR (slug)
func (r ApiIpamAsnsListRequest) RirN(rirN []string) ApiIpamAsnsListRequest {
	r.rirN = &rirN
	return r
}

// RIR (ID)
func (r ApiIpamAsnsListRequest) RirId(rirId []int32) ApiIpamAsnsListRequest {
	r.rirId = &rirId
	return r
}

// RIR (ID)
func (r ApiIpamAsnsListRequest) RirIdN(rirIdN []int32) ApiIpamAsnsListRequest {
	r.rirIdN = &rirIdN
	return r
}

// Site (slug)
func (r ApiIpamAsnsListRequest) Site(site []string) ApiIpamAsnsListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiIpamAsnsListRequest) SiteN(siteN []string) ApiIpamAsnsListRequest {
	r.siteN = &siteN
	return r
}

// Site (ID)
func (r ApiIpamAsnsListRequest) SiteId(siteId []int32) ApiIpamAsnsListRequest {
	r.siteId = &siteId
	return r
}

// Site (ID)
func (r ApiIpamAsnsListRequest) SiteIdN(siteIdN []int32) ApiIpamAsnsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiIpamAsnsListRequest) Tag(tag []string) ApiIpamAsnsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamAsnsListRequest) TagN(tagN []string) ApiIpamAsnsListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamAsnsListRequest) Tenant(tenant []string) ApiIpamAsnsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamAsnsListRequest) TenantN(tenantN []string) ApiIpamAsnsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamAsnsListRequest) TenantGroup(tenantGroup []string) ApiIpamAsnsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamAsnsListRequest) TenantGroupN(tenantGroupN []string) ApiIpamAsnsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamAsnsListRequest) TenantGroupId(tenantGroupId []string) ApiIpamAsnsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamAsnsListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamAsnsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamAsnsListRequest) TenantId(tenantId []*int32) ApiIpamAsnsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamAsnsListRequest) TenantIdN(tenantIdN []*int32) ApiIpamAsnsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamAsnsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamAsnsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamAsnsListRequest) Execute() (*PaginatedASNList, *http.Response, error) {
	return r.ApiService.IpamAsnsListExecute(r)
}

/*
IpamAsnsList Method for IpamAsnsList

Get a list of ASN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamAsnsListRequest
*/
func (a *IpamAPIService) IpamAsnsList(ctx context.Context) ApiIpamAsnsListRequest {
	return ApiIpamAsnsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedASNList
func (a *IpamAPIService) IpamAsnsListExecute(r ApiIpamAsnsListRequest) (*PaginatedASNList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedASNList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asn != nil {
		t := *r.asn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn", t, "multi")
		}
	}
	if r.asnEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asn__empty", r.asnEmpty, "")
	}
	if r.asnGt != nil {
		t := *r.asnGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gt", t, "multi")
		}
	}
	if r.asnGte != nil {
		t := *r.asnGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__gte", t, "multi")
		}
	}
	if r.asnLt != nil {
		t := *r.asnLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lt", t, "multi")
		}
	}
	if r.asnLte != nil {
		t := *r.asnLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__lte", t, "multi")
		}
	}
	if r.asnN != nil {
		t := *r.asnN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "asn__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "asn__n", t, "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.provider != nil {
		t := *r.provider
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "provider", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "provider", t, "multi")
		}
	}
	if r.providerN != nil {
		t := *r.providerN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "provider__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "provider__n", t, "multi")
		}
	}
	if r.providerId != nil {
		t := *r.providerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "provider_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "provider_id", t, "multi")
		}
	}
	if r.providerIdN != nil {
		t := *r.providerIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "provider_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "provider_id__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rir != nil {
		t := *r.rir
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir", t, "multi")
		}
	}
	if r.rirN != nil {
		t := *r.rirN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir__n", t, "multi")
		}
	}
	if r.rirId != nil {
		t := *r.rirId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id", t, "multi")
		}
	}
	if r.rirIdN != nil {
		t := *r.rirIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rir_id__n", t, "multi")
		}
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site", t, "multi")
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", t, "multi")
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", t, "multi")
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsPartialUpdateRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	id                int32
	patchedASNRequest *PatchedASNRequest
}

func (r ApiIpamAsnsPartialUpdateRequest) PatchedASNRequest(patchedASNRequest PatchedASNRequest) ApiIpamAsnsPartialUpdateRequest {
	r.patchedASNRequest = &patchedASNRequest
	return r
}

func (r ApiIpamAsnsPartialUpdateRequest) Execute() (*ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsPartialUpdateExecute(r)
}

/*
IpamAsnsPartialUpdate Method for IpamAsnsPartialUpdate

Patch a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN.
	@return ApiIpamAsnsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamAsnsPartialUpdate(ctx context.Context, id int32) ApiIpamAsnsPartialUpdateRequest {
	return ApiIpamAsnsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ASN
func (a *IpamAPIService) IpamAsnsPartialUpdateExecute(r ApiIpamAsnsPartialUpdateRequest) (*ASN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedASNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamAsnsRetrieveRequest) Execute() (*ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsRetrieveExecute(r)
}

/*
IpamAsnsRetrieve Method for IpamAsnsRetrieve

Get a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN.
	@return ApiIpamAsnsRetrieveRequest
*/
func (a *IpamAPIService) IpamAsnsRetrieve(ctx context.Context, id int32) ApiIpamAsnsRetrieveRequest {
	return ApiIpamAsnsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ASN
func (a *IpamAPIService) IpamAsnsRetrieveExecute(r ApiIpamAsnsRetrieveRequest) (*ASN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAsnsUpdateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
	aSNRequest *ASNRequest
}

func (r ApiIpamAsnsUpdateRequest) ASNRequest(aSNRequest ASNRequest) ApiIpamAsnsUpdateRequest {
	r.aSNRequest = &aSNRequest
	return r
}

func (r ApiIpamAsnsUpdateRequest) Execute() (*ASN, *http.Response, error) {
	return r.ApiService.IpamAsnsUpdateExecute(r)
}

/*
IpamAsnsUpdate Method for IpamAsnsUpdate

Put a ASN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this ASN.
	@return ApiIpamAsnsUpdateRequest
*/
func (a *IpamAPIService) IpamAsnsUpdate(ctx context.Context, id int32) ApiIpamAsnsUpdateRequest {
	return ApiIpamAsnsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ASN
func (a *IpamAPIService) IpamAsnsUpdateExecute(r ApiIpamAsnsUpdateRequest) (*ASN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ASN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamAsnsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/asns/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aSNRequest == nil {
		return localVarReturnValue, nil, reportError("aSNRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aSNRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsBulkDestroyRequest struct {
	ctx                        context.Context
	ApiService                 *IpamAPIService
	fHRPGroupAssignmentRequest *[]FHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsBulkDestroyRequest) FHRPGroupAssignmentRequest(fHRPGroupAssignmentRequest []FHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsBulkDestroyRequest {
	r.fHRPGroupAssignmentRequest = &fHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsBulkDestroyExecute(r)
}

/*
IpamFhrpGroupAssignmentsBulkDestroy Method for IpamFhrpGroupAssignmentsBulkDestroy

Delete a list of FHRP group assignment objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupAssignmentsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkDestroy(ctx context.Context) ApiIpamFhrpGroupAssignmentsBulkDestroyRequest {
	return ApiIpamFhrpGroupAssignmentsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkDestroyExecute(r ApiIpamFhrpGroupAssignmentsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupAssignmentRequest == nil {
		return nil, reportError("fHRPGroupAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest struct {
	ctx                        context.Context
	ApiService                 *IpamAPIService
	fHRPGroupAssignmentRequest *[]FHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest) FHRPGroupAssignmentRequest(fHRPGroupAssignmentRequest []FHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest {
	r.fHRPGroupAssignmentRequest = &fHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest) Execute() ([]FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsBulkPartialUpdateExecute(r)
}

/*
IpamFhrpGroupAssignmentsBulkPartialUpdate Method for IpamFhrpGroupAssignmentsBulkPartialUpdate

Patch a list of FHRP group assignment objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkPartialUpdate(ctx context.Context) ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest {
	return ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkPartialUpdateExecute(r ApiIpamFhrpGroupAssignmentsBulkPartialUpdateRequest) ([]FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsBulkUpdateRequest struct {
	ctx                        context.Context
	ApiService                 *IpamAPIService
	fHRPGroupAssignmentRequest *[]FHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsBulkUpdateRequest) FHRPGroupAssignmentRequest(fHRPGroupAssignmentRequest []FHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsBulkUpdateRequest {
	r.fHRPGroupAssignmentRequest = &fHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsBulkUpdateRequest) Execute() ([]FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsBulkUpdateExecute(r)
}

/*
IpamFhrpGroupAssignmentsBulkUpdate Method for IpamFhrpGroupAssignmentsBulkUpdate

Put a list of FHRP group assignment objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupAssignmentsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkUpdate(ctx context.Context) ApiIpamFhrpGroupAssignmentsBulkUpdateRequest {
	return ApiIpamFhrpGroupAssignmentsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsBulkUpdateExecute(r ApiIpamFhrpGroupAssignmentsBulkUpdateRequest) ([]FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsCreateRequest struct {
	ctx                        context.Context
	ApiService                 *IpamAPIService
	fHRPGroupAssignmentRequest *FHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsCreateRequest) FHRPGroupAssignmentRequest(fHRPGroupAssignmentRequest FHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsCreateRequest {
	r.fHRPGroupAssignmentRequest = &fHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsCreateRequest) Execute() (*FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsCreateExecute(r)
}

/*
IpamFhrpGroupAssignmentsCreate Method for IpamFhrpGroupAssignmentsCreate

Post a list of FHRP group assignment objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupAssignmentsCreateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsCreate(ctx context.Context) ApiIpamFhrpGroupAssignmentsCreateRequest {
	return ApiIpamFhrpGroupAssignmentsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsCreateExecute(r ApiIpamFhrpGroupAssignmentsCreateRequest) (*FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamFhrpGroupAssignmentsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsDestroyExecute(r)
}

/*
IpamFhrpGroupAssignmentsDestroy Method for IpamFhrpGroupAssignmentsDestroy

Delete a FHRP group assignment object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group assignment.
	@return ApiIpamFhrpGroupAssignmentsDestroyRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsDestroy(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsDestroyRequest {
	return ApiIpamFhrpGroupAssignmentsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamFhrpGroupAssignmentsDestroyExecute(r ApiIpamFhrpGroupAssignmentsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	device            *[]string
	deviceId          *[]int32
	groupId           *[]int32
	groupIdN          *[]int32
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	interfaceId       *[]int32
	interfaceIdEmpty  *bool
	interfaceIdGt     *[]int32
	interfaceIdGte    *[]int32
	interfaceIdLt     *[]int32
	interfaceIdLte    *[]int32
	interfaceIdN      *[]int32
	interfaceType     *string
	interfaceTypeN    *string
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	modifiedByRequest *string
	offset            *int32
	ordering          *string
	priority          *[]int32
	priorityEmpty     *bool
	priorityGt        *[]int32
	priorityGte       *[]int32
	priorityLt        *[]int32
	priorityLte       *[]int32
	priorityN         *[]int32
	updatedByRequest  *string
	virtualMachine    *[]string
	virtualMachineId  *[]int32
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) Created(created []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedGt(createdGt []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedGte(createdGte []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedLt(createdLt []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedLte(createdLte []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedN(createdN []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) CreatedByRequest(createdByRequest string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) Device(device []string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.device = &device
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) DeviceId(deviceId []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.deviceId = &deviceId
	return r
}

// Group (ID)
func (r ApiIpamFhrpGroupAssignmentsListRequest) GroupId(groupId []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.groupId = &groupId
	return r
}

// Group (ID)
func (r ApiIpamFhrpGroupAssignmentsListRequest) GroupIdN(groupIdN []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) Id(id []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdEmpty(idEmpty bool) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdGt(idGt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdGte(idGte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdLt(idLt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdLte(idLte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) IdN(idN []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceId(interfaceId []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceId = &interfaceId
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdEmpty(interfaceIdEmpty bool) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdEmpty = &interfaceIdEmpty
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdGt(interfaceIdGt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdGt = &interfaceIdGt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdGte(interfaceIdGte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdGte = &interfaceIdGte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdLt(interfaceIdLt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdLt = &interfaceIdLt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdLte(interfaceIdLte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdLte = &interfaceIdLte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceIdN(interfaceIdN []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceIdN = &interfaceIdN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceType(interfaceType string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceType = &interfaceType
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) InterfaceTypeN(interfaceTypeN string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.interfaceTypeN = &interfaceTypeN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamFhrpGroupAssignmentsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamFhrpGroupAssignmentsListRequest) Limit(limit int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiIpamFhrpGroupAssignmentsListRequest) Offset(offset int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamFhrpGroupAssignmentsListRequest) Ordering(ordering string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) Priority(priority []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priority = &priority
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityEmpty(priorityEmpty bool) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityEmpty = &priorityEmpty
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityGt(priorityGt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityGt = &priorityGt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityGte(priorityGte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityGte = &priorityGte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityLt(priorityLt []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityLt = &priorityLt
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityLte(priorityLte []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityLte = &priorityLte
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) PriorityN(priorityN []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.priorityN = &priorityN
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) VirtualMachine(virtualMachine []string) ApiIpamFhrpGroupAssignmentsListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) VirtualMachineId(virtualMachineId []int32) ApiIpamFhrpGroupAssignmentsListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

func (r ApiIpamFhrpGroupAssignmentsListRequest) Execute() (*PaginatedFHRPGroupAssignmentList, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsListExecute(r)
}

/*
IpamFhrpGroupAssignmentsList Method for IpamFhrpGroupAssignmentsList

Get a list of FHRP group assignment objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupAssignmentsListRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsList(ctx context.Context) ApiIpamFhrpGroupAssignmentsListRequest {
	return ApiIpamFhrpGroupAssignmentsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedFHRPGroupAssignmentList
func (a *IpamAPIService) IpamFhrpGroupAssignmentsListExecute(r ApiIpamFhrpGroupAssignmentsListRequest) (*PaginatedFHRPGroupAssignmentList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedFHRPGroupAssignmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "multi")
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", t, "multi")
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.interfaceId != nil {
		t := *r.interfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", t, "multi")
		}
	}
	if r.interfaceIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__empty", r.interfaceIdEmpty, "")
	}
	if r.interfaceIdGt != nil {
		t := *r.interfaceIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__gt", t, "multi")
		}
	}
	if r.interfaceIdGte != nil {
		t := *r.interfaceIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__gte", t, "multi")
		}
	}
	if r.interfaceIdLt != nil {
		t := *r.interfaceIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__lt", t, "multi")
		}
	}
	if r.interfaceIdLte != nil {
		t := *r.interfaceIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__lte", t, "multi")
		}
	}
	if r.interfaceIdN != nil {
		t := *r.interfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", t, "multi")
		}
	}
	if r.interfaceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface_type", r.interfaceType, "")
	}
	if r.interfaceTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interface_type__n", r.interfaceTypeN, "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.priority != nil {
		t := *r.priority
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority", t, "multi")
		}
	}
	if r.priorityEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority__empty", r.priorityEmpty, "")
	}
	if r.priorityGt != nil {
		t := *r.priorityGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gt", t, "multi")
		}
	}
	if r.priorityGte != nil {
		t := *r.priorityGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__gte", t, "multi")
		}
	}
	if r.priorityLt != nil {
		t := *r.priorityLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lt", t, "multi")
		}
	}
	if r.priorityLte != nil {
		t := *r.priorityLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__lte", t, "multi")
		}
	}
	if r.priorityN != nil {
		t := *r.priorityN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "priority__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "priority__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", t, "multi")
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsPartialUpdateRequest struct {
	ctx                               context.Context
	ApiService                        *IpamAPIService
	id                                int32
	patchedFHRPGroupAssignmentRequest *PatchedFHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsPartialUpdateRequest) PatchedFHRPGroupAssignmentRequest(patchedFHRPGroupAssignmentRequest PatchedFHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsPartialUpdateRequest {
	r.patchedFHRPGroupAssignmentRequest = &patchedFHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsPartialUpdateRequest) Execute() (*FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsPartialUpdateExecute(r)
}

/*
IpamFhrpGroupAssignmentsPartialUpdate Method for IpamFhrpGroupAssignmentsPartialUpdate

Patch a FHRP group assignment object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group assignment.
	@return ApiIpamFhrpGroupAssignmentsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsPartialUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsPartialUpdateRequest {
	return ApiIpamFhrpGroupAssignmentsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsPartialUpdateExecute(r ApiIpamFhrpGroupAssignmentsPartialUpdateRequest) (*FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedFHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamFhrpGroupAssignmentsRetrieveRequest) Execute() (*FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsRetrieveExecute(r)
}

/*
IpamFhrpGroupAssignmentsRetrieve Method for IpamFhrpGroupAssignmentsRetrieve

Get a FHRP group assignment object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group assignment.
	@return ApiIpamFhrpGroupAssignmentsRetrieveRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsRetrieve(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsRetrieveRequest {
	return ApiIpamFhrpGroupAssignmentsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsRetrieveExecute(r ApiIpamFhrpGroupAssignmentsRetrieveRequest) (*FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupAssignmentsUpdateRequest struct {
	ctx                        context.Context
	ApiService                 *IpamAPIService
	id                         int32
	fHRPGroupAssignmentRequest *FHRPGroupAssignmentRequest
}

func (r ApiIpamFhrpGroupAssignmentsUpdateRequest) FHRPGroupAssignmentRequest(fHRPGroupAssignmentRequest FHRPGroupAssignmentRequest) ApiIpamFhrpGroupAssignmentsUpdateRequest {
	r.fHRPGroupAssignmentRequest = &fHRPGroupAssignmentRequest
	return r
}

func (r ApiIpamFhrpGroupAssignmentsUpdateRequest) Execute() (*FHRPGroupAssignment, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupAssignmentsUpdateExecute(r)
}

/*
IpamFhrpGroupAssignmentsUpdate Method for IpamFhrpGroupAssignmentsUpdate

Put a FHRP group assignment object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group assignment.
	@return ApiIpamFhrpGroupAssignmentsUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupAssignmentsUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupAssignmentsUpdateRequest {
	return ApiIpamFhrpGroupAssignmentsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return FHRPGroupAssignment
func (a *IpamAPIService) IpamFhrpGroupAssignmentsUpdateExecute(r ApiIpamFhrpGroupAssignmentsUpdateRequest) (*FHRPGroupAssignment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FHRPGroupAssignment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupAssignmentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-group-assignments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupAssignmentRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupAssignmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupAssignmentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsBulkDestroyRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	fHRPGroupRequest *[]FHRPGroupRequest
}

func (r ApiIpamFhrpGroupsBulkDestroyRequest) FHRPGroupRequest(fHRPGroupRequest []FHRPGroupRequest) ApiIpamFhrpGroupsBulkDestroyRequest {
	r.fHRPGroupRequest = &fHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamFhrpGroupsBulkDestroyExecute(r)
}

/*
IpamFhrpGroupsBulkDestroy Method for IpamFhrpGroupsBulkDestroy

Delete a list of FHRP group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsBulkDestroy(ctx context.Context) ApiIpamFhrpGroupsBulkDestroyRequest {
	return ApiIpamFhrpGroupsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamFhrpGroupsBulkDestroyExecute(r ApiIpamFhrpGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupRequest == nil {
		return nil, reportError("fHRPGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsBulkPartialUpdateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	fHRPGroupRequest *[]FHRPGroupRequest
}

func (r ApiIpamFhrpGroupsBulkPartialUpdateRequest) FHRPGroupRequest(fHRPGroupRequest []FHRPGroupRequest) ApiIpamFhrpGroupsBulkPartialUpdateRequest {
	r.fHRPGroupRequest = &fHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsBulkPartialUpdateRequest) Execute() ([]FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsBulkPartialUpdateExecute(r)
}

/*
IpamFhrpGroupsBulkPartialUpdate Method for IpamFhrpGroupsBulkPartialUpdate

Patch a list of FHRP group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsBulkPartialUpdate(ctx context.Context) ApiIpamFhrpGroupsBulkPartialUpdateRequest {
	return ApiIpamFhrpGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsBulkPartialUpdateExecute(r ApiIpamFhrpGroupsBulkPartialUpdateRequest) ([]FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsBulkUpdateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	fHRPGroupRequest *[]FHRPGroupRequest
}

func (r ApiIpamFhrpGroupsBulkUpdateRequest) FHRPGroupRequest(fHRPGroupRequest []FHRPGroupRequest) ApiIpamFhrpGroupsBulkUpdateRequest {
	r.fHRPGroupRequest = &fHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsBulkUpdateRequest) Execute() ([]FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsBulkUpdateExecute(r)
}

/*
IpamFhrpGroupsBulkUpdate Method for IpamFhrpGroupsBulkUpdate

Put a list of FHRP group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsBulkUpdate(ctx context.Context) ApiIpamFhrpGroupsBulkUpdateRequest {
	return ApiIpamFhrpGroupsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsBulkUpdateExecute(r ApiIpamFhrpGroupsBulkUpdateRequest) ([]FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsCreateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	fHRPGroupRequest *FHRPGroupRequest
}

func (r ApiIpamFhrpGroupsCreateRequest) FHRPGroupRequest(fHRPGroupRequest FHRPGroupRequest) ApiIpamFhrpGroupsCreateRequest {
	r.fHRPGroupRequest = &fHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsCreateRequest) Execute() (*FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsCreateExecute(r)
}

/*
IpamFhrpGroupsCreate Method for IpamFhrpGroupsCreate

Post a list of FHRP group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupsCreateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsCreate(ctx context.Context) ApiIpamFhrpGroupsCreateRequest {
	return ApiIpamFhrpGroupsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsCreateExecute(r ApiIpamFhrpGroupsCreateRequest) (*FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamFhrpGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamFhrpGroupsDestroyExecute(r)
}

/*
IpamFhrpGroupsDestroy Method for IpamFhrpGroupsDestroy

Delete a FHRP group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group.
	@return ApiIpamFhrpGroupsDestroyRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsDestroy(ctx context.Context, id int32) ApiIpamFhrpGroupsDestroyRequest {
	return ApiIpamFhrpGroupsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamFhrpGroupsDestroyExecute(r ApiIpamFhrpGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	authKey           *[]string
	authKeyEmpty      *bool
	authKeyIc         *[]string
	authKeyIe         *[]string
	authKeyIew        *[]string
	authKeyIsw        *[]string
	authKeyN          *[]string
	authKeyNic        *[]string
	authKeyNie        *[]string
	authKeyNiew       *[]string
	authKeyNisw       *[]string
	authType          *[]string
	authTypeN         *[]string
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	groupId           *[]int32
	groupIdEmpty      *bool
	groupIdGt         *[]int32
	groupIdGte        *[]int32
	groupIdLt         *[]int32
	groupIdLte        *[]int32
	groupIdN          *[]int32
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	modifiedByRequest *string
	name              *[]string
	nameEmpty         *bool
	nameIc            *[]string
	nameIe            *[]string
	nameIew           *[]string
	nameIsw           *[]string
	nameN             *[]string
	nameNic           *[]string
	nameNie           *[]string
	nameNiew          *[]string
	nameNisw          *[]string
	offset            *int32
	ordering          *string
	protocol          *[]string
	protocolN         *[]string
	q                 *string
	relatedIp         *[]string
	tag               *[]string
	tagN              *[]string
	updatedByRequest  *string
}

func (r ApiIpamFhrpGroupsListRequest) AuthKey(authKey []string) ApiIpamFhrpGroupsListRequest {
	r.authKey = &authKey
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyEmpty(authKeyEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.authKeyEmpty = &authKeyEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyIc(authKeyIc []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyIc = &authKeyIc
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyIe(authKeyIe []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyIe = &authKeyIe
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyIew(authKeyIew []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyIew = &authKeyIew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyIsw(authKeyIsw []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyIsw = &authKeyIsw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyN(authKeyN []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyN = &authKeyN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyNic(authKeyNic []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyNic = &authKeyNic
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyNie(authKeyNie []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyNie = &authKeyNie
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyNiew(authKeyNiew []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyNiew = &authKeyNiew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthKeyNisw(authKeyNisw []string) ApiIpamFhrpGroupsListRequest {
	r.authKeyNisw = &authKeyNisw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthType(authType []string) ApiIpamFhrpGroupsListRequest {
	r.authType = &authType
	return r
}

func (r ApiIpamFhrpGroupsListRequest) AuthTypeN(authTypeN []string) ApiIpamFhrpGroupsListRequest {
	r.authTypeN = &authTypeN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Created(created []time.Time) ApiIpamFhrpGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedGt(createdGt []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedGte(createdGte []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedLt(createdLt []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedLte(createdLte []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedN(createdN []time.Time) ApiIpamFhrpGroupsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) CreatedByRequest(createdByRequest string) ApiIpamFhrpGroupsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Description(description []string) ApiIpamFhrpGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionIc(descriptionIc []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionIe(descriptionIe []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionIew(descriptionIew []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionN(descriptionN []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionNic(descriptionNic []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionNie(descriptionNie []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamFhrpGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupId(groupId []int32) ApiIpamFhrpGroupsListRequest {
	r.groupId = &groupId
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdEmpty(groupIdEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.groupIdEmpty = &groupIdEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdGt(groupIdGt []int32) ApiIpamFhrpGroupsListRequest {
	r.groupIdGt = &groupIdGt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdGte(groupIdGte []int32) ApiIpamFhrpGroupsListRequest {
	r.groupIdGte = &groupIdGte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdLt(groupIdLt []int32) ApiIpamFhrpGroupsListRequest {
	r.groupIdLt = &groupIdLt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdLte(groupIdLte []int32) ApiIpamFhrpGroupsListRequest {
	r.groupIdLte = &groupIdLte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) GroupIdN(groupIdN []int32) ApiIpamFhrpGroupsListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Id(id []int32) ApiIpamFhrpGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdEmpty(idEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdGt(idGt []int32) ApiIpamFhrpGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdGte(idGte []int32) ApiIpamFhrpGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdLt(idLt []int32) ApiIpamFhrpGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdLte(idLte []int32) ApiIpamFhrpGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) IdN(idN []int32) ApiIpamFhrpGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamFhrpGroupsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamFhrpGroupsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamFhrpGroupsListRequest) Limit(limit int32) ApiIpamFhrpGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamFhrpGroupsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Name(name []string) ApiIpamFhrpGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameEmpty(nameEmpty bool) ApiIpamFhrpGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameIc(nameIc []string) ApiIpamFhrpGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameIe(nameIe []string) ApiIpamFhrpGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameIew(nameIew []string) ApiIpamFhrpGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameIsw(nameIsw []string) ApiIpamFhrpGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameN(nameN []string) ApiIpamFhrpGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameNic(nameNic []string) ApiIpamFhrpGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameNie(nameNie []string) ApiIpamFhrpGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameNiew(nameNiew []string) ApiIpamFhrpGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamFhrpGroupsListRequest) NameNisw(nameNisw []string) ApiIpamFhrpGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamFhrpGroupsListRequest) Offset(offset int32) ApiIpamFhrpGroupsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamFhrpGroupsListRequest) Ordering(ordering string) ApiIpamFhrpGroupsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Protocol(protocol []string) ApiIpamFhrpGroupsListRequest {
	r.protocol = &protocol
	return r
}

func (r ApiIpamFhrpGroupsListRequest) ProtocolN(protocolN []string) ApiIpamFhrpGroupsListRequest {
	r.protocolN = &protocolN
	return r
}

// Search
func (r ApiIpamFhrpGroupsListRequest) Q(q string) ApiIpamFhrpGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamFhrpGroupsListRequest) RelatedIp(relatedIp []string) ApiIpamFhrpGroupsListRequest {
	r.relatedIp = &relatedIp
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Tag(tag []string) ApiIpamFhrpGroupsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamFhrpGroupsListRequest) TagN(tagN []string) ApiIpamFhrpGroupsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamFhrpGroupsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamFhrpGroupsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamFhrpGroupsListRequest) Execute() (*PaginatedFHRPGroupList, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsListExecute(r)
}

/*
IpamFhrpGroupsList Method for IpamFhrpGroupsList

Get a list of FHRP group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamFhrpGroupsListRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsList(ctx context.Context) ApiIpamFhrpGroupsListRequest {
	return ApiIpamFhrpGroupsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedFHRPGroupList
func (a *IpamAPIService) IpamFhrpGroupsListExecute(r ApiIpamFhrpGroupsListRequest) (*PaginatedFHRPGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedFHRPGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.authKey != nil {
		t := *r.authKey
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key", t, "multi")
		}
	}
	if r.authKeyEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__empty", r.authKeyEmpty, "")
	}
	if r.authKeyIc != nil {
		t := *r.authKeyIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__ic", t, "multi")
		}
	}
	if r.authKeyIe != nil {
		t := *r.authKeyIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__ie", t, "multi")
		}
	}
	if r.authKeyIew != nil {
		t := *r.authKeyIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__iew", t, "multi")
		}
	}
	if r.authKeyIsw != nil {
		t := *r.authKeyIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__isw", t, "multi")
		}
	}
	if r.authKeyN != nil {
		t := *r.authKeyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__n", t, "multi")
		}
	}
	if r.authKeyNic != nil {
		t := *r.authKeyNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nic", t, "multi")
		}
	}
	if r.authKeyNie != nil {
		t := *r.authKeyNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nie", t, "multi")
		}
	}
	if r.authKeyNiew != nil {
		t := *r.authKeyNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__niew", t, "multi")
		}
	}
	if r.authKeyNisw != nil {
		t := *r.authKeyNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_key__nisw", t, "multi")
		}
	}
	if r.authType != nil {
		t := *r.authType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type", t, "multi")
		}
	}
	if r.authTypeN != nil {
		t := *r.authTypeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type__n", t, "multi")
		}
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", t, "multi")
		}
	}
	if r.groupIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__empty", r.groupIdEmpty, "")
	}
	if r.groupIdGt != nil {
		t := *r.groupIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__gt", t, "multi")
		}
	}
	if r.groupIdGte != nil {
		t := *r.groupIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__gte", t, "multi")
		}
	}
	if r.groupIdLt != nil {
		t := *r.groupIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__lt", t, "multi")
		}
	}
	if r.groupIdLte != nil {
		t := *r.groupIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__lte", t, "multi")
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.protocol != nil {
		t := *r.protocol
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", t, "multi")
		}
	}
	if r.protocolN != nil {
		t := *r.protocolN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__n", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.relatedIp != nil {
		t := *r.relatedIp
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "related_ip", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "related_ip", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsPartialUpdateRequest struct {
	ctx                     context.Context
	ApiService              *IpamAPIService
	id                      int32
	patchedFHRPGroupRequest *PatchedFHRPGroupRequest
}

func (r ApiIpamFhrpGroupsPartialUpdateRequest) PatchedFHRPGroupRequest(patchedFHRPGroupRequest PatchedFHRPGroupRequest) ApiIpamFhrpGroupsPartialUpdateRequest {
	r.patchedFHRPGroupRequest = &patchedFHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsPartialUpdateRequest) Execute() (*FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsPartialUpdateExecute(r)
}

/*
IpamFhrpGroupsPartialUpdate Method for IpamFhrpGroupsPartialUpdate

Patch a FHRP group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group.
	@return ApiIpamFhrpGroupsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsPartialUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupsPartialUpdateRequest {
	return ApiIpamFhrpGroupsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsPartialUpdateExecute(r ApiIpamFhrpGroupsPartialUpdateRequest) (*FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedFHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamFhrpGroupsRetrieveRequest) Execute() (*FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsRetrieveExecute(r)
}

/*
IpamFhrpGroupsRetrieve Method for IpamFhrpGroupsRetrieve

Get a FHRP group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group.
	@return ApiIpamFhrpGroupsRetrieveRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsRetrieve(ctx context.Context, id int32) ApiIpamFhrpGroupsRetrieveRequest {
	return ApiIpamFhrpGroupsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsRetrieveExecute(r ApiIpamFhrpGroupsRetrieveRequest) (*FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamFhrpGroupsUpdateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	id               int32
	fHRPGroupRequest *FHRPGroupRequest
}

func (r ApiIpamFhrpGroupsUpdateRequest) FHRPGroupRequest(fHRPGroupRequest FHRPGroupRequest) ApiIpamFhrpGroupsUpdateRequest {
	r.fHRPGroupRequest = &fHRPGroupRequest
	return r
}

func (r ApiIpamFhrpGroupsUpdateRequest) Execute() (*FHRPGroup, *http.Response, error) {
	return r.ApiService.IpamFhrpGroupsUpdateExecute(r)
}

/*
IpamFhrpGroupsUpdate Method for IpamFhrpGroupsUpdate

Put a FHRP group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this FHRP group.
	@return ApiIpamFhrpGroupsUpdateRequest
*/
func (a *IpamAPIService) IpamFhrpGroupsUpdate(ctx context.Context, id int32) ApiIpamFhrpGroupsUpdateRequest {
	return ApiIpamFhrpGroupsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return FHRPGroup
func (a *IpamAPIService) IpamFhrpGroupsUpdateExecute(r ApiIpamFhrpGroupsUpdateRequest) (*FHRPGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FHRPGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamFhrpGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/fhrp-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fHRPGroupRequest == nil {
		return localVarReturnValue, nil, reportError("fHRPGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fHRPGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkDestroyRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	iPAddressRequest *[]IPAddressRequest
}

func (r ApiIpamIpAddressesBulkDestroyRequest) IPAddressRequest(iPAddressRequest []IPAddressRequest) ApiIpamIpAddressesBulkDestroyRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamIpAddressesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkDestroyExecute(r)
}

/*
IpamIpAddressesBulkDestroy Method for IpamIpAddressesBulkDestroy

Delete a list of IP address objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpAddressesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamIpAddressesBulkDestroy(ctx context.Context) ApiIpamIpAddressesBulkDestroyRequest {
	return ApiIpamIpAddressesBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpAddressesBulkDestroyExecute(r ApiIpamIpAddressesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return nil, reportError("iPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkPartialUpdateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	iPAddressRequest *[]IPAddressRequest
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IPAddressRequest(iPAddressRequest []IPAddressRequest) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Execute() ([]IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkPartialUpdateExecute(r)
}

/*
IpamIpAddressesBulkPartialUpdate Method for IpamIpAddressesBulkPartialUpdate

Patch a list of IP address objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpAddressesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesBulkPartialUpdate(ctx context.Context) ApiIpamIpAddressesBulkPartialUpdateRequest {
	return ApiIpamIpAddressesBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []IPAddress
func (a *IpamAPIService) IpamIpAddressesBulkPartialUpdateExecute(r ApiIpamIpAddressesBulkPartialUpdateRequest) ([]IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkUpdateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	iPAddressRequest *[]IPAddressRequest
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IPAddressRequest(iPAddressRequest []IPAddressRequest) ApiIpamIpAddressesBulkUpdateRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) Execute() ([]IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkUpdateExecute(r)
}

/*
IpamIpAddressesBulkUpdate Method for IpamIpAddressesBulkUpdate

Put a list of IP address objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpAddressesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesBulkUpdate(ctx context.Context) ApiIpamIpAddressesBulkUpdateRequest {
	return ApiIpamIpAddressesBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []IPAddress
func (a *IpamAPIService) IpamIpAddressesBulkUpdateExecute(r ApiIpamIpAddressesBulkUpdateRequest) ([]IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesCreateRequest struct {
	ctx                      context.Context
	ApiService               *IpamAPIService
	writableIPAddressRequest *WritableIPAddressRequest
}

func (r ApiIpamIpAddressesCreateRequest) WritableIPAddressRequest(writableIPAddressRequest WritableIPAddressRequest) ApiIpamIpAddressesCreateRequest {
	r.writableIPAddressRequest = &writableIPAddressRequest
	return r
}

func (r ApiIpamIpAddressesCreateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesCreateExecute(r)
}

/*
IpamIpAddressesCreate Method for IpamIpAddressesCreate

Post a list of IP address objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpAddressesCreateRequest
*/
func (a *IpamAPIService) IpamIpAddressesCreate(ctx context.Context) ApiIpamIpAddressesCreateRequest {
	return ApiIpamIpAddressesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return IPAddress
func (a *IpamAPIService) IpamIpAddressesCreateExecute(r ApiIpamIpAddressesCreateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamIpAddressesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressesDestroyExecute(r)
}

/*
IpamIpAddressesDestroy Method for IpamIpAddressesDestroy

Delete a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP address.
	@return ApiIpamIpAddressesDestroyRequest
*/
func (a *IpamAPIService) IpamIpAddressesDestroy(ctx context.Context, id int32) ApiIpamIpAddressesDestroyRequest {
	return ApiIpamIpAddressesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpAddressesDestroyExecute(r ApiIpamIpAddressesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressesListRequest struct {
	ctx                   context.Context
	ApiService            *IpamAPIService
	address               *[]string
	assigned              *bool
	assignedObjectId      *[]int32
	assignedObjectIdEmpty *bool
	assignedObjectIdGt    *[]int32
	assignedObjectIdGte   *[]int32
	assignedObjectIdLt    *[]int32
	assignedObjectIdLte   *[]int32
	assignedObjectIdN     *[]int32
	assignedObjectType    *int32
	assignedObjectTypeN   *int32
	assignedToInterface   *bool
	created               *[]time.Time
	createdEmpty          *[]time.Time
	createdGt             *[]time.Time
	createdGte            *[]time.Time
	createdLt             *[]time.Time
	createdLte            *[]time.Time
	createdN              *[]time.Time
	createdByRequest      *string
	description           *[]string
	descriptionEmpty      *bool
	descriptionIc         *[]string
	descriptionIe         *[]string
	descriptionIew        *[]string
	descriptionIsw        *[]string
	descriptionN          *[]string
	descriptionNic        *[]string
	descriptionNie        *[]string
	descriptionNiew       *[]string
	descriptionNisw       *[]string
	device                *[]string
	deviceId              *[]int32
	dnsName               *[]string
	dnsNameEmpty          *bool
	dnsNameIc             *[]string
	dnsNameIe             *[]string
	dnsNameIew            *[]string
	dnsNameIsw            *[]string
	dnsNameN              *[]string
	dnsNameNic            *[]string
	dnsNameNie            *[]string
	dnsNameNiew           *[]string
	dnsNameNisw           *[]string
	family                *float32
	fhrpgroupId           *[]int32
	fhrpgroupIdN          *[]int32
	id                    *[]int32
	idEmpty               *bool
	idGt                  *[]int32
	idGte                 *[]int32
	idLt                  *[]int32
	idLte                 *[]int32
	idN                   *[]int32
	interface_            *[]string
	interfaceN            *[]string
	interfaceId           *[]int32
	interfaceIdN          *[]int32
	lastUpdated           *[]time.Time
	lastUpdatedEmpty      *[]time.Time
	lastUpdatedGt         *[]time.Time
	lastUpdatedGte        *[]time.Time
	lastUpdatedLt         *[]time.Time
	lastUpdatedLte        *[]time.Time
	lastUpdatedN          *[]time.Time
	limit                 *int32
	maskLength            *[]int32
	maskLengthGte         *float32
	maskLengthLte         *float32
	modifiedByRequest     *string
	natInsideId           *[]int32
	natInsideIdN          *[]int32
	offset                *int32
	ordering              *string
	parent                *[]string
	presentInVrf          *string
	presentInVrfId        *string
	q                     *string
	role                  *[]string
	roleN                 *[]string
	serviceId             *[]int32
	serviceIdN            *[]int32
	status                *[]string
	statusN               *[]string
	tag                   *[]string
	tagN                  *[]string
	tenant                *[]string
	tenantN               *[]string
	tenantGroup           *[]string
	tenantGroupN          *[]string
	tenantGroupId         *[]string
	tenantGroupIdN        *[]string
	tenantId              *[]*int32
	tenantIdN             *[]*int32
	updatedByRequest      *string
	virtualMachine        *[]string
	virtualMachineId      *[]int32
	vminterface           *[]string
	vminterfaceN          *[]string
	vminterfaceId         *[]int32
	vminterfaceIdN        *[]int32
	vrf                   *[]*string
	vrfN                  *[]*string
	vrfId                 *[]*int32
	vrfIdN                *[]*int32
}

func (r ApiIpamIpAddressesListRequest) Address(address []string) ApiIpamIpAddressesListRequest {
	r.address = &address
	return r
}

// Is assigned
func (r ApiIpamIpAddressesListRequest) Assigned(assigned bool) ApiIpamIpAddressesListRequest {
	r.assigned = &assigned
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectId(assignedObjectId []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectId = &assignedObjectId
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdEmpty(assignedObjectIdEmpty bool) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdEmpty = &assignedObjectIdEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdGt(assignedObjectIdGt []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdGt = &assignedObjectIdGt
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdGte(assignedObjectIdGte []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdGte = &assignedObjectIdGte
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdLt(assignedObjectIdLt []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdLt = &assignedObjectIdLt
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdLte(assignedObjectIdLte []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdLte = &assignedObjectIdLte
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectIdN(assignedObjectIdN []int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectIdN = &assignedObjectIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectType(assignedObjectType int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectType = &assignedObjectType
	return r
}

func (r ApiIpamIpAddressesListRequest) AssignedObjectTypeN(assignedObjectTypeN int32) ApiIpamIpAddressesListRequest {
	r.assignedObjectTypeN = &assignedObjectTypeN
	return r
}

// Is assigned to an interface
func (r ApiIpamIpAddressesListRequest) AssignedToInterface(assignedToInterface bool) ApiIpamIpAddressesListRequest {
	r.assignedToInterface = &assignedToInterface
	return r
}

func (r ApiIpamIpAddressesListRequest) Created(created []time.Time) ApiIpamIpAddressesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamIpAddressesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedGt(createdGt []time.Time) ApiIpamIpAddressesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedGte(createdGte []time.Time) ApiIpamIpAddressesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedLt(createdLt []time.Time) ApiIpamIpAddressesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedLte(createdLte []time.Time) ApiIpamIpAddressesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedN(createdN []time.Time) ApiIpamIpAddressesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedByRequest(createdByRequest string) ApiIpamIpAddressesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamIpAddressesListRequest) Description(description []string) ApiIpamIpAddressesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamIpAddressesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIc(descriptionIc []string) ApiIpamIpAddressesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIe(descriptionIe []string) ApiIpamIpAddressesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIew(descriptionIew []string) ApiIpamIpAddressesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamIpAddressesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionN(descriptionN []string) ApiIpamIpAddressesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNic(descriptionNic []string) ApiIpamIpAddressesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNie(descriptionNie []string) ApiIpamIpAddressesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamIpAddressesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamIpAddressesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamIpAddressesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) Device(device []string) ApiIpamIpAddressesListRequest {
	r.device = &device
	return r
}

func (r ApiIpamIpAddressesListRequest) DeviceId(deviceId []int32) ApiIpamIpAddressesListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsName(dnsName []string) ApiIpamIpAddressesListRequest {
	r.dnsName = &dnsName
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameEmpty(dnsNameEmpty bool) ApiIpamIpAddressesListRequest {
	r.dnsNameEmpty = &dnsNameEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIc(dnsNameIc []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIc = &dnsNameIc
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIe(dnsNameIe []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIe = &dnsNameIe
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIew(dnsNameIew []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIew = &dnsNameIew
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIsw(dnsNameIsw []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIsw = &dnsNameIsw
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameN(dnsNameN []string) ApiIpamIpAddressesListRequest {
	r.dnsNameN = &dnsNameN
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNic(dnsNameNic []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNic = &dnsNameNic
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNie(dnsNameNie []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNie = &dnsNameNie
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNiew(dnsNameNiew []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNiew = &dnsNameNiew
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNisw(dnsNameNisw []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNisw = &dnsNameNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) Family(family float32) ApiIpamIpAddressesListRequest {
	r.family = &family
	return r
}

// FHRP group (ID)
func (r ApiIpamIpAddressesListRequest) FhrpgroupId(fhrpgroupId []int32) ApiIpamIpAddressesListRequest {
	r.fhrpgroupId = &fhrpgroupId
	return r
}

// FHRP group (ID)
func (r ApiIpamIpAddressesListRequest) FhrpgroupIdN(fhrpgroupIdN []int32) ApiIpamIpAddressesListRequest {
	r.fhrpgroupIdN = &fhrpgroupIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) Id(id []int32) ApiIpamIpAddressesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamIpAddressesListRequest) IdEmpty(idEmpty bool) ApiIpamIpAddressesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) IdGt(idGt []int32) ApiIpamIpAddressesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamIpAddressesListRequest) IdGte(idGte []int32) ApiIpamIpAddressesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamIpAddressesListRequest) IdLt(idLt []int32) ApiIpamIpAddressesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamIpAddressesListRequest) IdLte(idLte []int32) ApiIpamIpAddressesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamIpAddressesListRequest) IdN(idN []int32) ApiIpamIpAddressesListRequest {
	r.idN = &idN
	return r
}

// Interface (name)
func (r ApiIpamIpAddressesListRequest) Interface_(interface_ []string) ApiIpamIpAddressesListRequest {
	r.interface_ = &interface_
	return r
}

// Interface (name)
func (r ApiIpamIpAddressesListRequest) InterfaceN(interfaceN []string) ApiIpamIpAddressesListRequest {
	r.interfaceN = &interfaceN
	return r
}

// Interface (ID)
func (r ApiIpamIpAddressesListRequest) InterfaceId(interfaceId []int32) ApiIpamIpAddressesListRequest {
	r.interfaceId = &interfaceId
	return r
}

// Interface (ID)
func (r ApiIpamIpAddressesListRequest) InterfaceIdN(interfaceIdN []int32) ApiIpamIpAddressesListRequest {
	r.interfaceIdN = &interfaceIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamIpAddressesListRequest) Limit(limit int32) ApiIpamIpAddressesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLength(maskLength []int32) ApiIpamIpAddressesListRequest {
	r.maskLength = &maskLength
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLengthGte(maskLengthGte float32) ApiIpamIpAddressesListRequest {
	r.maskLengthGte = &maskLengthGte
	return r
}

func (r ApiIpamIpAddressesListRequest) MaskLengthLte(maskLengthLte float32) ApiIpamIpAddressesListRequest {
	r.maskLengthLte = &maskLengthLte
	return r
}

func (r ApiIpamIpAddressesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamIpAddressesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// NAT inside IP address (ID)
func (r ApiIpamIpAddressesListRequest) NatInsideId(natInsideId []int32) ApiIpamIpAddressesListRequest {
	r.natInsideId = &natInsideId
	return r
}

// NAT inside IP address (ID)
func (r ApiIpamIpAddressesListRequest) NatInsideIdN(natInsideIdN []int32) ApiIpamIpAddressesListRequest {
	r.natInsideIdN = &natInsideIdN
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpAddressesListRequest) Offset(offset int32) ApiIpamIpAddressesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamIpAddressesListRequest) Ordering(ordering string) ApiIpamIpAddressesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamIpAddressesListRequest) Parent(parent []string) ApiIpamIpAddressesListRequest {
	r.parent = &parent
	return r
}

func (r ApiIpamIpAddressesListRequest) PresentInVrf(presentInVrf string) ApiIpamIpAddressesListRequest {
	r.presentInVrf = &presentInVrf
	return r
}

func (r ApiIpamIpAddressesListRequest) PresentInVrfId(presentInVrfId string) ApiIpamIpAddressesListRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

// Search
func (r ApiIpamIpAddressesListRequest) Q(q string) ApiIpamIpAddressesListRequest {
	r.q = &q
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) Role(role []string) ApiIpamIpAddressesListRequest {
	r.role = &role
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) RoleN(roleN []string) ApiIpamIpAddressesListRequest {
	r.roleN = &roleN
	return r
}

// Service (ID)
func (r ApiIpamIpAddressesListRequest) ServiceId(serviceId []int32) ApiIpamIpAddressesListRequest {
	r.serviceId = &serviceId
	return r
}

// Service (ID)
func (r ApiIpamIpAddressesListRequest) ServiceIdN(serviceIdN []int32) ApiIpamIpAddressesListRequest {
	r.serviceIdN = &serviceIdN
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) Status(status []string) ApiIpamIpAddressesListRequest {
	r.status = &status
	return r
}

// The operational status of this IP
func (r ApiIpamIpAddressesListRequest) StatusN(statusN []string) ApiIpamIpAddressesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamIpAddressesListRequest) Tag(tag []string) ApiIpamIpAddressesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamIpAddressesListRequest) TagN(tagN []string) ApiIpamIpAddressesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamIpAddressesListRequest) Tenant(tenant []string) ApiIpamIpAddressesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamIpAddressesListRequest) TenantN(tenantN []string) ApiIpamIpAddressesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroup(tenantGroup []string) ApiIpamIpAddressesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamIpAddressesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamIpAddressesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamIpAddressesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamIpAddressesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamIpAddressesListRequest) TenantId(tenantId []*int32) ApiIpamIpAddressesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamIpAddressesListRequest) TenantIdN(tenantIdN []*int32) ApiIpamIpAddressesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamIpAddressesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamIpAddressesListRequest) VirtualMachine(virtualMachine []string) ApiIpamIpAddressesListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

func (r ApiIpamIpAddressesListRequest) VirtualMachineId(virtualMachineId []int32) ApiIpamIpAddressesListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

// VM interface (name)
func (r ApiIpamIpAddressesListRequest) Vminterface(vminterface []string) ApiIpamIpAddressesListRequest {
	r.vminterface = &vminterface
	return r
}

// VM interface (name)
func (r ApiIpamIpAddressesListRequest) VminterfaceN(vminterfaceN []string) ApiIpamIpAddressesListRequest {
	r.vminterfaceN = &vminterfaceN
	return r
}

// VM interface (ID)
func (r ApiIpamIpAddressesListRequest) VminterfaceId(vminterfaceId []int32) ApiIpamIpAddressesListRequest {
	r.vminterfaceId = &vminterfaceId
	return r
}

// VM interface (ID)
func (r ApiIpamIpAddressesListRequest) VminterfaceIdN(vminterfaceIdN []int32) ApiIpamIpAddressesListRequest {
	r.vminterfaceIdN = &vminterfaceIdN
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesListRequest) Vrf(vrf []*string) ApiIpamIpAddressesListRequest {
	r.vrf = &vrf
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesListRequest) VrfN(vrfN []*string) ApiIpamIpAddressesListRequest {
	r.vrfN = &vrfN
	return r
}

// VRF
func (r ApiIpamIpAddressesListRequest) VrfId(vrfId []*int32) ApiIpamIpAddressesListRequest {
	r.vrfId = &vrfId
	return r
}

// VRF
func (r ApiIpamIpAddressesListRequest) VrfIdN(vrfIdN []*int32) ApiIpamIpAddressesListRequest {
	r.vrfIdN = &vrfIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) Execute() (*PaginatedIPAddressList, *http.Response, error) {
	return r.ApiService.IpamIpAddressesListExecute(r)
}

/*
IpamIpAddressesList Method for IpamIpAddressesList

Get a list of IP address objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpAddressesListRequest
*/
func (a *IpamAPIService) IpamIpAddressesList(ctx context.Context) ApiIpamIpAddressesListRequest {
	return ApiIpamIpAddressesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedIPAddressList
func (a *IpamAPIService) IpamIpAddressesListExecute(r ApiIpamIpAddressesListRequest) (*PaginatedIPAddressList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedIPAddressList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		t := *r.address
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "address", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "address", t, "multi")
		}
	}
	if r.assigned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned", r.assigned, "")
	}
	if r.assignedObjectId != nil {
		t := *r.assignedObjectId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id", t, "multi")
		}
	}
	if r.assignedObjectIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__empty", r.assignedObjectIdEmpty, "")
	}
	if r.assignedObjectIdGt != nil {
		t := *r.assignedObjectIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gt", t, "multi")
		}
	}
	if r.assignedObjectIdGte != nil {
		t := *r.assignedObjectIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__gte", t, "multi")
		}
	}
	if r.assignedObjectIdLt != nil {
		t := *r.assignedObjectIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lt", t, "multi")
		}
	}
	if r.assignedObjectIdLte != nil {
		t := *r.assignedObjectIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__lte", t, "multi")
		}
	}
	if r.assignedObjectIdN != nil {
		t := *r.assignedObjectIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_id__n", t, "multi")
		}
	}
	if r.assignedObjectType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_type", r.assignedObjectType, "")
	}
	if r.assignedObjectTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_object_type__n", r.assignedObjectTypeN, "")
	}
	if r.assignedToInterface != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assigned_to_interface", r.assignedToInterface, "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "multi")
		}
	}
	if r.dnsName != nil {
		t := *r.dnsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name", t, "multi")
		}
	}
	if r.dnsNameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__empty", r.dnsNameEmpty, "")
	}
	if r.dnsNameIc != nil {
		t := *r.dnsNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ic", t, "multi")
		}
	}
	if r.dnsNameIe != nil {
		t := *r.dnsNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__ie", t, "multi")
		}
	}
	if r.dnsNameIew != nil {
		t := *r.dnsNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__iew", t, "multi")
		}
	}
	if r.dnsNameIsw != nil {
		t := *r.dnsNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__isw", t, "multi")
		}
	}
	if r.dnsNameN != nil {
		t := *r.dnsNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__n", t, "multi")
		}
	}
	if r.dnsNameNic != nil {
		t := *r.dnsNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nic", t, "multi")
		}
	}
	if r.dnsNameNie != nil {
		t := *r.dnsNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nie", t, "multi")
		}
	}
	if r.dnsNameNiew != nil {
		t := *r.dnsNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__niew", t, "multi")
		}
	}
	if r.dnsNameNisw != nil {
		t := *r.dnsNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dns_name__nisw", t, "multi")
		}
	}
	if r.family != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "family", r.family, "")
	}
	if r.fhrpgroupId != nil {
		t := *r.fhrpgroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fhrpgroup_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fhrpgroup_id", t, "multi")
		}
	}
	if r.fhrpgroupIdN != nil {
		t := *r.fhrpgroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fhrpgroup_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fhrpgroup_id__n", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.interface_ != nil {
		t := *r.interface_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface", t, "multi")
		}
	}
	if r.interfaceN != nil {
		t := *r.interfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface__n", t, "multi")
		}
	}
	if r.interfaceId != nil {
		t := *r.interfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id", t, "multi")
		}
	}
	if r.interfaceIdN != nil {
		t := *r.interfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "interface_id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.maskLength != nil {
		t := *r.maskLength
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length", t, "multi")
		}
	}
	if r.maskLengthGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__gte", r.maskLengthGte, "")
	}
	if r.maskLengthLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__lte", r.maskLengthLte, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.natInsideId != nil {
		t := *r.natInsideId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside_id", t, "multi")
		}
	}
	if r.natInsideIdN != nil {
		t := *r.natInsideIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "nat_inside_id__n", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.parent != nil {
		t := *r.parent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent", t, "multi")
		}
	}
	if r.presentInVrf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf", r.presentInVrf, "")
	}
	if r.presentInVrfId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf_id", r.presentInVrfId, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "multi")
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "multi")
		}
	}
	if r.serviceId != nil {
		t := *r.serviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_id", t, "multi")
		}
	}
	if r.serviceIdN != nil {
		t := *r.serviceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_id__n", t, "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", t, "multi")
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", t, "multi")
		}
	}
	if r.vminterface != nil {
		t := *r.vminterface
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface", t, "multi")
		}
	}
	if r.vminterfaceN != nil {
		t := *r.vminterfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface__n", t, "multi")
		}
	}
	if r.vminterfaceId != nil {
		t := *r.vminterfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id", t, "multi")
		}
	}
	if r.vminterfaceIdN != nil {
		t := *r.vminterfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vminterface_id__n", t, "multi")
		}
	}
	if r.vrf != nil {
		t := *r.vrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", t, "multi")
		}
	}
	if r.vrfN != nil {
		t := *r.vrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", t, "multi")
		}
	}
	if r.vrfId != nil {
		t := *r.vrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", t, "multi")
		}
	}
	if r.vrfIdN != nil {
		t := *r.vrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesPartialUpdateRequest struct {
	ctx                             context.Context
	ApiService                      *IpamAPIService
	id                              int32
	patchedWritableIPAddressRequest *PatchedWritableIPAddressRequest
}

func (r ApiIpamIpAddressesPartialUpdateRequest) PatchedWritableIPAddressRequest(patchedWritableIPAddressRequest PatchedWritableIPAddressRequest) ApiIpamIpAddressesPartialUpdateRequest {
	r.patchedWritableIPAddressRequest = &patchedWritableIPAddressRequest
	return r
}

func (r ApiIpamIpAddressesPartialUpdateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesPartialUpdateExecute(r)
}

/*
IpamIpAddressesPartialUpdate Method for IpamIpAddressesPartialUpdate

Patch a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP address.
	@return ApiIpamIpAddressesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesPartialUpdate(ctx context.Context, id int32) ApiIpamIpAddressesPartialUpdateRequest {
	return ApiIpamIpAddressesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return IPAddress
func (a *IpamAPIService) IpamIpAddressesPartialUpdateExecute(r ApiIpamIpAddressesPartialUpdateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableIPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamIpAddressesRetrieveRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesRetrieveExecute(r)
}

/*
IpamIpAddressesRetrieve Method for IpamIpAddressesRetrieve

Get a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP address.
	@return ApiIpamIpAddressesRetrieveRequest
*/
func (a *IpamAPIService) IpamIpAddressesRetrieve(ctx context.Context, id int32) ApiIpamIpAddressesRetrieveRequest {
	return ApiIpamIpAddressesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return IPAddress
func (a *IpamAPIService) IpamIpAddressesRetrieveExecute(r ApiIpamIpAddressesRetrieveRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesUpdateRequest struct {
	ctx                      context.Context
	ApiService               *IpamAPIService
	id                       int32
	writableIPAddressRequest *WritableIPAddressRequest
}

func (r ApiIpamIpAddressesUpdateRequest) WritableIPAddressRequest(writableIPAddressRequest WritableIPAddressRequest) ApiIpamIpAddressesUpdateRequest {
	r.writableIPAddressRequest = &writableIPAddressRequest
	return r
}

func (r ApiIpamIpAddressesUpdateRequest) Execute() (*IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpAddressesUpdateExecute(r)
}

/*
IpamIpAddressesUpdate Method for IpamIpAddressesUpdate

Put a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP address.
	@return ApiIpamIpAddressesUpdateRequest
*/
func (a *IpamAPIService) IpamIpAddressesUpdate(ctx context.Context, id int32) ApiIpamIpAddressesUpdateRequest {
	return ApiIpamIpAddressesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return IPAddress
func (a *IpamAPIService) IpamIpAddressesUpdateExecute(r ApiIpamIpAddressesUpdateRequest) (*IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpAddressesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesAvailableIpsCreateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	id               int32
	iPAddressRequest *[]IPAddressRequest
}

func (r ApiIpamIpRangesAvailableIpsCreateRequest) IPAddressRequest(iPAddressRequest []IPAddressRequest) ApiIpamIpRangesAvailableIpsCreateRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamIpRangesAvailableIpsCreateRequest) Execute() ([]IPAddress, *http.Response, error) {
	return r.ApiService.IpamIpRangesAvailableIpsCreateExecute(r)
}

/*
IpamIpRangesAvailableIpsCreate Method for IpamIpRangesAvailableIpsCreate

Post a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamIpRangesAvailableIpsCreateRequest
*/
func (a *IpamAPIService) IpamIpRangesAvailableIpsCreate(ctx context.Context, id int32) ApiIpamIpRangesAvailableIpsCreateRequest {
	return ApiIpamIpRangesAvailableIpsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []IPAddress
func (a *IpamAPIService) IpamIpRangesAvailableIpsCreateExecute(r ApiIpamIpRangesAvailableIpsCreateRequest) ([]IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesAvailableIpsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesAvailableIpsListRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamIpRangesAvailableIpsListRequest) Execute() ([]AvailableIP, *http.Response, error) {
	return r.ApiService.IpamIpRangesAvailableIpsListExecute(r)
}

/*
IpamIpRangesAvailableIpsList Method for IpamIpRangesAvailableIpsList

Get a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamIpRangesAvailableIpsListRequest
*/
func (a *IpamAPIService) IpamIpRangesAvailableIpsList(ctx context.Context, id int32) ApiIpamIpRangesAvailableIpsListRequest {
	return ApiIpamIpRangesAvailableIpsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []AvailableIP
func (a *IpamAPIService) IpamIpRangesAvailableIpsListExecute(r ApiIpamIpRangesAvailableIpsListRequest) ([]AvailableIP, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AvailableIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesAvailableIpsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesBulkDestroyRequest struct {
	ctx            context.Context
	ApiService     *IpamAPIService
	iPRangeRequest *[]IPRangeRequest
}

func (r ApiIpamIpRangesBulkDestroyRequest) IPRangeRequest(iPRangeRequest []IPRangeRequest) ApiIpamIpRangesBulkDestroyRequest {
	r.iPRangeRequest = &iPRangeRequest
	return r
}

func (r ApiIpamIpRangesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpRangesBulkDestroyExecute(r)
}

/*
IpamIpRangesBulkDestroy Method for IpamIpRangesBulkDestroy

Delete a list of IP range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpRangesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamIpRangesBulkDestroy(ctx context.Context) ApiIpamIpRangesBulkDestroyRequest {
	return ApiIpamIpRangesBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpRangesBulkDestroyExecute(r ApiIpamIpRangesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPRangeRequest == nil {
		return nil, reportError("iPRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpRangesBulkPartialUpdateRequest struct {
	ctx            context.Context
	ApiService     *IpamAPIService
	iPRangeRequest *[]IPRangeRequest
}

func (r ApiIpamIpRangesBulkPartialUpdateRequest) IPRangeRequest(iPRangeRequest []IPRangeRequest) ApiIpamIpRangesBulkPartialUpdateRequest {
	r.iPRangeRequest = &iPRangeRequest
	return r
}

func (r ApiIpamIpRangesBulkPartialUpdateRequest) Execute() ([]IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesBulkPartialUpdateExecute(r)
}

/*
IpamIpRangesBulkPartialUpdate Method for IpamIpRangesBulkPartialUpdate

Patch a list of IP range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpRangesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpRangesBulkPartialUpdate(ctx context.Context) ApiIpamIpRangesBulkPartialUpdateRequest {
	return ApiIpamIpRangesBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []IPRange
func (a *IpamAPIService) IpamIpRangesBulkPartialUpdateExecute(r ApiIpamIpRangesBulkPartialUpdateRequest) ([]IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPRangeRequest == nil {
		return localVarReturnValue, nil, reportError("iPRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesBulkUpdateRequest struct {
	ctx            context.Context
	ApiService     *IpamAPIService
	iPRangeRequest *[]IPRangeRequest
}

func (r ApiIpamIpRangesBulkUpdateRequest) IPRangeRequest(iPRangeRequest []IPRangeRequest) ApiIpamIpRangesBulkUpdateRequest {
	r.iPRangeRequest = &iPRangeRequest
	return r
}

func (r ApiIpamIpRangesBulkUpdateRequest) Execute() ([]IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesBulkUpdateExecute(r)
}

/*
IpamIpRangesBulkUpdate Method for IpamIpRangesBulkUpdate

Put a list of IP range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpRangesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamIpRangesBulkUpdate(ctx context.Context) ApiIpamIpRangesBulkUpdateRequest {
	return ApiIpamIpRangesBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []IPRange
func (a *IpamAPIService) IpamIpRangesBulkUpdateExecute(r ApiIpamIpRangesBulkUpdateRequest) ([]IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPRangeRequest == nil {
		return localVarReturnValue, nil, reportError("iPRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesCreateRequest struct {
	ctx                    context.Context
	ApiService             *IpamAPIService
	writableIPRangeRequest *WritableIPRangeRequest
}

func (r ApiIpamIpRangesCreateRequest) WritableIPRangeRequest(writableIPRangeRequest WritableIPRangeRequest) ApiIpamIpRangesCreateRequest {
	r.writableIPRangeRequest = &writableIPRangeRequest
	return r
}

func (r ApiIpamIpRangesCreateRequest) Execute() (*IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesCreateExecute(r)
}

/*
IpamIpRangesCreate Method for IpamIpRangesCreate

Post a list of IP range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpRangesCreateRequest
*/
func (a *IpamAPIService) IpamIpRangesCreate(ctx context.Context) ApiIpamIpRangesCreateRequest {
	return ApiIpamIpRangesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return IPRange
func (a *IpamAPIService) IpamIpRangesCreateExecute(r ApiIpamIpRangesCreateRequest) (*IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPRangeRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamIpRangesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpRangesDestroyExecute(r)
}

/*
IpamIpRangesDestroy Method for IpamIpRangesDestroy

Delete a IP range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP range.
	@return ApiIpamIpRangesDestroyRequest
*/
func (a *IpamAPIService) IpamIpRangesDestroy(ctx context.Context, id int32) ApiIpamIpRangesDestroyRequest {
	return ApiIpamIpRangesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamIpRangesDestroyExecute(r ApiIpamIpRangesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpRangesListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	contains          *string
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	endAddress        *[]string
	family            *float32
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	markUtilized      *bool
	modifiedByRequest *string
	offset            *int32
	ordering          *string
	parent            *[]string
	q                 *string
	role              *[]string
	roleN             *[]string
	roleId            *[]*int32
	roleIdN           *[]*int32
	size              *[]int32
	sizeEmpty         *bool
	sizeGt            *[]int32
	sizeGte           *[]int32
	sizeLt            *[]int32
	sizeLte           *[]int32
	sizeN             *[]int32
	startAddress      *[]string
	status            *[]string
	statusN           *[]string
	tag               *[]string
	tagN              *[]string
	tenant            *[]string
	tenantN           *[]string
	tenantGroup       *[]string
	tenantGroupN      *[]string
	tenantGroupId     *[]string
	tenantGroupIdN    *[]string
	tenantId          *[]*int32
	tenantIdN         *[]*int32
	updatedByRequest  *string
	vrf               *[]*string
	vrfN              *[]*string
	vrfId             *[]*int32
	vrfIdN            *[]*int32
}

// Ranges which contain this prefix or IP
func (r ApiIpamIpRangesListRequest) Contains(contains string) ApiIpamIpRangesListRequest {
	r.contains = &contains
	return r
}

func (r ApiIpamIpRangesListRequest) Created(created []time.Time) ApiIpamIpRangesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamIpRangesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedGt(createdGt []time.Time) ApiIpamIpRangesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedGte(createdGte []time.Time) ApiIpamIpRangesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedLt(createdLt []time.Time) ApiIpamIpRangesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedLte(createdLte []time.Time) ApiIpamIpRangesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedN(createdN []time.Time) ApiIpamIpRangesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamIpRangesListRequest) CreatedByRequest(createdByRequest string) ApiIpamIpRangesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamIpRangesListRequest) Description(description []string) ApiIpamIpRangesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamIpRangesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionIc(descriptionIc []string) ApiIpamIpRangesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionIe(descriptionIe []string) ApiIpamIpRangesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionIew(descriptionIew []string) ApiIpamIpRangesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamIpRangesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionN(descriptionN []string) ApiIpamIpRangesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionNic(descriptionNic []string) ApiIpamIpRangesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionNie(descriptionNie []string) ApiIpamIpRangesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamIpRangesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamIpRangesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamIpRangesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamIpRangesListRequest) EndAddress(endAddress []string) ApiIpamIpRangesListRequest {
	r.endAddress = &endAddress
	return r
}

func (r ApiIpamIpRangesListRequest) Family(family float32) ApiIpamIpRangesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamIpRangesListRequest) Id(id []int32) ApiIpamIpRangesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamIpRangesListRequest) IdEmpty(idEmpty bool) ApiIpamIpRangesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamIpRangesListRequest) IdGt(idGt []int32) ApiIpamIpRangesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamIpRangesListRequest) IdGte(idGte []int32) ApiIpamIpRangesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamIpRangesListRequest) IdLt(idLt []int32) ApiIpamIpRangesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamIpRangesListRequest) IdLte(idLte []int32) ApiIpamIpRangesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamIpRangesListRequest) IdN(idN []int32) ApiIpamIpRangesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamIpRangesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamIpRangesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamIpRangesListRequest) Limit(limit int32) ApiIpamIpRangesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamIpRangesListRequest) MarkUtilized(markUtilized bool) ApiIpamIpRangesListRequest {
	r.markUtilized = &markUtilized
	return r
}

func (r ApiIpamIpRangesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamIpRangesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpRangesListRequest) Offset(offset int32) ApiIpamIpRangesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamIpRangesListRequest) Ordering(ordering string) ApiIpamIpRangesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamIpRangesListRequest) Parent(parent []string) ApiIpamIpRangesListRequest {
	r.parent = &parent
	return r
}

// Search
func (r ApiIpamIpRangesListRequest) Q(q string) ApiIpamIpRangesListRequest {
	r.q = &q
	return r
}

// Role (slug)
func (r ApiIpamIpRangesListRequest) Role(role []string) ApiIpamIpRangesListRequest {
	r.role = &role
	return r
}

// Role (slug)
func (r ApiIpamIpRangesListRequest) RoleN(roleN []string) ApiIpamIpRangesListRequest {
	r.roleN = &roleN
	return r
}

// Role (ID)
func (r ApiIpamIpRangesListRequest) RoleId(roleId []*int32) ApiIpamIpRangesListRequest {
	r.roleId = &roleId
	return r
}

// Role (ID)
func (r ApiIpamIpRangesListRequest) RoleIdN(roleIdN []*int32) ApiIpamIpRangesListRequest {
	r.roleIdN = &roleIdN
	return r
}

func (r ApiIpamIpRangesListRequest) Size(size []int32) ApiIpamIpRangesListRequest {
	r.size = &size
	return r
}

func (r ApiIpamIpRangesListRequest) SizeEmpty(sizeEmpty bool) ApiIpamIpRangesListRequest {
	r.sizeEmpty = &sizeEmpty
	return r
}

func (r ApiIpamIpRangesListRequest) SizeGt(sizeGt []int32) ApiIpamIpRangesListRequest {
	r.sizeGt = &sizeGt
	return r
}

func (r ApiIpamIpRangesListRequest) SizeGte(sizeGte []int32) ApiIpamIpRangesListRequest {
	r.sizeGte = &sizeGte
	return r
}

func (r ApiIpamIpRangesListRequest) SizeLt(sizeLt []int32) ApiIpamIpRangesListRequest {
	r.sizeLt = &sizeLt
	return r
}

func (r ApiIpamIpRangesListRequest) SizeLte(sizeLte []int32) ApiIpamIpRangesListRequest {
	r.sizeLte = &sizeLte
	return r
}

func (r ApiIpamIpRangesListRequest) SizeN(sizeN []int32) ApiIpamIpRangesListRequest {
	r.sizeN = &sizeN
	return r
}

func (r ApiIpamIpRangesListRequest) StartAddress(startAddress []string) ApiIpamIpRangesListRequest {
	r.startAddress = &startAddress
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) Status(status []string) ApiIpamIpRangesListRequest {
	r.status = &status
	return r
}

// Operational status of this range
func (r ApiIpamIpRangesListRequest) StatusN(statusN []string) ApiIpamIpRangesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamIpRangesListRequest) Tag(tag []string) ApiIpamIpRangesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamIpRangesListRequest) TagN(tagN []string) ApiIpamIpRangesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamIpRangesListRequest) Tenant(tenant []string) ApiIpamIpRangesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamIpRangesListRequest) TenantN(tenantN []string) ApiIpamIpRangesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamIpRangesListRequest) TenantGroup(tenantGroup []string) ApiIpamIpRangesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamIpRangesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamIpRangesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamIpRangesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamIpRangesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamIpRangesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamIpRangesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamIpRangesListRequest) TenantId(tenantId []*int32) ApiIpamIpRangesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamIpRangesListRequest) TenantIdN(tenantIdN []*int32) ApiIpamIpRangesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamIpRangesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamIpRangesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

// VRF (RD)
func (r ApiIpamIpRangesListRequest) Vrf(vrf []*string) ApiIpamIpRangesListRequest {
	r.vrf = &vrf
	return r
}

// VRF (RD)
func (r ApiIpamIpRangesListRequest) VrfN(vrfN []*string) ApiIpamIpRangesListRequest {
	r.vrfN = &vrfN
	return r
}

// VRF
func (r ApiIpamIpRangesListRequest) VrfId(vrfId []*int32) ApiIpamIpRangesListRequest {
	r.vrfId = &vrfId
	return r
}

// VRF
func (r ApiIpamIpRangesListRequest) VrfIdN(vrfIdN []*int32) ApiIpamIpRangesListRequest {
	r.vrfIdN = &vrfIdN
	return r
}

func (r ApiIpamIpRangesListRequest) Execute() (*PaginatedIPRangeList, *http.Response, error) {
	return r.ApiService.IpamIpRangesListExecute(r)
}

/*
IpamIpRangesList Method for IpamIpRangesList

Get a list of IP range objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamIpRangesListRequest
*/
func (a *IpamAPIService) IpamIpRangesList(ctx context.Context) ApiIpamIpRangesListRequest {
	return ApiIpamIpRangesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedIPRangeList
func (a *IpamAPIService) IpamIpRangesListExecute(r ApiIpamIpRangesListRequest) (*PaginatedIPRangeList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedIPRangeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.endAddress != nil {
		t := *r.endAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "end_address", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "end_address", t, "multi")
		}
	}
	if r.family != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "family", r.family, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.markUtilized != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mark_utilized", r.markUtilized, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.parent != nil {
		t := *r.parent
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "parent", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "parent", t, "multi")
		}
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "multi")
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "multi")
		}
	}
	if r.roleId != nil {
		t := *r.roleId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", t, "multi")
		}
	}
	if r.roleIdN != nil {
		t := *r.roleIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", t, "multi")
		}
	}
	if r.size != nil {
		t := *r.size
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size", t, "multi")
		}
	}
	if r.sizeEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size__empty", r.sizeEmpty, "")
	}
	if r.sizeGt != nil {
		t := *r.sizeGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size__gt", t, "multi")
		}
	}
	if r.sizeGte != nil {
		t := *r.sizeGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size__gte", t, "multi")
		}
	}
	if r.sizeLt != nil {
		t := *r.sizeLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size__lt", t, "multi")
		}
	}
	if r.sizeLte != nil {
		t := *r.sizeLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size__lte", t, "multi")
		}
	}
	if r.sizeN != nil {
		t := *r.sizeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "size__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "size__n", t, "multi")
		}
	}
	if r.startAddress != nil {
		t := *r.startAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "start_address", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "start_address", t, "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	if r.vrf != nil {
		t := *r.vrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", t, "multi")
		}
	}
	if r.vrfN != nil {
		t := *r.vrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", t, "multi")
		}
	}
	if r.vrfId != nil {
		t := *r.vrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", t, "multi")
		}
	}
	if r.vrfIdN != nil {
		t := *r.vrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesPartialUpdateRequest struct {
	ctx                           context.Context
	ApiService                    *IpamAPIService
	id                            int32
	patchedWritableIPRangeRequest *PatchedWritableIPRangeRequest
}

func (r ApiIpamIpRangesPartialUpdateRequest) PatchedWritableIPRangeRequest(patchedWritableIPRangeRequest PatchedWritableIPRangeRequest) ApiIpamIpRangesPartialUpdateRequest {
	r.patchedWritableIPRangeRequest = &patchedWritableIPRangeRequest
	return r
}

func (r ApiIpamIpRangesPartialUpdateRequest) Execute() (*IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesPartialUpdateExecute(r)
}

/*
IpamIpRangesPartialUpdate Method for IpamIpRangesPartialUpdate

Patch a IP range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP range.
	@return ApiIpamIpRangesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamIpRangesPartialUpdate(ctx context.Context, id int32) ApiIpamIpRangesPartialUpdateRequest {
	return ApiIpamIpRangesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return IPRange
func (a *IpamAPIService) IpamIpRangesPartialUpdateExecute(r ApiIpamIpRangesPartialUpdateRequest) (*IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableIPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamIpRangesRetrieveRequest) Execute() (*IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesRetrieveExecute(r)
}

/*
IpamIpRangesRetrieve Method for IpamIpRangesRetrieve

Get a IP range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP range.
	@return ApiIpamIpRangesRetrieveRequest
*/
func (a *IpamAPIService) IpamIpRangesRetrieve(ctx context.Context, id int32) ApiIpamIpRangesRetrieveRequest {
	return ApiIpamIpRangesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return IPRange
func (a *IpamAPIService) IpamIpRangesRetrieveExecute(r ApiIpamIpRangesRetrieveRequest) (*IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpRangesUpdateRequest struct {
	ctx                    context.Context
	ApiService             *IpamAPIService
	id                     int32
	writableIPRangeRequest *WritableIPRangeRequest
}

func (r ApiIpamIpRangesUpdateRequest) WritableIPRangeRequest(writableIPRangeRequest WritableIPRangeRequest) ApiIpamIpRangesUpdateRequest {
	r.writableIPRangeRequest = &writableIPRangeRequest
	return r
}

func (r ApiIpamIpRangesUpdateRequest) Execute() (*IPRange, *http.Response, error) {
	return r.ApiService.IpamIpRangesUpdateExecute(r)
}

/*
IpamIpRangesUpdate Method for IpamIpRangesUpdate

Put a IP range object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this IP range.
	@return ApiIpamIpRangesUpdateRequest
*/
func (a *IpamAPIService) IpamIpRangesUpdate(ctx context.Context, id int32) ApiIpamIpRangesUpdateRequest {
	return ApiIpamIpRangesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return IPRange
func (a *IpamAPIService) IpamIpRangesUpdateExecute(r ApiIpamIpRangesUpdateRequest) (*IPRange, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IPRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamIpRangesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/ip-ranges/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPRangeRequest == nil {
		return localVarReturnValue, nil, reportError("writableIPRangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPRangeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailableIpsCreateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	id               int32
	iPAddressRequest *[]IPAddressRequest
}

func (r ApiIpamPrefixesAvailableIpsCreateRequest) IPAddressRequest(iPAddressRequest []IPAddressRequest) ApiIpamPrefixesAvailableIpsCreateRequest {
	r.iPAddressRequest = &iPAddressRequest
	return r
}

func (r ApiIpamPrefixesAvailableIpsCreateRequest) Execute() ([]IPAddress, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailableIpsCreateExecute(r)
}

/*
IpamPrefixesAvailableIpsCreate Method for IpamPrefixesAvailableIpsCreate

Post a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamPrefixesAvailableIpsCreateRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailableIpsCreate(ctx context.Context, id int32) ApiIpamPrefixesAvailableIpsCreateRequest {
	return ApiIpamPrefixesAvailableIpsCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []IPAddress
func (a *IpamAPIService) IpamPrefixesAvailableIpsCreateExecute(r ApiIpamPrefixesAvailableIpsCreateRequest) ([]IPAddress, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []IPAddress
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailableIpsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iPAddressRequest == nil {
		return localVarReturnValue, nil, reportError("iPAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iPAddressRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailableIpsListRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamPrefixesAvailableIpsListRequest) Execute() ([]AvailableIP, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailableIpsListExecute(r)
}

/*
IpamPrefixesAvailableIpsList Method for IpamPrefixesAvailableIpsList

Get a IP address object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamPrefixesAvailableIpsListRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailableIpsList(ctx context.Context, id int32) ApiIpamPrefixesAvailableIpsListRequest {
	return ApiIpamPrefixesAvailableIpsListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []AvailableIP
func (a *IpamAPIService) IpamPrefixesAvailableIpsListExecute(r ApiIpamPrefixesAvailableIpsListRequest) ([]AvailableIP, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AvailableIP
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailableIpsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailablePrefixesCreateRequest struct {
	ctx           context.Context
	ApiService    *IpamAPIService
	id            int32
	prefixRequest *[]PrefixRequest
}

func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) PrefixRequest(prefixRequest []PrefixRequest) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	r.prefixRequest = &prefixRequest
	return r
}

func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) Execute() ([]Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailablePrefixesCreateExecute(r)
}

/*
IpamPrefixesAvailablePrefixesCreate Method for IpamPrefixesAvailablePrefixesCreate

Post a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamPrefixesAvailablePrefixesCreateRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesCreate(ctx context.Context, id int32) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	return ApiIpamPrefixesAvailablePrefixesCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []Prefix
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesCreateExecute(r ApiIpamPrefixesAvailablePrefixesCreateRequest) ([]Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailablePrefixesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/available-prefixes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixRequest == nil {
		return localVarReturnValue, nil, reportError("prefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailablePrefixesListRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamPrefixesAvailablePrefixesListRequest) Execute() ([]AvailablePrefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailablePrefixesListExecute(r)
}

/*
IpamPrefixesAvailablePrefixesList Method for IpamPrefixesAvailablePrefixesList

Get a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamPrefixesAvailablePrefixesListRequest
*/
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesList(ctx context.Context, id int32) ApiIpamPrefixesAvailablePrefixesListRequest {
	return ApiIpamPrefixesAvailablePrefixesListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []AvailablePrefix
func (a *IpamAPIService) IpamPrefixesAvailablePrefixesListExecute(r ApiIpamPrefixesAvailablePrefixesListRequest) ([]AvailablePrefix, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AvailablePrefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesAvailablePrefixesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/available-prefixes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkDestroyRequest struct {
	ctx           context.Context
	ApiService    *IpamAPIService
	prefixRequest *[]PrefixRequest
}

func (r ApiIpamPrefixesBulkDestroyRequest) PrefixRequest(prefixRequest []PrefixRequest) ApiIpamPrefixesBulkDestroyRequest {
	r.prefixRequest = &prefixRequest
	return r
}

func (r ApiIpamPrefixesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixesBulkDestroyExecute(r)
}

/*
IpamPrefixesBulkDestroy Method for IpamPrefixesBulkDestroy

Delete a list of prefix objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamPrefixesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamPrefixesBulkDestroy(ctx context.Context) ApiIpamPrefixesBulkDestroyRequest {
	return ApiIpamPrefixesBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamPrefixesBulkDestroyExecute(r ApiIpamPrefixesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixRequest == nil {
		return nil, reportError("prefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkPartialUpdateRequest struct {
	ctx           context.Context
	ApiService    *IpamAPIService
	prefixRequest *[]PrefixRequest
}

func (r ApiIpamPrefixesBulkPartialUpdateRequest) PrefixRequest(prefixRequest []PrefixRequest) ApiIpamPrefixesBulkPartialUpdateRequest {
	r.prefixRequest = &prefixRequest
	return r
}

func (r ApiIpamPrefixesBulkPartialUpdateRequest) Execute() ([]Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesBulkPartialUpdateExecute(r)
}

/*
IpamPrefixesBulkPartialUpdate Method for IpamPrefixesBulkPartialUpdate

Patch a list of prefix objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamPrefixesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesBulkPartialUpdate(ctx context.Context) ApiIpamPrefixesBulkPartialUpdateRequest {
	return ApiIpamPrefixesBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Prefix
func (a *IpamAPIService) IpamPrefixesBulkPartialUpdateExecute(r ApiIpamPrefixesBulkPartialUpdateRequest) ([]Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixRequest == nil {
		return localVarReturnValue, nil, reportError("prefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkUpdateRequest struct {
	ctx           context.Context
	ApiService    *IpamAPIService
	prefixRequest *[]PrefixRequest
}

func (r ApiIpamPrefixesBulkUpdateRequest) PrefixRequest(prefixRequest []PrefixRequest) ApiIpamPrefixesBulkUpdateRequest {
	r.prefixRequest = &prefixRequest
	return r
}

func (r ApiIpamPrefixesBulkUpdateRequest) Execute() ([]Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesBulkUpdateExecute(r)
}

/*
IpamPrefixesBulkUpdate Method for IpamPrefixesBulkUpdate

Put a list of prefix objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamPrefixesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesBulkUpdate(ctx context.Context) ApiIpamPrefixesBulkUpdateRequest {
	return ApiIpamPrefixesBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Prefix
func (a *IpamAPIService) IpamPrefixesBulkUpdateExecute(r ApiIpamPrefixesBulkUpdateRequest) ([]Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixRequest == nil {
		return localVarReturnValue, nil, reportError("prefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesCreateRequest struct {
	ctx                   context.Context
	ApiService            *IpamAPIService
	writablePrefixRequest *WritablePrefixRequest
}

func (r ApiIpamPrefixesCreateRequest) WritablePrefixRequest(writablePrefixRequest WritablePrefixRequest) ApiIpamPrefixesCreateRequest {
	r.writablePrefixRequest = &writablePrefixRequest
	return r
}

func (r ApiIpamPrefixesCreateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesCreateExecute(r)
}

/*
IpamPrefixesCreate Method for IpamPrefixesCreate

Post a list of prefix objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamPrefixesCreateRequest
*/
func (a *IpamAPIService) IpamPrefixesCreate(ctx context.Context) ApiIpamPrefixesCreateRequest {
	return ApiIpamPrefixesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Prefix
func (a *IpamAPIService) IpamPrefixesCreateExecute(r ApiIpamPrefixesCreateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePrefixRequest == nil {
		return localVarReturnValue, nil, reportError("writablePrefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePrefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamPrefixesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixesDestroyExecute(r)
}

/*
IpamPrefixesDestroy Method for IpamPrefixesDestroy

Delete a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this prefix.
	@return ApiIpamPrefixesDestroyRequest
*/
func (a *IpamAPIService) IpamPrefixesDestroy(ctx context.Context, id int32) ApiIpamPrefixesDestroyRequest {
	return ApiIpamPrefixesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamPrefixesDestroyExecute(r ApiIpamPrefixesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixesListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	children          *[]int32
	childrenEmpty     *[]int32
	childrenGt        *[]int32
	childrenGte       *[]int32
	childrenLt        *[]int32
	childrenLte       *[]int32
	childrenN         *[]int32
	contains          *string
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	depth             *[]int32
	depthEmpty        *[]int32
	depthGt           *[]int32
	depthGte          *[]int32
	depthLt           *[]int32
	depthLte          *[]int32
	depthN            *[]int32
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	family            *float32
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	isPool            *bool
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	markUtilized      *bool
	maskLength        *[]int32
	maskLengthGte     *float32
	maskLengthLte     *float32
	modifiedByRequest *string
	offset            *int32
	ordering          *string
	prefix            *[]string
	presentInVrf      *string
	presentInVrfId    *string
	q                 *string
	region            *[]string
	regionN           *[]string
	regionId          *[]string
	regionIdN         *[]string
	role              *[]string
	roleN             *[]string
	roleId            *[]*int32
	roleIdN           *[]*int32
	site              *[]string
	siteN             *[]string
	siteGroup         *[]string
	siteGroupN        *[]string
	siteGroupId       *[]string
	siteGroupIdN      *[]string
	siteId            *[]*int32
	siteIdN           *[]*int32
	status            *[]string
	statusN           *[]string
	tag               *[]string
	tagN              *[]string
	tenant            *[]string
	tenantN           *[]string
	tenantGroup       *[]string
	tenantGroupN      *[]string
	tenantGroupId     *[]string
	tenantGroupIdN    *[]string
	tenantId          *[]*int32
	tenantIdN         *[]*int32
	updatedByRequest  *string
	vlanId            *[]*int32
	vlanIdN           *[]*int32
	vlanVid           *int32
	vlanVidEmpty      *int32
	vlanVidGt         *int32
	vlanVidGte        *int32
	vlanVidLt         *int32
	vlanVidLte        *int32
	vlanVidN          *int32
	vrf               *[]*string
	vrfN              *[]*string
	vrfId             *[]*int32
	vrfIdN            *[]*int32
	within            *string
	withinInclude     *string
}

func (r ApiIpamPrefixesListRequest) Children(children []int32) ApiIpamPrefixesListRequest {
	r.children = &children
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenEmpty(childrenEmpty []int32) ApiIpamPrefixesListRequest {
	r.childrenEmpty = &childrenEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenGt(childrenGt []int32) ApiIpamPrefixesListRequest {
	r.childrenGt = &childrenGt
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenGte(childrenGte []int32) ApiIpamPrefixesListRequest {
	r.childrenGte = &childrenGte
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenLt(childrenLt []int32) ApiIpamPrefixesListRequest {
	r.childrenLt = &childrenLt
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenLte(childrenLte []int32) ApiIpamPrefixesListRequest {
	r.childrenLte = &childrenLte
	return r
}

func (r ApiIpamPrefixesListRequest) ChildrenN(childrenN []int32) ApiIpamPrefixesListRequest {
	r.childrenN = &childrenN
	return r
}

// Prefixes which contain this prefix or IP
func (r ApiIpamPrefixesListRequest) Contains(contains string) ApiIpamPrefixesListRequest {
	r.contains = &contains
	return r
}

func (r ApiIpamPrefixesListRequest) Created(created []time.Time) ApiIpamPrefixesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamPrefixesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedGt(createdGt []time.Time) ApiIpamPrefixesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedGte(createdGte []time.Time) ApiIpamPrefixesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedLt(createdLt []time.Time) ApiIpamPrefixesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedLte(createdLte []time.Time) ApiIpamPrefixesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedN(createdN []time.Time) ApiIpamPrefixesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedByRequest(createdByRequest string) ApiIpamPrefixesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamPrefixesListRequest) Depth(depth []int32) ApiIpamPrefixesListRequest {
	r.depth = &depth
	return r
}

func (r ApiIpamPrefixesListRequest) DepthEmpty(depthEmpty []int32) ApiIpamPrefixesListRequest {
	r.depthEmpty = &depthEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) DepthGt(depthGt []int32) ApiIpamPrefixesListRequest {
	r.depthGt = &depthGt
	return r
}

func (r ApiIpamPrefixesListRequest) DepthGte(depthGte []int32) ApiIpamPrefixesListRequest {
	r.depthGte = &depthGte
	return r
}

func (r ApiIpamPrefixesListRequest) DepthLt(depthLt []int32) ApiIpamPrefixesListRequest {
	r.depthLt = &depthLt
	return r
}

func (r ApiIpamPrefixesListRequest) DepthLte(depthLte []int32) ApiIpamPrefixesListRequest {
	r.depthLte = &depthLte
	return r
}

func (r ApiIpamPrefixesListRequest) DepthN(depthN []int32) ApiIpamPrefixesListRequest {
	r.depthN = &depthN
	return r
}

func (r ApiIpamPrefixesListRequest) Description(description []string) ApiIpamPrefixesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamPrefixesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionIc(descriptionIc []string) ApiIpamPrefixesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionIe(descriptionIe []string) ApiIpamPrefixesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionIew(descriptionIew []string) ApiIpamPrefixesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamPrefixesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionN(descriptionN []string) ApiIpamPrefixesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionNic(descriptionNic []string) ApiIpamPrefixesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionNie(descriptionNie []string) ApiIpamPrefixesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamPrefixesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamPrefixesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamPrefixesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamPrefixesListRequest) Family(family float32) ApiIpamPrefixesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamPrefixesListRequest) Id(id []int32) ApiIpamPrefixesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamPrefixesListRequest) IdEmpty(idEmpty bool) ApiIpamPrefixesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) IdGt(idGt []int32) ApiIpamPrefixesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamPrefixesListRequest) IdGte(idGte []int32) ApiIpamPrefixesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamPrefixesListRequest) IdLt(idLt []int32) ApiIpamPrefixesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamPrefixesListRequest) IdLte(idLte []int32) ApiIpamPrefixesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamPrefixesListRequest) IdN(idN []int32) ApiIpamPrefixesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamPrefixesListRequest) IsPool(isPool bool) ApiIpamPrefixesListRequest {
	r.isPool = &isPool
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixesListRequest) Limit(limit int32) ApiIpamPrefixesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamPrefixesListRequest) MarkUtilized(markUtilized bool) ApiIpamPrefixesListRequest {
	r.markUtilized = &markUtilized
	return r
}

func (r ApiIpamPrefixesListRequest) MaskLength(maskLength []int32) ApiIpamPrefixesListRequest {
	r.maskLength = &maskLength
	return r
}

func (r ApiIpamPrefixesListRequest) MaskLengthGte(maskLengthGte float32) ApiIpamPrefixesListRequest {
	r.maskLengthGte = &maskLengthGte
	return r
}

func (r ApiIpamPrefixesListRequest) MaskLengthLte(maskLengthLte float32) ApiIpamPrefixesListRequest {
	r.maskLengthLte = &maskLengthLte
	return r
}

func (r ApiIpamPrefixesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamPrefixesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesListRequest) Offset(offset int32) ApiIpamPrefixesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamPrefixesListRequest) Ordering(ordering string) ApiIpamPrefixesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamPrefixesListRequest) Prefix(prefix []string) ApiIpamPrefixesListRequest {
	r.prefix = &prefix
	return r
}

func (r ApiIpamPrefixesListRequest) PresentInVrf(presentInVrf string) ApiIpamPrefixesListRequest {
	r.presentInVrf = &presentInVrf
	return r
}

func (r ApiIpamPrefixesListRequest) PresentInVrfId(presentInVrfId string) ApiIpamPrefixesListRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

// Search
func (r ApiIpamPrefixesListRequest) Q(q string) ApiIpamPrefixesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamPrefixesListRequest) Region(region []string) ApiIpamPrefixesListRequest {
	r.region = &region
	return r
}

func (r ApiIpamPrefixesListRequest) RegionN(regionN []string) ApiIpamPrefixesListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiIpamPrefixesListRequest) RegionId(regionId []string) ApiIpamPrefixesListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiIpamPrefixesListRequest) RegionIdN(regionIdN []string) ApiIpamPrefixesListRequest {
	r.regionIdN = &regionIdN
	return r
}

// Role (slug)
func (r ApiIpamPrefixesListRequest) Role(role []string) ApiIpamPrefixesListRequest {
	r.role = &role
	return r
}

// Role (slug)
func (r ApiIpamPrefixesListRequest) RoleN(roleN []string) ApiIpamPrefixesListRequest {
	r.roleN = &roleN
	return r
}

// Role (ID)
func (r ApiIpamPrefixesListRequest) RoleId(roleId []*int32) ApiIpamPrefixesListRequest {
	r.roleId = &roleId
	return r
}

// Role (ID)
func (r ApiIpamPrefixesListRequest) RoleIdN(roleIdN []*int32) ApiIpamPrefixesListRequest {
	r.roleIdN = &roleIdN
	return r
}

// Site (slug)
func (r ApiIpamPrefixesListRequest) Site(site []string) ApiIpamPrefixesListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiIpamPrefixesListRequest) SiteN(siteN []string) ApiIpamPrefixesListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroup(siteGroup []string) ApiIpamPrefixesListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroupN(siteGroupN []string) ApiIpamPrefixesListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroupId(siteGroupId []string) ApiIpamPrefixesListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiIpamPrefixesListRequest) SiteGroupIdN(siteGroupIdN []string) ApiIpamPrefixesListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

// Site (ID)
func (r ApiIpamPrefixesListRequest) SiteId(siteId []*int32) ApiIpamPrefixesListRequest {
	r.siteId = &siteId
	return r
}

// Site (ID)
func (r ApiIpamPrefixesListRequest) SiteIdN(siteIdN []*int32) ApiIpamPrefixesListRequest {
	r.siteIdN = &siteIdN
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) Status(status []string) ApiIpamPrefixesListRequest {
	r.status = &status
	return r
}

// Operational status of this prefix
func (r ApiIpamPrefixesListRequest) StatusN(statusN []string) ApiIpamPrefixesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamPrefixesListRequest) Tag(tag []string) ApiIpamPrefixesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamPrefixesListRequest) TagN(tagN []string) ApiIpamPrefixesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamPrefixesListRequest) Tenant(tenant []string) ApiIpamPrefixesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamPrefixesListRequest) TenantN(tenantN []string) ApiIpamPrefixesListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroup(tenantGroup []string) ApiIpamPrefixesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamPrefixesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamPrefixesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamPrefixesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamPrefixesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamPrefixesListRequest) TenantId(tenantId []*int32) ApiIpamPrefixesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamPrefixesListRequest) TenantIdN(tenantIdN []*int32) ApiIpamPrefixesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamPrefixesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamPrefixesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

// VLAN (ID)
func (r ApiIpamPrefixesListRequest) VlanId(vlanId []*int32) ApiIpamPrefixesListRequest {
	r.vlanId = &vlanId
	return r
}

// VLAN (ID)
func (r ApiIpamPrefixesListRequest) VlanIdN(vlanIdN []*int32) ApiIpamPrefixesListRequest {
	r.vlanIdN = &vlanIdN
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVid(vlanVid int32) ApiIpamPrefixesListRequest {
	r.vlanVid = &vlanVid
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidEmpty(vlanVidEmpty int32) ApiIpamPrefixesListRequest {
	r.vlanVidEmpty = &vlanVidEmpty
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidGt(vlanVidGt int32) ApiIpamPrefixesListRequest {
	r.vlanVidGt = &vlanVidGt
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidGte(vlanVidGte int32) ApiIpamPrefixesListRequest {
	r.vlanVidGte = &vlanVidGte
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidLt(vlanVidLt int32) ApiIpamPrefixesListRequest {
	r.vlanVidLt = &vlanVidLt
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidLte(vlanVidLte int32) ApiIpamPrefixesListRequest {
	r.vlanVidLte = &vlanVidLte
	return r
}

// VLAN number (1-4094)
func (r ApiIpamPrefixesListRequest) VlanVidN(vlanVidN int32) ApiIpamPrefixesListRequest {
	r.vlanVidN = &vlanVidN
	return r
}

// VRF (RD)
func (r ApiIpamPrefixesListRequest) Vrf(vrf []*string) ApiIpamPrefixesListRequest {
	r.vrf = &vrf
	return r
}

// VRF (RD)
func (r ApiIpamPrefixesListRequest) VrfN(vrfN []*string) ApiIpamPrefixesListRequest {
	r.vrfN = &vrfN
	return r
}

// VRF
func (r ApiIpamPrefixesListRequest) VrfId(vrfId []*int32) ApiIpamPrefixesListRequest {
	r.vrfId = &vrfId
	return r
}

// VRF
func (r ApiIpamPrefixesListRequest) VrfIdN(vrfIdN []*int32) ApiIpamPrefixesListRequest {
	r.vrfIdN = &vrfIdN
	return r
}

// Within prefix
func (r ApiIpamPrefixesListRequest) Within(within string) ApiIpamPrefixesListRequest {
	r.within = &within
	return r
}

// Within and including prefix
func (r ApiIpamPrefixesListRequest) WithinInclude(withinInclude string) ApiIpamPrefixesListRequest {
	r.withinInclude = &withinInclude
	return r
}

func (r ApiIpamPrefixesListRequest) Execute() (*PaginatedPrefixList, *http.Response, error) {
	return r.ApiService.IpamPrefixesListExecute(r)
}

/*
IpamPrefixesList Method for IpamPrefixesList

Get a list of prefix objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamPrefixesListRequest
*/
func (a *IpamAPIService) IpamPrefixesList(ctx context.Context) ApiIpamPrefixesListRequest {
	return ApiIpamPrefixesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedPrefixList
func (a *IpamAPIService) IpamPrefixesListExecute(r ApiIpamPrefixesListRequest) (*PaginatedPrefixList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedPrefixList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.children != nil {
		t := *r.children
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children", t, "multi")
		}
	}
	if r.childrenEmpty != nil {
		t := *r.childrenEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__empty", t, "multi")
		}
	}
	if r.childrenGt != nil {
		t := *r.childrenGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__gt", t, "multi")
		}
	}
	if r.childrenGte != nil {
		t := *r.childrenGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__gte", t, "multi")
		}
	}
	if r.childrenLt != nil {
		t := *r.childrenLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__lt", t, "multi")
		}
	}
	if r.childrenLte != nil {
		t := *r.childrenLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__lte", t, "multi")
		}
	}
	if r.childrenN != nil {
		t := *r.childrenN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "children__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "children__n", t, "multi")
		}
	}
	if r.contains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contains", r.contains, "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.depth != nil {
		t := *r.depth
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth", t, "multi")
		}
	}
	if r.depthEmpty != nil {
		t := *r.depthEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__empty", t, "multi")
		}
	}
	if r.depthGt != nil {
		t := *r.depthGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__gt", t, "multi")
		}
	}
	if r.depthGte != nil {
		t := *r.depthGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__gte", t, "multi")
		}
	}
	if r.depthLt != nil {
		t := *r.depthLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__lt", t, "multi")
		}
	}
	if r.depthLte != nil {
		t := *r.depthLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__lte", t, "multi")
		}
	}
	if r.depthN != nil {
		t := *r.depthN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "depth__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "depth__n", t, "multi")
		}
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.family != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "family", r.family, "")
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.isPool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_pool", r.isPool, "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.markUtilized != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mark_utilized", r.markUtilized, "")
	}
	if r.maskLength != nil {
		t := *r.maskLength
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length", t, "multi")
		}
	}
	if r.maskLengthGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__gte", r.maskLengthGte, "")
	}
	if r.maskLengthLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mask_length__lte", r.maskLengthLte, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.prefix != nil {
		t := *r.prefix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", t, "multi")
		}
	}
	if r.presentInVrf != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf", r.presentInVrf, "")
	}
	if r.presentInVrfId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "present_in_vrf_id", r.presentInVrfId, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.region != nil {
		t := *r.region
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region", t, "multi")
		}
	}
	if r.regionN != nil {
		t := *r.regionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region__n", t, "multi")
		}
	}
	if r.regionId != nil {
		t := *r.regionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region_id", t, "multi")
		}
	}
	if r.regionIdN != nil {
		t := *r.regionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region_id__n", t, "multi")
		}
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "multi")
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "multi")
		}
	}
	if r.roleId != nil {
		t := *r.roleId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", t, "multi")
		}
	}
	if r.roleIdN != nil {
		t := *r.roleIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", t, "multi")
		}
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site", t, "multi")
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", t, "multi")
		}
	}
	if r.siteGroup != nil {
		t := *r.siteGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group", t, "multi")
		}
	}
	if r.siteGroupN != nil {
		t := *r.siteGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group__n", t, "multi")
		}
	}
	if r.siteGroupId != nil {
		t := *r.siteGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id", t, "multi")
		}
	}
	if r.siteGroupIdN != nil {
		t := *r.siteGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id__n", t, "multi")
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", t, "multi")
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", t, "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	if r.vlanId != nil {
		t := *r.vlanId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id", t, "multi")
		}
	}
	if r.vlanIdN != nil {
		t := *r.vlanIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_id__n", t, "multi")
		}
	}
	if r.vlanVid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid", r.vlanVid, "")
	}
	if r.vlanVidEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__empty", r.vlanVidEmpty, "")
	}
	if r.vlanVidGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__gt", r.vlanVidGt, "")
	}
	if r.vlanVidGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__gte", r.vlanVidGte, "")
	}
	if r.vlanVidLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__lt", r.vlanVidLt, "")
	}
	if r.vlanVidLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__lte", r.vlanVidLte, "")
	}
	if r.vlanVidN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vlan_vid__n", r.vlanVidN, "")
	}
	if r.vrf != nil {
		t := *r.vrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf", t, "multi")
		}
	}
	if r.vrfN != nil {
		t := *r.vrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf__n", t, "multi")
		}
	}
	if r.vrfId != nil {
		t := *r.vrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id", t, "multi")
		}
	}
	if r.vrfIdN != nil {
		t := *r.vrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vrf_id__n", t, "multi")
		}
	}
	if r.within != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "within", r.within, "")
	}
	if r.withinInclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "within_include", r.withinInclude, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesPartialUpdateRequest struct {
	ctx                          context.Context
	ApiService                   *IpamAPIService
	id                           int32
	patchedWritablePrefixRequest *PatchedWritablePrefixRequest
}

func (r ApiIpamPrefixesPartialUpdateRequest) PatchedWritablePrefixRequest(patchedWritablePrefixRequest PatchedWritablePrefixRequest) ApiIpamPrefixesPartialUpdateRequest {
	r.patchedWritablePrefixRequest = &patchedWritablePrefixRequest
	return r
}

func (r ApiIpamPrefixesPartialUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesPartialUpdateExecute(r)
}

/*
IpamPrefixesPartialUpdate Method for IpamPrefixesPartialUpdate

Patch a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this prefix.
	@return ApiIpamPrefixesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesPartialUpdate(ctx context.Context, id int32) ApiIpamPrefixesPartialUpdateRequest {
	return ApiIpamPrefixesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Prefix
func (a *IpamAPIService) IpamPrefixesPartialUpdateExecute(r ApiIpamPrefixesPartialUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritablePrefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamPrefixesRetrieveRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesRetrieveExecute(r)
}

/*
IpamPrefixesRetrieve Method for IpamPrefixesRetrieve

Get a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this prefix.
	@return ApiIpamPrefixesRetrieveRequest
*/
func (a *IpamAPIService) IpamPrefixesRetrieve(ctx context.Context, id int32) ApiIpamPrefixesRetrieveRequest {
	return ApiIpamPrefixesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Prefix
func (a *IpamAPIService) IpamPrefixesRetrieveExecute(r ApiIpamPrefixesRetrieveRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesUpdateRequest struct {
	ctx                   context.Context
	ApiService            *IpamAPIService
	id                    int32
	writablePrefixRequest *WritablePrefixRequest
}

func (r ApiIpamPrefixesUpdateRequest) WritablePrefixRequest(writablePrefixRequest WritablePrefixRequest) ApiIpamPrefixesUpdateRequest {
	r.writablePrefixRequest = &writablePrefixRequest
	return r
}

func (r ApiIpamPrefixesUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesUpdateExecute(r)
}

/*
IpamPrefixesUpdate Method for IpamPrefixesUpdate

Put a prefix object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this prefix.
	@return ApiIpamPrefixesUpdateRequest
*/
func (a *IpamAPIService) IpamPrefixesUpdate(ctx context.Context, id int32) ApiIpamPrefixesUpdateRequest {
	return ApiIpamPrefixesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Prefix
func (a *IpamAPIService) IpamPrefixesUpdateExecute(r ApiIpamPrefixesUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamPrefixesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePrefixRequest == nil {
		return localVarReturnValue, nil, reportError("writablePrefixRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePrefixRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsBulkDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	rIRRequest *[]RIRRequest
}

func (r ApiIpamRirsBulkDestroyRequest) RIRRequest(rIRRequest []RIRRequest) ApiIpamRirsBulkDestroyRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRirsBulkDestroyExecute(r)
}

/*
IpamRirsBulkDestroy Method for IpamRirsBulkDestroy

Delete a list of RIR objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRirsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamRirsBulkDestroy(ctx context.Context) ApiIpamRirsBulkDestroyRequest {
	return ApiIpamRirsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRirsBulkDestroyExecute(r ApiIpamRirsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return nil, reportError("rIRRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRirsBulkPartialUpdateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	rIRRequest *[]RIRRequest
}

func (r ApiIpamRirsBulkPartialUpdateRequest) RIRRequest(rIRRequest []RIRRequest) ApiIpamRirsBulkPartialUpdateRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsBulkPartialUpdateRequest) Execute() ([]RIR, *http.Response, error) {
	return r.ApiService.IpamRirsBulkPartialUpdateExecute(r)
}

/*
IpamRirsBulkPartialUpdate Method for IpamRirsBulkPartialUpdate

Patch a list of RIR objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRirsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRirsBulkPartialUpdate(ctx context.Context) ApiIpamRirsBulkPartialUpdateRequest {
	return ApiIpamRirsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []RIR
func (a *IpamAPIService) IpamRirsBulkPartialUpdateExecute(r ApiIpamRirsBulkPartialUpdateRequest) ([]RIR, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return localVarReturnValue, nil, reportError("rIRRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsBulkUpdateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	rIRRequest *[]RIRRequest
}

func (r ApiIpamRirsBulkUpdateRequest) RIRRequest(rIRRequest []RIRRequest) ApiIpamRirsBulkUpdateRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsBulkUpdateRequest) Execute() ([]RIR, *http.Response, error) {
	return r.ApiService.IpamRirsBulkUpdateExecute(r)
}

/*
IpamRirsBulkUpdate Method for IpamRirsBulkUpdate

Put a list of RIR objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRirsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamRirsBulkUpdate(ctx context.Context) ApiIpamRirsBulkUpdateRequest {
	return ApiIpamRirsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []RIR
func (a *IpamAPIService) IpamRirsBulkUpdateExecute(r ApiIpamRirsBulkUpdateRequest) ([]RIR, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return localVarReturnValue, nil, reportError("rIRRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsCreateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	rIRRequest *RIRRequest
}

func (r ApiIpamRirsCreateRequest) RIRRequest(rIRRequest RIRRequest) ApiIpamRirsCreateRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsCreateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsCreateExecute(r)
}

/*
IpamRirsCreate Method for IpamRirsCreate

Post a list of RIR objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRirsCreateRequest
*/
func (a *IpamAPIService) IpamRirsCreate(ctx context.Context) ApiIpamRirsCreateRequest {
	return ApiIpamRirsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RIR
func (a *IpamAPIService) IpamRirsCreateExecute(r ApiIpamRirsCreateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return localVarReturnValue, nil, reportError("rIRRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamRirsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRirsDestroyExecute(r)
}

/*
IpamRirsDestroy Method for IpamRirsDestroy

Delete a RIR object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this RIR.
	@return ApiIpamRirsDestroyRequest
*/
func (a *IpamAPIService) IpamRirsDestroy(ctx context.Context, id int32) ApiIpamRirsDestroyRequest {
	return ApiIpamRirsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRirsDestroyExecute(r ApiIpamRirsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRirsListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	isPrivate         *bool
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	modifiedByRequest *string
	name              *[]string
	nameEmpty         *bool
	nameIc            *[]string
	nameIe            *[]string
	nameIew           *[]string
	nameIsw           *[]string
	nameN             *[]string
	nameNic           *[]string
	nameNie           *[]string
	nameNiew          *[]string
	nameNisw          *[]string
	offset            *int32
	ordering          *string
	q                 *string
	slug              *[]string
	slugEmpty         *bool
	slugIc            *[]string
	slugIe            *[]string
	slugIew           *[]string
	slugIsw           *[]string
	slugN             *[]string
	slugNic           *[]string
	slugNie           *[]string
	slugNiew          *[]string
	slugNisw          *[]string
	tag               *[]string
	tagN              *[]string
	updatedByRequest  *string
}

func (r ApiIpamRirsListRequest) Created(created []time.Time) ApiIpamRirsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRirsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamRirsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamRirsListRequest) CreatedGt(createdGt []time.Time) ApiIpamRirsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamRirsListRequest) CreatedGte(createdGte []time.Time) ApiIpamRirsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRirsListRequest) CreatedLt(createdLt []time.Time) ApiIpamRirsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamRirsListRequest) CreatedLte(createdLte []time.Time) ApiIpamRirsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRirsListRequest) CreatedN(createdN []time.Time) ApiIpamRirsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamRirsListRequest) CreatedByRequest(createdByRequest string) ApiIpamRirsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamRirsListRequest) Description(description []string) ApiIpamRirsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamRirsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamRirsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIc(descriptionIc []string) ApiIpamRirsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIe(descriptionIe []string) ApiIpamRirsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIew(descriptionIew []string) ApiIpamRirsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamRirsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamRirsListRequest) DescriptionN(descriptionN []string) ApiIpamRirsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNic(descriptionNic []string) ApiIpamRirsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNie(descriptionNie []string) ApiIpamRirsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamRirsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamRirsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamRirsListRequest) Id(id []int32) ApiIpamRirsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRirsListRequest) IdEmpty(idEmpty bool) ApiIpamRirsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamRirsListRequest) IdGt(idGt []int32) ApiIpamRirsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamRirsListRequest) IdGte(idGte []int32) ApiIpamRirsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamRirsListRequest) IdLt(idLt []int32) ApiIpamRirsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamRirsListRequest) IdLte(idLte []int32) ApiIpamRirsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamRirsListRequest) IdN(idN []int32) ApiIpamRirsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRirsListRequest) IsPrivate(isPrivate bool) ApiIpamRirsListRequest {
	r.isPrivate = &isPrivate
	return r
}

func (r ApiIpamRirsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamRirsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamRirsListRequest) Limit(limit int32) ApiIpamRirsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamRirsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamRirsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamRirsListRequest) Name(name []string) ApiIpamRirsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRirsListRequest) NameEmpty(nameEmpty bool) ApiIpamRirsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamRirsListRequest) NameIc(nameIc []string) ApiIpamRirsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRirsListRequest) NameIe(nameIe []string) ApiIpamRirsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRirsListRequest) NameIew(nameIew []string) ApiIpamRirsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRirsListRequest) NameIsw(nameIsw []string) ApiIpamRirsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRirsListRequest) NameN(nameN []string) ApiIpamRirsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRirsListRequest) NameNic(nameNic []string) ApiIpamRirsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRirsListRequest) NameNie(nameNie []string) ApiIpamRirsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRirsListRequest) NameNiew(nameNiew []string) ApiIpamRirsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRirsListRequest) NameNisw(nameNisw []string) ApiIpamRirsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRirsListRequest) Offset(offset int32) ApiIpamRirsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamRirsListRequest) Ordering(ordering string) ApiIpamRirsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamRirsListRequest) Q(q string) ApiIpamRirsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRirsListRequest) Slug(slug []string) ApiIpamRirsListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamRirsListRequest) SlugEmpty(slugEmpty bool) ApiIpamRirsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiIpamRirsListRequest) SlugIc(slugIc []string) ApiIpamRirsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamRirsListRequest) SlugIe(slugIe []string) ApiIpamRirsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamRirsListRequest) SlugIew(slugIew []string) ApiIpamRirsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamRirsListRequest) SlugIsw(slugIsw []string) ApiIpamRirsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamRirsListRequest) SlugN(slugN []string) ApiIpamRirsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamRirsListRequest) SlugNic(slugNic []string) ApiIpamRirsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamRirsListRequest) SlugNie(slugNie []string) ApiIpamRirsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamRirsListRequest) SlugNiew(slugNiew []string) ApiIpamRirsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamRirsListRequest) SlugNisw(slugNisw []string) ApiIpamRirsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamRirsListRequest) Tag(tag []string) ApiIpamRirsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamRirsListRequest) TagN(tagN []string) ApiIpamRirsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamRirsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamRirsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamRirsListRequest) Execute() (*PaginatedRIRList, *http.Response, error) {
	return r.ApiService.IpamRirsListExecute(r)
}

/*
IpamRirsList Method for IpamRirsList

Get a list of RIR objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRirsListRequest
*/
func (a *IpamAPIService) IpamRirsList(ctx context.Context) ApiIpamRirsListRequest {
	return ApiIpamRirsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedRIRList
func (a *IpamAPIService) IpamRirsListExecute(r ApiIpamRirsListRequest) (*PaginatedRIRList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedRIRList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.isPrivate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_private", r.isPrivate, "")
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug", t, "multi")
		}
	}
	if r.slugEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slug__empty", r.slugEmpty, "")
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", t, "multi")
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", t, "multi")
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", t, "multi")
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", t, "multi")
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", t, "multi")
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", t, "multi")
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", t, "multi")
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", t, "multi")
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsPartialUpdateRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	id                int32
	patchedRIRRequest *PatchedRIRRequest
}

func (r ApiIpamRirsPartialUpdateRequest) PatchedRIRRequest(patchedRIRRequest PatchedRIRRequest) ApiIpamRirsPartialUpdateRequest {
	r.patchedRIRRequest = &patchedRIRRequest
	return r
}

func (r ApiIpamRirsPartialUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsPartialUpdateExecute(r)
}

/*
IpamRirsPartialUpdate Method for IpamRirsPartialUpdate

Patch a RIR object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this RIR.
	@return ApiIpamRirsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRirsPartialUpdate(ctx context.Context, id int32) ApiIpamRirsPartialUpdateRequest {
	return ApiIpamRirsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return RIR
func (a *IpamAPIService) IpamRirsPartialUpdateExecute(r ApiIpamRirsPartialUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamRirsRetrieveRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsRetrieveExecute(r)
}

/*
IpamRirsRetrieve Method for IpamRirsRetrieve

Get a RIR object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this RIR.
	@return ApiIpamRirsRetrieveRequest
*/
func (a *IpamAPIService) IpamRirsRetrieve(ctx context.Context, id int32) ApiIpamRirsRetrieveRequest {
	return ApiIpamRirsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return RIR
func (a *IpamAPIService) IpamRirsRetrieveExecute(r ApiIpamRirsRetrieveRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsUpdateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
	rIRRequest *RIRRequest
}

func (r ApiIpamRirsUpdateRequest) RIRRequest(rIRRequest RIRRequest) ApiIpamRirsUpdateRequest {
	r.rIRRequest = &rIRRequest
	return r
}

func (r ApiIpamRirsUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsUpdateExecute(r)
}

/*
IpamRirsUpdate Method for IpamRirsUpdate

Put a RIR object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this RIR.
	@return ApiIpamRirsUpdateRequest
*/
func (a *IpamAPIService) IpamRirsUpdate(ctx context.Context, id int32) ApiIpamRirsUpdateRequest {
	return ApiIpamRirsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return RIR
func (a *IpamAPIService) IpamRirsUpdateExecute(r ApiIpamRirsUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRirsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIRRequest == nil {
		return localVarReturnValue, nil, reportError("rIRRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIRRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesBulkDestroyRequest struct {
	ctx         context.Context
	ApiService  *IpamAPIService
	roleRequest *[]RoleRequest
}

func (r ApiIpamRolesBulkDestroyRequest) RoleRequest(roleRequest []RoleRequest) ApiIpamRolesBulkDestroyRequest {
	r.roleRequest = &roleRequest
	return r
}

func (r ApiIpamRolesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRolesBulkDestroyExecute(r)
}

/*
IpamRolesBulkDestroy Method for IpamRolesBulkDestroy

Delete a list of role objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRolesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamRolesBulkDestroy(ctx context.Context) ApiIpamRolesBulkDestroyRequest {
	return ApiIpamRolesBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRolesBulkDestroyExecute(r ApiIpamRolesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleRequest == nil {
		return nil, reportError("roleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRolesBulkPartialUpdateRequest struct {
	ctx         context.Context
	ApiService  *IpamAPIService
	roleRequest *[]RoleRequest
}

func (r ApiIpamRolesBulkPartialUpdateRequest) RoleRequest(roleRequest []RoleRequest) ApiIpamRolesBulkPartialUpdateRequest {
	r.roleRequest = &roleRequest
	return r
}

func (r ApiIpamRolesBulkPartialUpdateRequest) Execute() ([]Role, *http.Response, error) {
	return r.ApiService.IpamRolesBulkPartialUpdateExecute(r)
}

/*
IpamRolesBulkPartialUpdate Method for IpamRolesBulkPartialUpdate

Patch a list of role objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRolesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRolesBulkPartialUpdate(ctx context.Context) ApiIpamRolesBulkPartialUpdateRequest {
	return ApiIpamRolesBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Role
func (a *IpamAPIService) IpamRolesBulkPartialUpdateExecute(r ApiIpamRolesBulkPartialUpdateRequest) ([]Role, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleRequest == nil {
		return localVarReturnValue, nil, reportError("roleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesBulkUpdateRequest struct {
	ctx         context.Context
	ApiService  *IpamAPIService
	roleRequest *[]RoleRequest
}

func (r ApiIpamRolesBulkUpdateRequest) RoleRequest(roleRequest []RoleRequest) ApiIpamRolesBulkUpdateRequest {
	r.roleRequest = &roleRequest
	return r
}

func (r ApiIpamRolesBulkUpdateRequest) Execute() ([]Role, *http.Response, error) {
	return r.ApiService.IpamRolesBulkUpdateExecute(r)
}

/*
IpamRolesBulkUpdate Method for IpamRolesBulkUpdate

Put a list of role objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRolesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamRolesBulkUpdate(ctx context.Context) ApiIpamRolesBulkUpdateRequest {
	return ApiIpamRolesBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Role
func (a *IpamAPIService) IpamRolesBulkUpdateExecute(r ApiIpamRolesBulkUpdateRequest) ([]Role, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleRequest == nil {
		return localVarReturnValue, nil, reportError("roleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesCreateRequest struct {
	ctx         context.Context
	ApiService  *IpamAPIService
	roleRequest *RoleRequest
}

func (r ApiIpamRolesCreateRequest) RoleRequest(roleRequest RoleRequest) ApiIpamRolesCreateRequest {
	r.roleRequest = &roleRequest
	return r
}

func (r ApiIpamRolesCreateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesCreateExecute(r)
}

/*
IpamRolesCreate Method for IpamRolesCreate

Post a list of role objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRolesCreateRequest
*/
func (a *IpamAPIService) IpamRolesCreate(ctx context.Context) ApiIpamRolesCreateRequest {
	return ApiIpamRolesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Role
func (a *IpamAPIService) IpamRolesCreateExecute(r ApiIpamRolesCreateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleRequest == nil {
		return localVarReturnValue, nil, reportError("roleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamRolesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRolesDestroyExecute(r)
}

/*
IpamRolesDestroy Method for IpamRolesDestroy

Delete a role object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this role.
	@return ApiIpamRolesDestroyRequest
*/
func (a *IpamAPIService) IpamRolesDestroy(ctx context.Context, id int32) ApiIpamRolesDestroyRequest {
	return ApiIpamRolesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRolesDestroyExecute(r ApiIpamRolesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRolesListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	modifiedByRequest *string
	name              *[]string
	nameEmpty         *bool
	nameIc            *[]string
	nameIe            *[]string
	nameIew           *[]string
	nameIsw           *[]string
	nameN             *[]string
	nameNic           *[]string
	nameNie           *[]string
	nameNiew          *[]string
	nameNisw          *[]string
	offset            *int32
	ordering          *string
	q                 *string
	slug              *[]string
	slugEmpty         *bool
	slugIc            *[]string
	slugIe            *[]string
	slugIew           *[]string
	slugIsw           *[]string
	slugN             *[]string
	slugNic           *[]string
	slugNie           *[]string
	slugNiew          *[]string
	slugNisw          *[]string
	tag               *[]string
	tagN              *[]string
	updatedByRequest  *string
	weight            *[]int32
	weightEmpty       *bool
	weightGt          *[]int32
	weightGte         *[]int32
	weightLt          *[]int32
	weightLte         *[]int32
	weightN           *[]int32
}

func (r ApiIpamRolesListRequest) Created(created []time.Time) ApiIpamRolesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRolesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamRolesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamRolesListRequest) CreatedGt(createdGt []time.Time) ApiIpamRolesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamRolesListRequest) CreatedGte(createdGte []time.Time) ApiIpamRolesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRolesListRequest) CreatedLt(createdLt []time.Time) ApiIpamRolesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamRolesListRequest) CreatedLte(createdLte []time.Time) ApiIpamRolesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRolesListRequest) CreatedN(createdN []time.Time) ApiIpamRolesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamRolesListRequest) CreatedByRequest(createdByRequest string) ApiIpamRolesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamRolesListRequest) Description(description []string) ApiIpamRolesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamRolesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamRolesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamRolesListRequest) DescriptionIc(descriptionIc []string) ApiIpamRolesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamRolesListRequest) DescriptionIe(descriptionIe []string) ApiIpamRolesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamRolesListRequest) DescriptionIew(descriptionIew []string) ApiIpamRolesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamRolesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamRolesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamRolesListRequest) DescriptionN(descriptionN []string) ApiIpamRolesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamRolesListRequest) DescriptionNic(descriptionNic []string) ApiIpamRolesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamRolesListRequest) DescriptionNie(descriptionNie []string) ApiIpamRolesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamRolesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamRolesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamRolesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamRolesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamRolesListRequest) Id(id []int32) ApiIpamRolesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRolesListRequest) IdEmpty(idEmpty bool) ApiIpamRolesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamRolesListRequest) IdGt(idGt []int32) ApiIpamRolesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamRolesListRequest) IdGte(idGte []int32) ApiIpamRolesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamRolesListRequest) IdLt(idLt []int32) ApiIpamRolesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamRolesListRequest) IdLte(idLte []int32) ApiIpamRolesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamRolesListRequest) IdN(idN []int32) ApiIpamRolesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRolesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamRolesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamRolesListRequest) Limit(limit int32) ApiIpamRolesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamRolesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamRolesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamRolesListRequest) Name(name []string) ApiIpamRolesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRolesListRequest) NameEmpty(nameEmpty bool) ApiIpamRolesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamRolesListRequest) NameIc(nameIc []string) ApiIpamRolesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRolesListRequest) NameIe(nameIe []string) ApiIpamRolesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRolesListRequest) NameIew(nameIew []string) ApiIpamRolesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRolesListRequest) NameIsw(nameIsw []string) ApiIpamRolesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRolesListRequest) NameN(nameN []string) ApiIpamRolesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRolesListRequest) NameNic(nameNic []string) ApiIpamRolesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRolesListRequest) NameNie(nameNie []string) ApiIpamRolesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRolesListRequest) NameNiew(nameNiew []string) ApiIpamRolesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRolesListRequest) NameNisw(nameNisw []string) ApiIpamRolesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRolesListRequest) Offset(offset int32) ApiIpamRolesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamRolesListRequest) Ordering(ordering string) ApiIpamRolesListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamRolesListRequest) Q(q string) ApiIpamRolesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRolesListRequest) Slug(slug []string) ApiIpamRolesListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamRolesListRequest) SlugEmpty(slugEmpty bool) ApiIpamRolesListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiIpamRolesListRequest) SlugIc(slugIc []string) ApiIpamRolesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamRolesListRequest) SlugIe(slugIe []string) ApiIpamRolesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamRolesListRequest) SlugIew(slugIew []string) ApiIpamRolesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamRolesListRequest) SlugIsw(slugIsw []string) ApiIpamRolesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamRolesListRequest) SlugN(slugN []string) ApiIpamRolesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamRolesListRequest) SlugNic(slugNic []string) ApiIpamRolesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamRolesListRequest) SlugNie(slugNie []string) ApiIpamRolesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamRolesListRequest) SlugNiew(slugNiew []string) ApiIpamRolesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamRolesListRequest) SlugNisw(slugNisw []string) ApiIpamRolesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamRolesListRequest) Tag(tag []string) ApiIpamRolesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamRolesListRequest) TagN(tagN []string) ApiIpamRolesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamRolesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamRolesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamRolesListRequest) Weight(weight []int32) ApiIpamRolesListRequest {
	r.weight = &weight
	return r
}

func (r ApiIpamRolesListRequest) WeightEmpty(weightEmpty bool) ApiIpamRolesListRequest {
	r.weightEmpty = &weightEmpty
	return r
}

func (r ApiIpamRolesListRequest) WeightGt(weightGt []int32) ApiIpamRolesListRequest {
	r.weightGt = &weightGt
	return r
}

func (r ApiIpamRolesListRequest) WeightGte(weightGte []int32) ApiIpamRolesListRequest {
	r.weightGte = &weightGte
	return r
}

func (r ApiIpamRolesListRequest) WeightLt(weightLt []int32) ApiIpamRolesListRequest {
	r.weightLt = &weightLt
	return r
}

func (r ApiIpamRolesListRequest) WeightLte(weightLte []int32) ApiIpamRolesListRequest {
	r.weightLte = &weightLte
	return r
}

func (r ApiIpamRolesListRequest) WeightN(weightN []int32) ApiIpamRolesListRequest {
	r.weightN = &weightN
	return r
}

func (r ApiIpamRolesListRequest) Execute() (*PaginatedRoleList, *http.Response, error) {
	return r.ApiService.IpamRolesListExecute(r)
}

/*
IpamRolesList Method for IpamRolesList

Get a list of role objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRolesListRequest
*/
func (a *IpamAPIService) IpamRolesList(ctx context.Context) ApiIpamRolesListRequest {
	return ApiIpamRolesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedRoleList
func (a *IpamAPIService) IpamRolesListExecute(r ApiIpamRolesListRequest) (*PaginatedRoleList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedRoleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug", t, "multi")
		}
	}
	if r.slugEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slug__empty", r.slugEmpty, "")
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", t, "multi")
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", t, "multi")
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", t, "multi")
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", t, "multi")
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", t, "multi")
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", t, "multi")
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", t, "multi")
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", t, "multi")
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	if r.weight != nil {
		t := *r.weight
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight", t, "multi")
		}
	}
	if r.weightEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "weight__empty", r.weightEmpty, "")
	}
	if r.weightGt != nil {
		t := *r.weightGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gt", t, "multi")
		}
	}
	if r.weightGte != nil {
		t := *r.weightGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__gte", t, "multi")
		}
	}
	if r.weightLt != nil {
		t := *r.weightLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lt", t, "multi")
		}
	}
	if r.weightLte != nil {
		t := *r.weightLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__lte", t, "multi")
		}
	}
	if r.weightN != nil {
		t := *r.weightN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "weight__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "weight__n", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesPartialUpdateRequest struct {
	ctx                context.Context
	ApiService         *IpamAPIService
	id                 int32
	patchedRoleRequest *PatchedRoleRequest
}

func (r ApiIpamRolesPartialUpdateRequest) PatchedRoleRequest(patchedRoleRequest PatchedRoleRequest) ApiIpamRolesPartialUpdateRequest {
	r.patchedRoleRequest = &patchedRoleRequest
	return r
}

func (r ApiIpamRolesPartialUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesPartialUpdateExecute(r)
}

/*
IpamRolesPartialUpdate Method for IpamRolesPartialUpdate

Patch a role object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this role.
	@return ApiIpamRolesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRolesPartialUpdate(ctx context.Context, id int32) ApiIpamRolesPartialUpdateRequest {
	return ApiIpamRolesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Role
func (a *IpamAPIService) IpamRolesPartialUpdateExecute(r ApiIpamRolesPartialUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRoleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamRolesRetrieveRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesRetrieveExecute(r)
}

/*
IpamRolesRetrieve Method for IpamRolesRetrieve

Get a role object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this role.
	@return ApiIpamRolesRetrieveRequest
*/
func (a *IpamAPIService) IpamRolesRetrieve(ctx context.Context, id int32) ApiIpamRolesRetrieveRequest {
	return ApiIpamRolesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Role
func (a *IpamAPIService) IpamRolesRetrieveExecute(r ApiIpamRolesRetrieveRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesUpdateRequest struct {
	ctx         context.Context
	ApiService  *IpamAPIService
	id          int32
	roleRequest *RoleRequest
}

func (r ApiIpamRolesUpdateRequest) RoleRequest(roleRequest RoleRequest) ApiIpamRolesUpdateRequest {
	r.roleRequest = &roleRequest
	return r
}

func (r ApiIpamRolesUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesUpdateExecute(r)
}

/*
IpamRolesUpdate Method for IpamRolesUpdate

Put a role object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this role.
	@return ApiIpamRolesUpdateRequest
*/
func (a *IpamAPIService) IpamRolesUpdate(ctx context.Context, id int32) ApiIpamRolesUpdateRequest {
	return ApiIpamRolesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Role
func (a *IpamAPIService) IpamRolesUpdateExecute(r ApiIpamRolesUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRolesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleRequest == nil {
		return localVarReturnValue, nil, reportError("roleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkDestroyRequest struct {
	ctx                context.Context
	ApiService         *IpamAPIService
	routeTargetRequest *[]RouteTargetRequest
}

func (r ApiIpamRouteTargetsBulkDestroyRequest) RouteTargetRequest(routeTargetRequest []RouteTargetRequest) ApiIpamRouteTargetsBulkDestroyRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkDestroyExecute(r)
}

/*
IpamRouteTargetsBulkDestroy Method for IpamRouteTargetsBulkDestroy

Delete a list of route target objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRouteTargetsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamRouteTargetsBulkDestroy(ctx context.Context) ApiIpamRouteTargetsBulkDestroyRequest {
	return ApiIpamRouteTargetsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRouteTargetsBulkDestroyExecute(r ApiIpamRouteTargetsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return nil, reportError("routeTargetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkPartialUpdateRequest struct {
	ctx                context.Context
	ApiService         *IpamAPIService
	routeTargetRequest *[]RouteTargetRequest
}

func (r ApiIpamRouteTargetsBulkPartialUpdateRequest) RouteTargetRequest(routeTargetRequest []RouteTargetRequest) ApiIpamRouteTargetsBulkPartialUpdateRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsBulkPartialUpdateRequest) Execute() ([]RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkPartialUpdateExecute(r)
}

/*
IpamRouteTargetsBulkPartialUpdate Method for IpamRouteTargetsBulkPartialUpdate

Patch a list of route target objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRouteTargetsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsBulkPartialUpdate(ctx context.Context) ApiIpamRouteTargetsBulkPartialUpdateRequest {
	return ApiIpamRouteTargetsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []RouteTarget
func (a *IpamAPIService) IpamRouteTargetsBulkPartialUpdateExecute(r ApiIpamRouteTargetsBulkPartialUpdateRequest) ([]RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return localVarReturnValue, nil, reportError("routeTargetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkUpdateRequest struct {
	ctx                context.Context
	ApiService         *IpamAPIService
	routeTargetRequest *[]RouteTargetRequest
}

func (r ApiIpamRouteTargetsBulkUpdateRequest) RouteTargetRequest(routeTargetRequest []RouteTargetRequest) ApiIpamRouteTargetsBulkUpdateRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsBulkUpdateRequest) Execute() ([]RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkUpdateExecute(r)
}

/*
IpamRouteTargetsBulkUpdate Method for IpamRouteTargetsBulkUpdate

Put a list of route target objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRouteTargetsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsBulkUpdate(ctx context.Context) ApiIpamRouteTargetsBulkUpdateRequest {
	return ApiIpamRouteTargetsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []RouteTarget
func (a *IpamAPIService) IpamRouteTargetsBulkUpdateExecute(r ApiIpamRouteTargetsBulkUpdateRequest) ([]RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return localVarReturnValue, nil, reportError("routeTargetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsCreateRequest struct {
	ctx                context.Context
	ApiService         *IpamAPIService
	routeTargetRequest *RouteTargetRequest
}

func (r ApiIpamRouteTargetsCreateRequest) RouteTargetRequest(routeTargetRequest RouteTargetRequest) ApiIpamRouteTargetsCreateRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsCreateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsCreateExecute(r)
}

/*
IpamRouteTargetsCreate Method for IpamRouteTargetsCreate

Post a list of route target objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRouteTargetsCreateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsCreate(ctx context.Context) ApiIpamRouteTargetsCreateRequest {
	return ApiIpamRouteTargetsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsCreateExecute(r ApiIpamRouteTargetsCreateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return localVarReturnValue, nil, reportError("routeTargetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamRouteTargetsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRouteTargetsDestroyExecute(r)
}

/*
IpamRouteTargetsDestroy Method for IpamRouteTargetsDestroy

Delete a route target object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this route target.
	@return ApiIpamRouteTargetsDestroyRequest
*/
func (a *IpamAPIService) IpamRouteTargetsDestroy(ctx context.Context, id int32) ApiIpamRouteTargetsDestroyRequest {
	return ApiIpamRouteTargetsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamRouteTargetsDestroyExecute(r ApiIpamRouteTargetsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	exportingL2vpn    *[]*int64
	exportingL2vpnN   *[]*int64
	exportingL2vpnId  *[]int32
	exportingL2vpnIdN *[]int32
	exportingVrf      *[]*string
	exportingVrfN     *[]*string
	exportingVrfId    *[]int32
	exportingVrfIdN   *[]int32
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	importingL2vpn    *[]*int64
	importingL2vpnN   *[]*int64
	importingL2vpnId  *[]int32
	importingL2vpnIdN *[]int32
	importingVrf      *[]*string
	importingVrfN     *[]*string
	importingVrfId    *[]int32
	importingVrfIdN   *[]int32
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	modifiedByRequest *string
	name              *[]string
	nameEmpty         *bool
	nameIc            *[]string
	nameIe            *[]string
	nameIew           *[]string
	nameIsw           *[]string
	nameN             *[]string
	nameNic           *[]string
	nameNie           *[]string
	nameNiew          *[]string
	nameNisw          *[]string
	offset            *int32
	ordering          *string
	q                 *string
	tag               *[]string
	tagN              *[]string
	tenant            *[]string
	tenantN           *[]string
	tenantGroup       *[]string
	tenantGroupN      *[]string
	tenantGroupId     *[]string
	tenantGroupIdN    *[]string
	tenantId          *[]*int32
	tenantIdN         *[]*int32
	updatedByRequest  *string
}

func (r ApiIpamRouteTargetsListRequest) Created(created []time.Time) ApiIpamRouteTargetsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedGt(createdGt []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedGte(createdGte []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedLt(createdLt []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedLte(createdLte []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedN(createdN []time.Time) ApiIpamRouteTargetsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedByRequest(createdByRequest string) ApiIpamRouteTargetsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamRouteTargetsListRequest) Description(description []string) ApiIpamRouteTargetsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamRouteTargetsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionIc(descriptionIc []string) ApiIpamRouteTargetsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionIe(descriptionIe []string) ApiIpamRouteTargetsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionIew(descriptionIew []string) ApiIpamRouteTargetsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamRouteTargetsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionN(descriptionN []string) ApiIpamRouteTargetsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionNic(descriptionNic []string) ApiIpamRouteTargetsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionNie(descriptionNie []string) ApiIpamRouteTargetsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamRouteTargetsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamRouteTargetsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamRouteTargetsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Exporting L2VPN (identifier)
func (r ApiIpamRouteTargetsListRequest) ExportingL2vpn(exportingL2vpn []*int64) ApiIpamRouteTargetsListRequest {
	r.exportingL2vpn = &exportingL2vpn
	return r
}

// Exporting L2VPN (identifier)
func (r ApiIpamRouteTargetsListRequest) ExportingL2vpnN(exportingL2vpnN []*int64) ApiIpamRouteTargetsListRequest {
	r.exportingL2vpnN = &exportingL2vpnN
	return r
}

// Exporting L2VPN
func (r ApiIpamRouteTargetsListRequest) ExportingL2vpnId(exportingL2vpnId []int32) ApiIpamRouteTargetsListRequest {
	r.exportingL2vpnId = &exportingL2vpnId
	return r
}

// Exporting L2VPN
func (r ApiIpamRouteTargetsListRequest) ExportingL2vpnIdN(exportingL2vpnIdN []int32) ApiIpamRouteTargetsListRequest {
	r.exportingL2vpnIdN = &exportingL2vpnIdN
	return r
}

// Export VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ExportingVrf(exportingVrf []*string) ApiIpamRouteTargetsListRequest {
	r.exportingVrf = &exportingVrf
	return r
}

// Export VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ExportingVrfN(exportingVrfN []*string) ApiIpamRouteTargetsListRequest {
	r.exportingVrfN = &exportingVrfN
	return r
}

// Exporting VRF
func (r ApiIpamRouteTargetsListRequest) ExportingVrfId(exportingVrfId []int32) ApiIpamRouteTargetsListRequest {
	r.exportingVrfId = &exportingVrfId
	return r
}

// Exporting VRF
func (r ApiIpamRouteTargetsListRequest) ExportingVrfIdN(exportingVrfIdN []int32) ApiIpamRouteTargetsListRequest {
	r.exportingVrfIdN = &exportingVrfIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) Id(id []int32) ApiIpamRouteTargetsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdEmpty(idEmpty bool) ApiIpamRouteTargetsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdGt(idGt []int32) ApiIpamRouteTargetsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdGte(idGte []int32) ApiIpamRouteTargetsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdLt(idLt []int32) ApiIpamRouteTargetsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdLte(idLte []int32) ApiIpamRouteTargetsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdN(idN []int32) ApiIpamRouteTargetsListRequest {
	r.idN = &idN
	return r
}

// Importing L2VPN (identifier)
func (r ApiIpamRouteTargetsListRequest) ImportingL2vpn(importingL2vpn []*int64) ApiIpamRouteTargetsListRequest {
	r.importingL2vpn = &importingL2vpn
	return r
}

// Importing L2VPN (identifier)
func (r ApiIpamRouteTargetsListRequest) ImportingL2vpnN(importingL2vpnN []*int64) ApiIpamRouteTargetsListRequest {
	r.importingL2vpnN = &importingL2vpnN
	return r
}

// Importing L2VPN
func (r ApiIpamRouteTargetsListRequest) ImportingL2vpnId(importingL2vpnId []int32) ApiIpamRouteTargetsListRequest {
	r.importingL2vpnId = &importingL2vpnId
	return r
}

// Importing L2VPN
func (r ApiIpamRouteTargetsListRequest) ImportingL2vpnIdN(importingL2vpnIdN []int32) ApiIpamRouteTargetsListRequest {
	r.importingL2vpnIdN = &importingL2vpnIdN
	return r
}

// Import VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ImportingVrf(importingVrf []*string) ApiIpamRouteTargetsListRequest {
	r.importingVrf = &importingVrf
	return r
}

// Import VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ImportingVrfN(importingVrfN []*string) ApiIpamRouteTargetsListRequest {
	r.importingVrfN = &importingVrfN
	return r
}

// Importing VRF
func (r ApiIpamRouteTargetsListRequest) ImportingVrfId(importingVrfId []int32) ApiIpamRouteTargetsListRequest {
	r.importingVrfId = &importingVrfId
	return r
}

// Importing VRF
func (r ApiIpamRouteTargetsListRequest) ImportingVrfIdN(importingVrfIdN []int32) ApiIpamRouteTargetsListRequest {
	r.importingVrfIdN = &importingVrfIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamRouteTargetsListRequest) Limit(limit int32) ApiIpamRouteTargetsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamRouteTargetsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamRouteTargetsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamRouteTargetsListRequest) Name(name []string) ApiIpamRouteTargetsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameEmpty(nameEmpty bool) ApiIpamRouteTargetsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIc(nameIc []string) ApiIpamRouteTargetsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIe(nameIe []string) ApiIpamRouteTargetsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIew(nameIew []string) ApiIpamRouteTargetsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIsw(nameIsw []string) ApiIpamRouteTargetsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameN(nameN []string) ApiIpamRouteTargetsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNic(nameNic []string) ApiIpamRouteTargetsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNie(nameNie []string) ApiIpamRouteTargetsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNiew(nameNiew []string) ApiIpamRouteTargetsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNisw(nameNisw []string) ApiIpamRouteTargetsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRouteTargetsListRequest) Offset(offset int32) ApiIpamRouteTargetsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamRouteTargetsListRequest) Ordering(ordering string) ApiIpamRouteTargetsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamRouteTargetsListRequest) Q(q string) ApiIpamRouteTargetsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRouteTargetsListRequest) Tag(tag []string) ApiIpamRouteTargetsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamRouteTargetsListRequest) TagN(tagN []string) ApiIpamRouteTargetsListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamRouteTargetsListRequest) Tenant(tenant []string) ApiIpamRouteTargetsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamRouteTargetsListRequest) TenantN(tenantN []string) ApiIpamRouteTargetsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroup(tenantGroup []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroupN(tenantGroupN []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroupId(tenantGroupId []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamRouteTargetsListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamRouteTargetsListRequest) TenantId(tenantId []*int32) ApiIpamRouteTargetsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamRouteTargetsListRequest) TenantIdN(tenantIdN []*int32) ApiIpamRouteTargetsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamRouteTargetsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamRouteTargetsListRequest) Execute() (*PaginatedRouteTargetList, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsListExecute(r)
}

/*
IpamRouteTargetsList Method for IpamRouteTargetsList

Get a list of route target objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamRouteTargetsListRequest
*/
func (a *IpamAPIService) IpamRouteTargetsList(ctx context.Context) ApiIpamRouteTargetsListRequest {
	return ApiIpamRouteTargetsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedRouteTargetList
func (a *IpamAPIService) IpamRouteTargetsListExecute(r ApiIpamRouteTargetsListRequest) (*PaginatedRouteTargetList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedRouteTargetList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.exportingL2vpn != nil {
		t := *r.exportingL2vpn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn", t, "multi")
		}
	}
	if r.exportingL2vpnN != nil {
		t := *r.exportingL2vpnN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn__n", t, "multi")
		}
	}
	if r.exportingL2vpnId != nil {
		t := *r.exportingL2vpnId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn_id", t, "multi")
		}
	}
	if r.exportingL2vpnIdN != nil {
		t := *r.exportingL2vpnIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_l2vpn_id__n", t, "multi")
		}
	}
	if r.exportingVrf != nil {
		t := *r.exportingVrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf", t, "multi")
		}
	}
	if r.exportingVrfN != nil {
		t := *r.exportingVrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf__n", t, "multi")
		}
	}
	if r.exportingVrfId != nil {
		t := *r.exportingVrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf_id", t, "multi")
		}
	}
	if r.exportingVrfIdN != nil {
		t := *r.exportingVrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exporting_vrf_id__n", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.importingL2vpn != nil {
		t := *r.importingL2vpn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn", t, "multi")
		}
	}
	if r.importingL2vpnN != nil {
		t := *r.importingL2vpnN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn__n", t, "multi")
		}
	}
	if r.importingL2vpnId != nil {
		t := *r.importingL2vpnId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn_id", t, "multi")
		}
	}
	if r.importingL2vpnIdN != nil {
		t := *r.importingL2vpnIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_l2vpn_id__n", t, "multi")
		}
	}
	if r.importingVrf != nil {
		t := *r.importingVrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf", t, "multi")
		}
	}
	if r.importingVrfN != nil {
		t := *r.importingVrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf__n", t, "multi")
		}
	}
	if r.importingVrfId != nil {
		t := *r.importingVrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf_id", t, "multi")
		}
	}
	if r.importingVrfIdN != nil {
		t := *r.importingVrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "importing_vrf_id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsPartialUpdateRequest struct {
	ctx                       context.Context
	ApiService                *IpamAPIService
	id                        int32
	patchedRouteTargetRequest *PatchedRouteTargetRequest
}

func (r ApiIpamRouteTargetsPartialUpdateRequest) PatchedRouteTargetRequest(patchedRouteTargetRequest PatchedRouteTargetRequest) ApiIpamRouteTargetsPartialUpdateRequest {
	r.patchedRouteTargetRequest = &patchedRouteTargetRequest
	return r
}

func (r ApiIpamRouteTargetsPartialUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsPartialUpdateExecute(r)
}

/*
IpamRouteTargetsPartialUpdate Method for IpamRouteTargetsPartialUpdate

Patch a route target object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this route target.
	@return ApiIpamRouteTargetsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsPartialUpdate(ctx context.Context, id int32) ApiIpamRouteTargetsPartialUpdateRequest {
	return ApiIpamRouteTargetsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsPartialUpdateExecute(r ApiIpamRouteTargetsPartialUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRouteTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamRouteTargetsRetrieveRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsRetrieveExecute(r)
}

/*
IpamRouteTargetsRetrieve Method for IpamRouteTargetsRetrieve

Get a route target object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this route target.
	@return ApiIpamRouteTargetsRetrieveRequest
*/
func (a *IpamAPIService) IpamRouteTargetsRetrieve(ctx context.Context, id int32) ApiIpamRouteTargetsRetrieveRequest {
	return ApiIpamRouteTargetsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsRetrieveExecute(r ApiIpamRouteTargetsRetrieveRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsUpdateRequest struct {
	ctx                context.Context
	ApiService         *IpamAPIService
	id                 int32
	routeTargetRequest *RouteTargetRequest
}

func (r ApiIpamRouteTargetsUpdateRequest) RouteTargetRequest(routeTargetRequest RouteTargetRequest) ApiIpamRouteTargetsUpdateRequest {
	r.routeTargetRequest = &routeTargetRequest
	return r
}

func (r ApiIpamRouteTargetsUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsUpdateExecute(r)
}

/*
IpamRouteTargetsUpdate Method for IpamRouteTargetsUpdate

Put a route target object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this route target.
	@return ApiIpamRouteTargetsUpdateRequest
*/
func (a *IpamAPIService) IpamRouteTargetsUpdate(ctx context.Context, id int32) ApiIpamRouteTargetsUpdateRequest {
	return ApiIpamRouteTargetsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return RouteTarget
func (a *IpamAPIService) IpamRouteTargetsUpdateExecute(r ApiIpamRouteTargetsUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamRouteTargetsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.routeTargetRequest == nil {
		return localVarReturnValue, nil, reportError("routeTargetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.routeTargetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesBulkDestroyRequest struct {
	ctx                    context.Context
	ApiService             *IpamAPIService
	serviceTemplateRequest *[]ServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesBulkDestroyRequest) ServiceTemplateRequest(serviceTemplateRequest []ServiceTemplateRequest) ApiIpamServiceTemplatesBulkDestroyRequest {
	r.serviceTemplateRequest = &serviceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServiceTemplatesBulkDestroyExecute(r)
}

/*
IpamServiceTemplatesBulkDestroy Method for IpamServiceTemplatesBulkDestroy

Delete a list of service template objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServiceTemplatesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesBulkDestroy(ctx context.Context) ApiIpamServiceTemplatesBulkDestroyRequest {
	return ApiIpamServiceTemplatesBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamServiceTemplatesBulkDestroyExecute(r ApiIpamServiceTemplatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceTemplateRequest == nil {
		return nil, reportError("serviceTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesBulkPartialUpdateRequest struct {
	ctx                    context.Context
	ApiService             *IpamAPIService
	serviceTemplateRequest *[]ServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesBulkPartialUpdateRequest) ServiceTemplateRequest(serviceTemplateRequest []ServiceTemplateRequest) ApiIpamServiceTemplatesBulkPartialUpdateRequest {
	r.serviceTemplateRequest = &serviceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesBulkPartialUpdateRequest) Execute() ([]ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesBulkPartialUpdateExecute(r)
}

/*
IpamServiceTemplatesBulkPartialUpdate Method for IpamServiceTemplatesBulkPartialUpdate

Patch a list of service template objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServiceTemplatesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesBulkPartialUpdate(ctx context.Context) ApiIpamServiceTemplatesBulkPartialUpdateRequest {
	return ApiIpamServiceTemplatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesBulkPartialUpdateExecute(r ApiIpamServiceTemplatesBulkPartialUpdateRequest) ([]ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("serviceTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesBulkUpdateRequest struct {
	ctx                    context.Context
	ApiService             *IpamAPIService
	serviceTemplateRequest *[]ServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesBulkUpdateRequest) ServiceTemplateRequest(serviceTemplateRequest []ServiceTemplateRequest) ApiIpamServiceTemplatesBulkUpdateRequest {
	r.serviceTemplateRequest = &serviceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesBulkUpdateRequest) Execute() ([]ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesBulkUpdateExecute(r)
}

/*
IpamServiceTemplatesBulkUpdate Method for IpamServiceTemplatesBulkUpdate

Put a list of service template objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServiceTemplatesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesBulkUpdate(ctx context.Context) ApiIpamServiceTemplatesBulkUpdateRequest {
	return ApiIpamServiceTemplatesBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesBulkUpdateExecute(r ApiIpamServiceTemplatesBulkUpdateRequest) ([]ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("serviceTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesCreateRequest struct {
	ctx                            context.Context
	ApiService                     *IpamAPIService
	writableServiceTemplateRequest *WritableServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesCreateRequest) WritableServiceTemplateRequest(writableServiceTemplateRequest WritableServiceTemplateRequest) ApiIpamServiceTemplatesCreateRequest {
	r.writableServiceTemplateRequest = &writableServiceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesCreateRequest) Execute() (*ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesCreateExecute(r)
}

/*
IpamServiceTemplatesCreate Method for IpamServiceTemplatesCreate

Post a list of service template objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServiceTemplatesCreateRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesCreate(ctx context.Context) ApiIpamServiceTemplatesCreateRequest {
	return ApiIpamServiceTemplatesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesCreateExecute(r ApiIpamServiceTemplatesCreateRequest) (*ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableServiceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableServiceTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableServiceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamServiceTemplatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServiceTemplatesDestroyExecute(r)
}

/*
IpamServiceTemplatesDestroy Method for IpamServiceTemplatesDestroy

Delete a service template object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service template.
	@return ApiIpamServiceTemplatesDestroyRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesDestroy(ctx context.Context, id int32) ApiIpamServiceTemplatesDestroyRequest {
	return ApiIpamServiceTemplatesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamServiceTemplatesDestroyExecute(r ApiIpamServiceTemplatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	modifiedByRequest *string
	name              *[]string
	nameEmpty         *bool
	nameIc            *[]string
	nameIe            *[]string
	nameIew           *[]string
	nameIsw           *[]string
	nameN             *[]string
	nameNic           *[]string
	nameNie           *[]string
	nameNiew          *[]string
	nameNisw          *[]string
	offset            *int32
	ordering          *string
	port              *float32
	protocol          *IpamServiceTemplatesListProtocolParameter
	protocolN         *IpamServiceTemplatesListProtocolParameter
	q                 *string
	tag               *[]string
	tagN              *[]string
	updatedByRequest  *string
}

func (r ApiIpamServiceTemplatesListRequest) Created(created []time.Time) ApiIpamServiceTemplatesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedGt(createdGt []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedGte(createdGte []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedLt(createdLt []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedLte(createdLte []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedN(createdN []time.Time) ApiIpamServiceTemplatesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamServiceTemplatesListRequest) CreatedByRequest(createdByRequest string) ApiIpamServiceTemplatesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Description(description []string) ApiIpamServiceTemplatesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamServiceTemplatesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionIc(descriptionIc []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionIe(descriptionIe []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionIew(descriptionIew []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionN(descriptionN []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionNic(descriptionNic []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionNie(descriptionNie []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamServiceTemplatesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamServiceTemplatesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Id(id []int32) ApiIpamServiceTemplatesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdEmpty(idEmpty bool) ApiIpamServiceTemplatesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdGt(idGt []int32) ApiIpamServiceTemplatesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdGte(idGte []int32) ApiIpamServiceTemplatesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdLt(idLt []int32) ApiIpamServiceTemplatesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdLte(idLte []int32) ApiIpamServiceTemplatesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) IdN(idN []int32) ApiIpamServiceTemplatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamServiceTemplatesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamServiceTemplatesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamServiceTemplatesListRequest) Limit(limit int32) ApiIpamServiceTemplatesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamServiceTemplatesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamServiceTemplatesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Name(name []string) ApiIpamServiceTemplatesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameEmpty(nameEmpty bool) ApiIpamServiceTemplatesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameIc(nameIc []string) ApiIpamServiceTemplatesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameIe(nameIe []string) ApiIpamServiceTemplatesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameIew(nameIew []string) ApiIpamServiceTemplatesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameIsw(nameIsw []string) ApiIpamServiceTemplatesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameN(nameN []string) ApiIpamServiceTemplatesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameNic(nameNic []string) ApiIpamServiceTemplatesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameNie(nameNie []string) ApiIpamServiceTemplatesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameNiew(nameNiew []string) ApiIpamServiceTemplatesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamServiceTemplatesListRequest) NameNisw(nameNisw []string) ApiIpamServiceTemplatesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamServiceTemplatesListRequest) Offset(offset int32) ApiIpamServiceTemplatesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamServiceTemplatesListRequest) Ordering(ordering string) ApiIpamServiceTemplatesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Port(port float32) ApiIpamServiceTemplatesListRequest {
	r.port = &port
	return r
}

// * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP
func (r ApiIpamServiceTemplatesListRequest) Protocol(protocol IpamServiceTemplatesListProtocolParameter) ApiIpamServiceTemplatesListRequest {
	r.protocol = &protocol
	return r
}

// * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP
func (r ApiIpamServiceTemplatesListRequest) ProtocolN(protocolN IpamServiceTemplatesListProtocolParameter) ApiIpamServiceTemplatesListRequest {
	r.protocolN = &protocolN
	return r
}

// Search
func (r ApiIpamServiceTemplatesListRequest) Q(q string) ApiIpamServiceTemplatesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Tag(tag []string) ApiIpamServiceTemplatesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamServiceTemplatesListRequest) TagN(tagN []string) ApiIpamServiceTemplatesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamServiceTemplatesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamServiceTemplatesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamServiceTemplatesListRequest) Execute() (*PaginatedServiceTemplateList, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesListExecute(r)
}

/*
IpamServiceTemplatesList Method for IpamServiceTemplatesList

Get a list of service template objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServiceTemplatesListRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesList(ctx context.Context) ApiIpamServiceTemplatesListRequest {
	return ApiIpamServiceTemplatesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedServiceTemplateList
func (a *IpamAPIService) IpamServiceTemplatesListExecute(r ApiIpamServiceTemplatesListRequest) (*PaginatedServiceTemplateList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedServiceTemplateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.port != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", r.port, "")
	}
	if r.protocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", r.protocol, "")
	}
	if r.protocolN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__n", r.protocolN, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesPartialUpdateRequest struct {
	ctx                                   context.Context
	ApiService                            *IpamAPIService
	id                                    int32
	patchedWritableServiceTemplateRequest *PatchedWritableServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesPartialUpdateRequest) PatchedWritableServiceTemplateRequest(patchedWritableServiceTemplateRequest PatchedWritableServiceTemplateRequest) ApiIpamServiceTemplatesPartialUpdateRequest {
	r.patchedWritableServiceTemplateRequest = &patchedWritableServiceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesPartialUpdateRequest) Execute() (*ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesPartialUpdateExecute(r)
}

/*
IpamServiceTemplatesPartialUpdate Method for IpamServiceTemplatesPartialUpdate

Patch a service template object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service template.
	@return ApiIpamServiceTemplatesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesPartialUpdate(ctx context.Context, id int32) ApiIpamServiceTemplatesPartialUpdateRequest {
	return ApiIpamServiceTemplatesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesPartialUpdateExecute(r ApiIpamServiceTemplatesPartialUpdateRequest) (*ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableServiceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamServiceTemplatesRetrieveRequest) Execute() (*ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesRetrieveExecute(r)
}

/*
IpamServiceTemplatesRetrieve Method for IpamServiceTemplatesRetrieve

Get a service template object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service template.
	@return ApiIpamServiceTemplatesRetrieveRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesRetrieve(ctx context.Context, id int32) ApiIpamServiceTemplatesRetrieveRequest {
	return ApiIpamServiceTemplatesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesRetrieveExecute(r ApiIpamServiceTemplatesRetrieveRequest) (*ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServiceTemplatesUpdateRequest struct {
	ctx                            context.Context
	ApiService                     *IpamAPIService
	id                             int32
	writableServiceTemplateRequest *WritableServiceTemplateRequest
}

func (r ApiIpamServiceTemplatesUpdateRequest) WritableServiceTemplateRequest(writableServiceTemplateRequest WritableServiceTemplateRequest) ApiIpamServiceTemplatesUpdateRequest {
	r.writableServiceTemplateRequest = &writableServiceTemplateRequest
	return r
}

func (r ApiIpamServiceTemplatesUpdateRequest) Execute() (*ServiceTemplate, *http.Response, error) {
	return r.ApiService.IpamServiceTemplatesUpdateExecute(r)
}

/*
IpamServiceTemplatesUpdate Method for IpamServiceTemplatesUpdate

Put a service template object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service template.
	@return ApiIpamServiceTemplatesUpdateRequest
*/
func (a *IpamAPIService) IpamServiceTemplatesUpdate(ctx context.Context, id int32) ApiIpamServiceTemplatesUpdateRequest {
	return ApiIpamServiceTemplatesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ServiceTemplate
func (a *IpamAPIService) IpamServiceTemplatesUpdateExecute(r ApiIpamServiceTemplatesUpdateRequest) (*ServiceTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ServiceTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServiceTemplatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/service-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableServiceTemplateRequest == nil {
		return localVarReturnValue, nil, reportError("writableServiceTemplateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableServiceTemplateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesBulkDestroyRequest struct {
	ctx            context.Context
	ApiService     *IpamAPIService
	serviceRequest *[]ServiceRequest
}

func (r ApiIpamServicesBulkDestroyRequest) ServiceRequest(serviceRequest []ServiceRequest) ApiIpamServicesBulkDestroyRequest {
	r.serviceRequest = &serviceRequest
	return r
}

func (r ApiIpamServicesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServicesBulkDestroyExecute(r)
}

/*
IpamServicesBulkDestroy Method for IpamServicesBulkDestroy

Delete a list of service objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServicesBulkDestroyRequest
*/
func (a *IpamAPIService) IpamServicesBulkDestroy(ctx context.Context) ApiIpamServicesBulkDestroyRequest {
	return ApiIpamServicesBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamServicesBulkDestroyExecute(r ApiIpamServicesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceRequest == nil {
		return nil, reportError("serviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServicesBulkPartialUpdateRequest struct {
	ctx            context.Context
	ApiService     *IpamAPIService
	serviceRequest *[]ServiceRequest
}

func (r ApiIpamServicesBulkPartialUpdateRequest) ServiceRequest(serviceRequest []ServiceRequest) ApiIpamServicesBulkPartialUpdateRequest {
	r.serviceRequest = &serviceRequest
	return r
}

func (r ApiIpamServicesBulkPartialUpdateRequest) Execute() ([]Service, *http.Response, error) {
	return r.ApiService.IpamServicesBulkPartialUpdateExecute(r)
}

/*
IpamServicesBulkPartialUpdate Method for IpamServicesBulkPartialUpdate

Patch a list of service objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServicesBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamServicesBulkPartialUpdate(ctx context.Context) ApiIpamServicesBulkPartialUpdateRequest {
	return ApiIpamServicesBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Service
func (a *IpamAPIService) IpamServicesBulkPartialUpdateExecute(r ApiIpamServicesBulkPartialUpdateRequest) ([]Service, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceRequest == nil {
		return localVarReturnValue, nil, reportError("serviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesBulkUpdateRequest struct {
	ctx            context.Context
	ApiService     *IpamAPIService
	serviceRequest *[]ServiceRequest
}

func (r ApiIpamServicesBulkUpdateRequest) ServiceRequest(serviceRequest []ServiceRequest) ApiIpamServicesBulkUpdateRequest {
	r.serviceRequest = &serviceRequest
	return r
}

func (r ApiIpamServicesBulkUpdateRequest) Execute() ([]Service, *http.Response, error) {
	return r.ApiService.IpamServicesBulkUpdateExecute(r)
}

/*
IpamServicesBulkUpdate Method for IpamServicesBulkUpdate

Put a list of service objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServicesBulkUpdateRequest
*/
func (a *IpamAPIService) IpamServicesBulkUpdate(ctx context.Context) ApiIpamServicesBulkUpdateRequest {
	return ApiIpamServicesBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Service
func (a *IpamAPIService) IpamServicesBulkUpdateExecute(r ApiIpamServicesBulkUpdateRequest) ([]Service, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceRequest == nil {
		return localVarReturnValue, nil, reportError("serviceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesCreateRequest struct {
	ctx                    context.Context
	ApiService             *IpamAPIService
	writableServiceRequest *WritableServiceRequest
}

func (r ApiIpamServicesCreateRequest) WritableServiceRequest(writableServiceRequest WritableServiceRequest) ApiIpamServicesCreateRequest {
	r.writableServiceRequest = &writableServiceRequest
	return r
}

func (r ApiIpamServicesCreateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesCreateExecute(r)
}

/*
IpamServicesCreate Method for IpamServicesCreate

Post a list of service objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServicesCreateRequest
*/
func (a *IpamAPIService) IpamServicesCreate(ctx context.Context) ApiIpamServicesCreateRequest {
	return ApiIpamServicesCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Service
func (a *IpamAPIService) IpamServicesCreateExecute(r ApiIpamServicesCreateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableServiceRequest == nil {
		return localVarReturnValue, nil, reportError("writableServiceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableServiceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamServicesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServicesDestroyExecute(r)
}

/*
IpamServicesDestroy Method for IpamServicesDestroy

Delete a service object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service.
	@return ApiIpamServicesDestroyRequest
*/
func (a *IpamAPIService) IpamServicesDestroy(ctx context.Context, id int32) ApiIpamServicesDestroyRequest {
	return ApiIpamServicesDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamServicesDestroyExecute(r ApiIpamServicesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServicesListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	device            *[]*string
	deviceN           *[]*string
	deviceId          *[]*int32
	deviceIdN         *[]*int32
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	ipAddress         *[]string
	ipAddressN        *[]string
	ipAddressId       *[]int32
	ipAddressIdN      *[]int32
	ipaddress         *[]string
	ipaddressN        *[]string
	ipaddressId       *[]int32
	ipaddressIdN      *[]int32
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	modifiedByRequest *string
	name              *[]string
	nameEmpty         *bool
	nameIc            *[]string
	nameIe            *[]string
	nameIew           *[]string
	nameIsw           *[]string
	nameN             *[]string
	nameNic           *[]string
	nameNie           *[]string
	nameNiew          *[]string
	nameNisw          *[]string
	offset            *int32
	ordering          *string
	port              *float32
	protocol          *IpamServiceTemplatesListProtocolParameter
	protocolN         *IpamServiceTemplatesListProtocolParameter
	q                 *string
	tag               *[]string
	tagN              *[]string
	updatedByRequest  *string
	virtualMachine    *[]string
	virtualMachineN   *[]string
	virtualMachineId  *[]*int32
	virtualMachineIdN *[]*int32
}

func (r ApiIpamServicesListRequest) Created(created []time.Time) ApiIpamServicesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamServicesListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamServicesListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamServicesListRequest) CreatedGt(createdGt []time.Time) ApiIpamServicesListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamServicesListRequest) CreatedGte(createdGte []time.Time) ApiIpamServicesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamServicesListRequest) CreatedLt(createdLt []time.Time) ApiIpamServicesListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamServicesListRequest) CreatedLte(createdLte []time.Time) ApiIpamServicesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamServicesListRequest) CreatedN(createdN []time.Time) ApiIpamServicesListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamServicesListRequest) CreatedByRequest(createdByRequest string) ApiIpamServicesListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamServicesListRequest) Description(description []string) ApiIpamServicesListRequest {
	r.description = &description
	return r
}

func (r ApiIpamServicesListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamServicesListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamServicesListRequest) DescriptionIc(descriptionIc []string) ApiIpamServicesListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamServicesListRequest) DescriptionIe(descriptionIe []string) ApiIpamServicesListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamServicesListRequest) DescriptionIew(descriptionIew []string) ApiIpamServicesListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamServicesListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamServicesListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamServicesListRequest) DescriptionN(descriptionN []string) ApiIpamServicesListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamServicesListRequest) DescriptionNic(descriptionNic []string) ApiIpamServicesListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamServicesListRequest) DescriptionNie(descriptionNie []string) ApiIpamServicesListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamServicesListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamServicesListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamServicesListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamServicesListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Device (name)
func (r ApiIpamServicesListRequest) Device(device []*string) ApiIpamServicesListRequest {
	r.device = &device
	return r
}

// Device (name)
func (r ApiIpamServicesListRequest) DeviceN(deviceN []*string) ApiIpamServicesListRequest {
	r.deviceN = &deviceN
	return r
}

// Device (ID)
func (r ApiIpamServicesListRequest) DeviceId(deviceId []*int32) ApiIpamServicesListRequest {
	r.deviceId = &deviceId
	return r
}

// Device (ID)
func (r ApiIpamServicesListRequest) DeviceIdN(deviceIdN []*int32) ApiIpamServicesListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiIpamServicesListRequest) Id(id []int32) ApiIpamServicesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamServicesListRequest) IdEmpty(idEmpty bool) ApiIpamServicesListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamServicesListRequest) IdGt(idGt []int32) ApiIpamServicesListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamServicesListRequest) IdGte(idGte []int32) ApiIpamServicesListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamServicesListRequest) IdLt(idLt []int32) ApiIpamServicesListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamServicesListRequest) IdLte(idLte []int32) ApiIpamServicesListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamServicesListRequest) IdN(idN []int32) ApiIpamServicesListRequest {
	r.idN = &idN
	return r
}

// IP address
func (r ApiIpamServicesListRequest) IpAddress(ipAddress []string) ApiIpamServicesListRequest {
	r.ipAddress = &ipAddress
	return r
}

// IP address
func (r ApiIpamServicesListRequest) IpAddressN(ipAddressN []string) ApiIpamServicesListRequest {
	r.ipAddressN = &ipAddressN
	return r
}

// IP address (ID)
func (r ApiIpamServicesListRequest) IpAddressId(ipAddressId []int32) ApiIpamServicesListRequest {
	r.ipAddressId = &ipAddressId
	return r
}

// IP address (ID)
func (r ApiIpamServicesListRequest) IpAddressIdN(ipAddressIdN []int32) ApiIpamServicesListRequest {
	r.ipAddressIdN = &ipAddressIdN
	return r
}

// IP address
func (r ApiIpamServicesListRequest) Ipaddress(ipaddress []string) ApiIpamServicesListRequest {
	r.ipaddress = &ipaddress
	return r
}

// IP address
func (r ApiIpamServicesListRequest) IpaddressN(ipaddressN []string) ApiIpamServicesListRequest {
	r.ipaddressN = &ipaddressN
	return r
}

// IP address (ID)
func (r ApiIpamServicesListRequest) IpaddressId(ipaddressId []int32) ApiIpamServicesListRequest {
	r.ipaddressId = &ipaddressId
	return r
}

// IP address (ID)
func (r ApiIpamServicesListRequest) IpaddressIdN(ipaddressIdN []int32) ApiIpamServicesListRequest {
	r.ipaddressIdN = &ipaddressIdN
	return r
}

func (r ApiIpamServicesListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamServicesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamServicesListRequest) Limit(limit int32) ApiIpamServicesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamServicesListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamServicesListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamServicesListRequest) Name(name []string) ApiIpamServicesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamServicesListRequest) NameEmpty(nameEmpty bool) ApiIpamServicesListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamServicesListRequest) NameIc(nameIc []string) ApiIpamServicesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamServicesListRequest) NameIe(nameIe []string) ApiIpamServicesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamServicesListRequest) NameIew(nameIew []string) ApiIpamServicesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamServicesListRequest) NameIsw(nameIsw []string) ApiIpamServicesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamServicesListRequest) NameN(nameN []string) ApiIpamServicesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamServicesListRequest) NameNic(nameNic []string) ApiIpamServicesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamServicesListRequest) NameNie(nameNie []string) ApiIpamServicesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamServicesListRequest) NameNiew(nameNiew []string) ApiIpamServicesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamServicesListRequest) NameNisw(nameNisw []string) ApiIpamServicesListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamServicesListRequest) Offset(offset int32) ApiIpamServicesListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamServicesListRequest) Ordering(ordering string) ApiIpamServicesListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiIpamServicesListRequest) Port(port float32) ApiIpamServicesListRequest {
	r.port = &port
	return r
}

// * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP
func (r ApiIpamServicesListRequest) Protocol(protocol IpamServiceTemplatesListProtocolParameter) ApiIpamServicesListRequest {
	r.protocol = &protocol
	return r
}

// * &#x60;tcp&#x60; - TCP * &#x60;udp&#x60; - UDP * &#x60;sctp&#x60; - SCTP
func (r ApiIpamServicesListRequest) ProtocolN(protocolN IpamServiceTemplatesListProtocolParameter) ApiIpamServicesListRequest {
	r.protocolN = &protocolN
	return r
}

// Search
func (r ApiIpamServicesListRequest) Q(q string) ApiIpamServicesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamServicesListRequest) Tag(tag []string) ApiIpamServicesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamServicesListRequest) TagN(tagN []string) ApiIpamServicesListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamServicesListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamServicesListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

// Virtual machine (name)
func (r ApiIpamServicesListRequest) VirtualMachine(virtualMachine []string) ApiIpamServicesListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

// Virtual machine (name)
func (r ApiIpamServicesListRequest) VirtualMachineN(virtualMachineN []string) ApiIpamServicesListRequest {
	r.virtualMachineN = &virtualMachineN
	return r
}

// Virtual machine (ID)
func (r ApiIpamServicesListRequest) VirtualMachineId(virtualMachineId []*int32) ApiIpamServicesListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

// Virtual machine (ID)
func (r ApiIpamServicesListRequest) VirtualMachineIdN(virtualMachineIdN []*int32) ApiIpamServicesListRequest {
	r.virtualMachineIdN = &virtualMachineIdN
	return r
}

func (r ApiIpamServicesListRequest) Execute() (*PaginatedServiceList, *http.Response, error) {
	return r.ApiService.IpamServicesListExecute(r)
}

/*
IpamServicesList Method for IpamServicesList

Get a list of service objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamServicesListRequest
*/
func (a *IpamAPIService) IpamServicesList(ctx context.Context) ApiIpamServicesListRequest {
	return ApiIpamServicesListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedServiceList
func (a *IpamAPIService) IpamServicesListExecute(r ApiIpamServicesListRequest) (*PaginatedServiceList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedServiceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device", t, "multi")
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device__n", t, "multi")
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", t, "multi")
		}
	}
	if r.deviceIdN != nil {
		t := *r.deviceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "device_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "device_id__n", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.ipAddress != nil {
		t := *r.ipAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address", t, "multi")
		}
	}
	if r.ipAddressN != nil {
		t := *r.ipAddressN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address__n", t, "multi")
		}
	}
	if r.ipAddressId != nil {
		t := *r.ipAddressId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address_id", t, "multi")
		}
	}
	if r.ipAddressIdN != nil {
		t := *r.ipAddressIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address_id__n", t, "multi")
		}
	}
	if r.ipaddress != nil {
		t := *r.ipaddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipaddress", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipaddress", t, "multi")
		}
	}
	if r.ipaddressN != nil {
		t := *r.ipaddressN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipaddress__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipaddress__n", t, "multi")
		}
	}
	if r.ipaddressId != nil {
		t := *r.ipaddressId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipaddress_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipaddress_id", t, "multi")
		}
	}
	if r.ipaddressIdN != nil {
		t := *r.ipaddressIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ipaddress_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ipaddress_id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.port != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", r.port, "")
	}
	if r.protocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", r.protocol, "")
	}
	if r.protocolN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol__n", r.protocolN, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine", t, "multi")
		}
	}
	if r.virtualMachineN != nil {
		t := *r.virtualMachineN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine__n", t, "multi")
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id", t, "multi")
		}
	}
	if r.virtualMachineIdN != nil {
		t := *r.virtualMachineIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "virtual_machine_id__n", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesPartialUpdateRequest struct {
	ctx                           context.Context
	ApiService                    *IpamAPIService
	id                            int32
	patchedWritableServiceRequest *PatchedWritableServiceRequest
}

func (r ApiIpamServicesPartialUpdateRequest) PatchedWritableServiceRequest(patchedWritableServiceRequest PatchedWritableServiceRequest) ApiIpamServicesPartialUpdateRequest {
	r.patchedWritableServiceRequest = &patchedWritableServiceRequest
	return r
}

func (r ApiIpamServicesPartialUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesPartialUpdateExecute(r)
}

/*
IpamServicesPartialUpdate Method for IpamServicesPartialUpdate

Patch a service object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service.
	@return ApiIpamServicesPartialUpdateRequest
*/
func (a *IpamAPIService) IpamServicesPartialUpdate(ctx context.Context, id int32) ApiIpamServicesPartialUpdateRequest {
	return ApiIpamServicesPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Service
func (a *IpamAPIService) IpamServicesPartialUpdateExecute(r ApiIpamServicesPartialUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableServiceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamServicesRetrieveRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesRetrieveExecute(r)
}

/*
IpamServicesRetrieve Method for IpamServicesRetrieve

Get a service object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service.
	@return ApiIpamServicesRetrieveRequest
*/
func (a *IpamAPIService) IpamServicesRetrieve(ctx context.Context, id int32) ApiIpamServicesRetrieveRequest {
	return ApiIpamServicesRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Service
func (a *IpamAPIService) IpamServicesRetrieveExecute(r ApiIpamServicesRetrieveRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesUpdateRequest struct {
	ctx                    context.Context
	ApiService             *IpamAPIService
	id                     int32
	writableServiceRequest *WritableServiceRequest
}

func (r ApiIpamServicesUpdateRequest) WritableServiceRequest(writableServiceRequest WritableServiceRequest) ApiIpamServicesUpdateRequest {
	r.writableServiceRequest = &writableServiceRequest
	return r
}

func (r ApiIpamServicesUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesUpdateExecute(r)
}

/*
IpamServicesUpdate Method for IpamServicesUpdate

Put a service object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this service.
	@return ApiIpamServicesUpdateRequest
*/
func (a *IpamAPIService) IpamServicesUpdate(ctx context.Context, id int32) ApiIpamServicesUpdateRequest {
	return ApiIpamServicesUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Service
func (a *IpamAPIService) IpamServicesUpdateExecute(r ApiIpamServicesUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamServicesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableServiceRequest == nil {
		return localVarReturnValue, nil, reportError("writableServiceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableServiceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsAvailableVlansCreateRequest struct {
	ctx         context.Context
	ApiService  *IpamAPIService
	id          int32
	vLANRequest *[]VLANRequest
}

func (r ApiIpamVlanGroupsAvailableVlansCreateRequest) VLANRequest(vLANRequest []VLANRequest) ApiIpamVlanGroupsAvailableVlansCreateRequest {
	r.vLANRequest = &vLANRequest
	return r
}

func (r ApiIpamVlanGroupsAvailableVlansCreateRequest) Execute() ([]VLAN, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsAvailableVlansCreateExecute(r)
}

/*
IpamVlanGroupsAvailableVlansCreate Method for IpamVlanGroupsAvailableVlansCreate

Post a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamVlanGroupsAvailableVlansCreateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsAvailableVlansCreate(ctx context.Context, id int32) ApiIpamVlanGroupsAvailableVlansCreateRequest {
	return ApiIpamVlanGroupsAvailableVlansCreateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []VLAN
func (a *IpamAPIService) IpamVlanGroupsAvailableVlansCreateExecute(r ApiIpamVlanGroupsAvailableVlansCreateRequest) ([]VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsAvailableVlansCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/available-vlans/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANRequest == nil {
		return localVarReturnValue, nil, reportError("vLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsAvailableVlansListRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamVlanGroupsAvailableVlansListRequest) Execute() ([]AvailableVLAN, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsAvailableVlansListExecute(r)
}

/*
IpamVlanGroupsAvailableVlansList Method for IpamVlanGroupsAvailableVlansList

Get a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiIpamVlanGroupsAvailableVlansListRequest
*/
func (a *IpamAPIService) IpamVlanGroupsAvailableVlansList(ctx context.Context, id int32) ApiIpamVlanGroupsAvailableVlansListRequest {
	return ApiIpamVlanGroupsAvailableVlansListRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []AvailableVLAN
func (a *IpamAPIService) IpamVlanGroupsAvailableVlansListExecute(r ApiIpamVlanGroupsAvailableVlansListRequest) ([]AvailableVLAN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AvailableVLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsAvailableVlansList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/available-vlans/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkDestroyRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	vLANGroupRequest *[]VLANGroupRequest
}

func (r ApiIpamVlanGroupsBulkDestroyRequest) VLANGroupRequest(vLANGroupRequest []VLANGroupRequest) ApiIpamVlanGroupsBulkDestroyRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkDestroyExecute(r)
}

/*
IpamVlanGroupsBulkDestroy Method for IpamVlanGroupsBulkDestroy

Delete a list of VLAN group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanGroupsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVlanGroupsBulkDestroy(ctx context.Context) ApiIpamVlanGroupsBulkDestroyRequest {
	return ApiIpamVlanGroupsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanGroupsBulkDestroyExecute(r ApiIpamVlanGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return nil, reportError("vLANGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkPartialUpdateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	vLANGroupRequest *[]VLANGroupRequest
}

func (r ApiIpamVlanGroupsBulkPartialUpdateRequest) VLANGroupRequest(vLANGroupRequest []VLANGroupRequest) ApiIpamVlanGroupsBulkPartialUpdateRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsBulkPartialUpdateRequest) Execute() ([]VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkPartialUpdateExecute(r)
}

/*
IpamVlanGroupsBulkPartialUpdate Method for IpamVlanGroupsBulkPartialUpdate

Patch a list of VLAN group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanGroupsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsBulkPartialUpdate(ctx context.Context) ApiIpamVlanGroupsBulkPartialUpdateRequest {
	return ApiIpamVlanGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []VLANGroup
func (a *IpamAPIService) IpamVlanGroupsBulkPartialUpdateExecute(r ApiIpamVlanGroupsBulkPartialUpdateRequest) ([]VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("vLANGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkUpdateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	vLANGroupRequest *[]VLANGroupRequest
}

func (r ApiIpamVlanGroupsBulkUpdateRequest) VLANGroupRequest(vLANGroupRequest []VLANGroupRequest) ApiIpamVlanGroupsBulkUpdateRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsBulkUpdateRequest) Execute() ([]VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkUpdateExecute(r)
}

/*
IpamVlanGroupsBulkUpdate Method for IpamVlanGroupsBulkUpdate

Put a list of VLAN group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanGroupsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsBulkUpdate(ctx context.Context) ApiIpamVlanGroupsBulkUpdateRequest {
	return ApiIpamVlanGroupsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []VLANGroup
func (a *IpamAPIService) IpamVlanGroupsBulkUpdateExecute(r ApiIpamVlanGroupsBulkUpdateRequest) ([]VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("vLANGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsCreateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	vLANGroupRequest *VLANGroupRequest
}

func (r ApiIpamVlanGroupsCreateRequest) VLANGroupRequest(vLANGroupRequest VLANGroupRequest) ApiIpamVlanGroupsCreateRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsCreateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsCreateExecute(r)
}

/*
IpamVlanGroupsCreate Method for IpamVlanGroupsCreate

Post a list of VLAN group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanGroupsCreateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsCreate(ctx context.Context) ApiIpamVlanGroupsCreateRequest {
	return ApiIpamVlanGroupsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsCreateExecute(r ApiIpamVlanGroupsCreateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("vLANGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamVlanGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanGroupsDestroyExecute(r)
}

/*
IpamVlanGroupsDestroy Method for IpamVlanGroupsDestroy

Delete a VLAN group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN group.
	@return ApiIpamVlanGroupsDestroyRequest
*/
func (a *IpamAPIService) IpamVlanGroupsDestroy(ctx context.Context, id int32) ApiIpamVlanGroupsDestroyRequest {
	return ApiIpamVlanGroupsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlanGroupsDestroyExecute(r ApiIpamVlanGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	cluster           *int32
	clusterGroup      *int32
	clustergroup      *int32
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	location          *int32
	maxVid            *[]int32
	maxVidEmpty       *bool
	maxVidGt          *[]int32
	maxVidGte         *[]int32
	maxVidLt          *[]int32
	maxVidLte         *[]int32
	maxVidN           *[]int32
	minVid            *[]int32
	minVidEmpty       *bool
	minVidGt          *[]int32
	minVidGte         *[]int32
	minVidLt          *[]int32
	minVidLte         *[]int32
	minVidN           *[]int32
	modifiedByRequest *string
	name              *[]string
	nameEmpty         *bool
	nameIc            *[]string
	nameIe            *[]string
	nameIew           *[]string
	nameIsw           *[]string
	nameN             *[]string
	nameNic           *[]string
	nameNie           *[]string
	nameNiew          *[]string
	nameNisw          *[]string
	offset            *int32
	ordering          *string
	q                 *string
	rack              *int32
	region            *int32
	scopeId           *[]int32
	scopeIdEmpty      *bool
	scopeIdGt         *[]int32
	scopeIdGte        *[]int32
	scopeIdLt         *[]int32
	scopeIdLte        *[]int32
	scopeIdN          *[]int32
	scopeType         *string
	scopeTypeN        *string
	site              *int32
	siteGroup         *int32
	sitegroup         *int32
	slug              *[]string
	slugEmpty         *bool
	slugIc            *[]string
	slugIe            *[]string
	slugIew           *[]string
	slugIsw           *[]string
	slugN             *[]string
	slugNic           *[]string
	slugNie           *[]string
	slugNiew          *[]string
	slugNisw          *[]string
	tag               *[]string
	tagN              *[]string
	updatedByRequest  *string
}

func (r ApiIpamVlanGroupsListRequest) Cluster(cluster int32) ApiIpamVlanGroupsListRequest {
	r.cluster = &cluster
	return r
}

func (r ApiIpamVlanGroupsListRequest) ClusterGroup(clusterGroup int32) ApiIpamVlanGroupsListRequest {
	r.clusterGroup = &clusterGroup
	return r
}

func (r ApiIpamVlanGroupsListRequest) Clustergroup(clustergroup int32) ApiIpamVlanGroupsListRequest {
	r.clustergroup = &clustergroup
	return r
}

func (r ApiIpamVlanGroupsListRequest) Created(created []time.Time) ApiIpamVlanGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedGt(createdGt []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedGte(createdGte []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedLt(createdLt []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedLte(createdLte []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedN(createdN []time.Time) ApiIpamVlanGroupsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedByRequest(createdByRequest string) ApiIpamVlanGroupsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamVlanGroupsListRequest) Description(description []string) ApiIpamVlanGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamVlanGroupsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIc(descriptionIc []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIe(descriptionIe []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIew(descriptionIew []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionN(descriptionN []string) ApiIpamVlanGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNic(descriptionNic []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNie(descriptionNie []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) Id(id []int32) ApiIpamVlanGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdEmpty(idEmpty bool) ApiIpamVlanGroupsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdGt(idGt []int32) ApiIpamVlanGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdGte(idGte []int32) ApiIpamVlanGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdLt(idLt []int32) ApiIpamVlanGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdLte(idLte []int32) ApiIpamVlanGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdN(idN []int32) ApiIpamVlanGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamVlanGroupsListRequest) Limit(limit int32) ApiIpamVlanGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVlanGroupsListRequest) Location(location int32) ApiIpamVlanGroupsListRequest {
	r.location = &location
	return r
}

func (r ApiIpamVlanGroupsListRequest) MaxVid(maxVid []int32) ApiIpamVlanGroupsListRequest {
	r.maxVid = &maxVid
	return r
}

func (r ApiIpamVlanGroupsListRequest) MaxVidEmpty(maxVidEmpty bool) ApiIpamVlanGroupsListRequest {
	r.maxVidEmpty = &maxVidEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) MaxVidGt(maxVidGt []int32) ApiIpamVlanGroupsListRequest {
	r.maxVidGt = &maxVidGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) MaxVidGte(maxVidGte []int32) ApiIpamVlanGroupsListRequest {
	r.maxVidGte = &maxVidGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) MaxVidLt(maxVidLt []int32) ApiIpamVlanGroupsListRequest {
	r.maxVidLt = &maxVidLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) MaxVidLte(maxVidLte []int32) ApiIpamVlanGroupsListRequest {
	r.maxVidLte = &maxVidLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) MaxVidN(maxVidN []int32) ApiIpamVlanGroupsListRequest {
	r.maxVidN = &maxVidN
	return r
}

func (r ApiIpamVlanGroupsListRequest) MinVid(minVid []int32) ApiIpamVlanGroupsListRequest {
	r.minVid = &minVid
	return r
}

func (r ApiIpamVlanGroupsListRequest) MinVidEmpty(minVidEmpty bool) ApiIpamVlanGroupsListRequest {
	r.minVidEmpty = &minVidEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) MinVidGt(minVidGt []int32) ApiIpamVlanGroupsListRequest {
	r.minVidGt = &minVidGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) MinVidGte(minVidGte []int32) ApiIpamVlanGroupsListRequest {
	r.minVidGte = &minVidGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) MinVidLt(minVidLt []int32) ApiIpamVlanGroupsListRequest {
	r.minVidLt = &minVidLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) MinVidLte(minVidLte []int32) ApiIpamVlanGroupsListRequest {
	r.minVidLte = &minVidLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) MinVidN(minVidN []int32) ApiIpamVlanGroupsListRequest {
	r.minVidN = &minVidN
	return r
}

func (r ApiIpamVlanGroupsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamVlanGroupsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamVlanGroupsListRequest) Name(name []string) ApiIpamVlanGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameEmpty(nameEmpty bool) ApiIpamVlanGroupsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIc(nameIc []string) ApiIpamVlanGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIe(nameIe []string) ApiIpamVlanGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIew(nameIew []string) ApiIpamVlanGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIsw(nameIsw []string) ApiIpamVlanGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameN(nameN []string) ApiIpamVlanGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNic(nameNic []string) ApiIpamVlanGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNie(nameNie []string) ApiIpamVlanGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNiew(nameNiew []string) ApiIpamVlanGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNisw(nameNisw []string) ApiIpamVlanGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlanGroupsListRequest) Offset(offset int32) ApiIpamVlanGroupsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVlanGroupsListRequest) Ordering(ordering string) ApiIpamVlanGroupsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamVlanGroupsListRequest) Q(q string) ApiIpamVlanGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVlanGroupsListRequest) Rack(rack int32) ApiIpamVlanGroupsListRequest {
	r.rack = &rack
	return r
}

func (r ApiIpamVlanGroupsListRequest) Region(region int32) ApiIpamVlanGroupsListRequest {
	r.region = &region
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeId(scopeId []int32) ApiIpamVlanGroupsListRequest {
	r.scopeId = &scopeId
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdEmpty(scopeIdEmpty bool) ApiIpamVlanGroupsListRequest {
	r.scopeIdEmpty = &scopeIdEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdGt(scopeIdGt []int32) ApiIpamVlanGroupsListRequest {
	r.scopeIdGt = &scopeIdGt
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdGte(scopeIdGte []int32) ApiIpamVlanGroupsListRequest {
	r.scopeIdGte = &scopeIdGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdLt(scopeIdLt []int32) ApiIpamVlanGroupsListRequest {
	r.scopeIdLt = &scopeIdLt
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdLte(scopeIdLte []int32) ApiIpamVlanGroupsListRequest {
	r.scopeIdLte = &scopeIdLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeIdN(scopeIdN []int32) ApiIpamVlanGroupsListRequest {
	r.scopeIdN = &scopeIdN
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeType(scopeType string) ApiIpamVlanGroupsListRequest {
	r.scopeType = &scopeType
	return r
}

func (r ApiIpamVlanGroupsListRequest) ScopeTypeN(scopeTypeN string) ApiIpamVlanGroupsListRequest {
	r.scopeTypeN = &scopeTypeN
	return r
}

func (r ApiIpamVlanGroupsListRequest) Site(site int32) ApiIpamVlanGroupsListRequest {
	r.site = &site
	return r
}

func (r ApiIpamVlanGroupsListRequest) SiteGroup(siteGroup int32) ApiIpamVlanGroupsListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiIpamVlanGroupsListRequest) Sitegroup(sitegroup int32) ApiIpamVlanGroupsListRequest {
	r.sitegroup = &sitegroup
	return r
}

func (r ApiIpamVlanGroupsListRequest) Slug(slug []string) ApiIpamVlanGroupsListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugEmpty(slugEmpty bool) ApiIpamVlanGroupsListRequest {
	r.slugEmpty = &slugEmpty
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIc(slugIc []string) ApiIpamVlanGroupsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIe(slugIe []string) ApiIpamVlanGroupsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIew(slugIew []string) ApiIpamVlanGroupsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIsw(slugIsw []string) ApiIpamVlanGroupsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugN(slugN []string) ApiIpamVlanGroupsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNic(slugNic []string) ApiIpamVlanGroupsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNie(slugNie []string) ApiIpamVlanGroupsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNiew(slugNiew []string) ApiIpamVlanGroupsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNisw(slugNisw []string) ApiIpamVlanGroupsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) Tag(tag []string) ApiIpamVlanGroupsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVlanGroupsListRequest) TagN(tagN []string) ApiIpamVlanGroupsListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiIpamVlanGroupsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamVlanGroupsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamVlanGroupsListRequest) Execute() (*PaginatedVLANGroupList, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsListExecute(r)
}

/*
IpamVlanGroupsList Method for IpamVlanGroupsList

Get a list of VLAN group objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlanGroupsListRequest
*/
func (a *IpamAPIService) IpamVlanGroupsList(ctx context.Context) ApiIpamVlanGroupsListRequest {
	return ApiIpamVlanGroupsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedVLANGroupList
func (a *IpamAPIService) IpamVlanGroupsListExecute(r ApiIpamVlanGroupsListRequest) (*PaginatedVLANGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedVLANGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.clusterGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_group", r.clusterGroup, "")
	}
	if r.clustergroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clustergroup", r.clustergroup, "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location", r.location, "")
	}
	if r.maxVid != nil {
		t := *r.maxVid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid", t, "multi")
		}
	}
	if r.maxVidEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid__empty", r.maxVidEmpty, "")
	}
	if r.maxVidGt != nil {
		t := *r.maxVidGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid__gt", t, "multi")
		}
	}
	if r.maxVidGte != nil {
		t := *r.maxVidGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid__gte", t, "multi")
		}
	}
	if r.maxVidLt != nil {
		t := *r.maxVidLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid__lt", t, "multi")
		}
	}
	if r.maxVidLte != nil {
		t := *r.maxVidLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid__lte", t, "multi")
		}
	}
	if r.maxVidN != nil {
		t := *r.maxVidN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "max_vid__n", t, "multi")
		}
	}
	if r.minVid != nil {
		t := *r.minVid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid", t, "multi")
		}
	}
	if r.minVidEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid__empty", r.minVidEmpty, "")
	}
	if r.minVidGt != nil {
		t := *r.minVidGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid__gt", t, "multi")
		}
	}
	if r.minVidGte != nil {
		t := *r.minVidGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid__gte", t, "multi")
		}
	}
	if r.minVidLt != nil {
		t := *r.minVidLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid__lt", t, "multi")
		}
	}
	if r.minVidLte != nil {
		t := *r.minVidLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid__lte", t, "multi")
		}
	}
	if r.minVidN != nil {
		t := *r.minVidN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "min_vid__n", t, "multi")
		}
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rack != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rack", r.rack, "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	}
	if r.scopeId != nil {
		t := *r.scopeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id", t, "multi")
		}
	}
	if r.scopeIdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__empty", r.scopeIdEmpty, "")
	}
	if r.scopeIdGt != nil {
		t := *r.scopeIdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gt", t, "multi")
		}
	}
	if r.scopeIdGte != nil {
		t := *r.scopeIdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__gte", t, "multi")
		}
	}
	if r.scopeIdLt != nil {
		t := *r.scopeIdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lt", t, "multi")
		}
	}
	if r.scopeIdLte != nil {
		t := *r.scopeIdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__lte", t, "multi")
		}
	}
	if r.scopeIdN != nil {
		t := *r.scopeIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "scope_id__n", t, "multi")
		}
	}
	if r.scopeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope_type", r.scopeType, "")
	}
	if r.scopeTypeN != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope_type__n", r.scopeTypeN, "")
	}
	if r.site != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "site", r.site, "")
	}
	if r.siteGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "site_group", r.siteGroup, "")
	}
	if r.sitegroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sitegroup", r.sitegroup, "")
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug", t, "multi")
		}
	}
	if r.slugEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slug__empty", r.slugEmpty, "")
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ic", t, "multi")
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__ie", t, "multi")
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__iew", t, "multi")
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__isw", t, "multi")
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__n", t, "multi")
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nic", t, "multi")
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nie", t, "multi")
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__niew", t, "multi")
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "slug__nisw", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsPartialUpdateRequest struct {
	ctx                     context.Context
	ApiService              *IpamAPIService
	id                      int32
	patchedVLANGroupRequest *PatchedVLANGroupRequest
}

func (r ApiIpamVlanGroupsPartialUpdateRequest) PatchedVLANGroupRequest(patchedVLANGroupRequest PatchedVLANGroupRequest) ApiIpamVlanGroupsPartialUpdateRequest {
	r.patchedVLANGroupRequest = &patchedVLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsPartialUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsPartialUpdateExecute(r)
}

/*
IpamVlanGroupsPartialUpdate Method for IpamVlanGroupsPartialUpdate

Patch a VLAN group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN group.
	@return ApiIpamVlanGroupsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsPartialUpdate(ctx context.Context, id int32) ApiIpamVlanGroupsPartialUpdateRequest {
	return ApiIpamVlanGroupsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsPartialUpdateExecute(r ApiIpamVlanGroupsPartialUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamVlanGroupsRetrieveRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsRetrieveExecute(r)
}

/*
IpamVlanGroupsRetrieve Method for IpamVlanGroupsRetrieve

Get a VLAN group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN group.
	@return ApiIpamVlanGroupsRetrieveRequest
*/
func (a *IpamAPIService) IpamVlanGroupsRetrieve(ctx context.Context, id int32) ApiIpamVlanGroupsRetrieveRequest {
	return ApiIpamVlanGroupsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsRetrieveExecute(r ApiIpamVlanGroupsRetrieveRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsUpdateRequest struct {
	ctx              context.Context
	ApiService       *IpamAPIService
	id               int32
	vLANGroupRequest *VLANGroupRequest
}

func (r ApiIpamVlanGroupsUpdateRequest) VLANGroupRequest(vLANGroupRequest VLANGroupRequest) ApiIpamVlanGroupsUpdateRequest {
	r.vLANGroupRequest = &vLANGroupRequest
	return r
}

func (r ApiIpamVlanGroupsUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsUpdateExecute(r)
}

/*
IpamVlanGroupsUpdate Method for IpamVlanGroupsUpdate

Put a VLAN group object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN group.
	@return ApiIpamVlanGroupsUpdateRequest
*/
func (a *IpamAPIService) IpamVlanGroupsUpdate(ctx context.Context, id int32) ApiIpamVlanGroupsUpdateRequest {
	return ApiIpamVlanGroupsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return VLANGroup
func (a *IpamAPIService) IpamVlanGroupsUpdateExecute(r ApiIpamVlanGroupsUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlanGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANGroupRequest == nil {
		return localVarReturnValue, nil, reportError("vLANGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansBulkDestroyRequest struct {
	ctx         context.Context
	ApiService  *IpamAPIService
	vLANRequest *[]VLANRequest
}

func (r ApiIpamVlansBulkDestroyRequest) VLANRequest(vLANRequest []VLANRequest) ApiIpamVlansBulkDestroyRequest {
	r.vLANRequest = &vLANRequest
	return r
}

func (r ApiIpamVlansBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlansBulkDestroyExecute(r)
}

/*
IpamVlansBulkDestroy Method for IpamVlansBulkDestroy

Delete a list of VLAN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlansBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVlansBulkDestroy(ctx context.Context) ApiIpamVlansBulkDestroyRequest {
	return ApiIpamVlansBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlansBulkDestroyExecute(r ApiIpamVlansBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANRequest == nil {
		return nil, reportError("vLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlansBulkPartialUpdateRequest struct {
	ctx         context.Context
	ApiService  *IpamAPIService
	vLANRequest *[]VLANRequest
}

func (r ApiIpamVlansBulkPartialUpdateRequest) VLANRequest(vLANRequest []VLANRequest) ApiIpamVlansBulkPartialUpdateRequest {
	r.vLANRequest = &vLANRequest
	return r
}

func (r ApiIpamVlansBulkPartialUpdateRequest) Execute() ([]VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansBulkPartialUpdateExecute(r)
}

/*
IpamVlansBulkPartialUpdate Method for IpamVlansBulkPartialUpdate

Patch a list of VLAN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlansBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlansBulkPartialUpdate(ctx context.Context) ApiIpamVlansBulkPartialUpdateRequest {
	return ApiIpamVlansBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []VLAN
func (a *IpamAPIService) IpamVlansBulkPartialUpdateExecute(r ApiIpamVlansBulkPartialUpdateRequest) ([]VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANRequest == nil {
		return localVarReturnValue, nil, reportError("vLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansBulkUpdateRequest struct {
	ctx         context.Context
	ApiService  *IpamAPIService
	vLANRequest *[]VLANRequest
}

func (r ApiIpamVlansBulkUpdateRequest) VLANRequest(vLANRequest []VLANRequest) ApiIpamVlansBulkUpdateRequest {
	r.vLANRequest = &vLANRequest
	return r
}

func (r ApiIpamVlansBulkUpdateRequest) Execute() ([]VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansBulkUpdateExecute(r)
}

/*
IpamVlansBulkUpdate Method for IpamVlansBulkUpdate

Put a list of VLAN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlansBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVlansBulkUpdate(ctx context.Context) ApiIpamVlansBulkUpdateRequest {
	return ApiIpamVlansBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []VLAN
func (a *IpamAPIService) IpamVlansBulkUpdateExecute(r ApiIpamVlansBulkUpdateRequest) ([]VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vLANRequest == nil {
		return localVarReturnValue, nil, reportError("vLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansCreateRequest struct {
	ctx                 context.Context
	ApiService          *IpamAPIService
	writableVLANRequest *WritableVLANRequest
}

func (r ApiIpamVlansCreateRequest) WritableVLANRequest(writableVLANRequest WritableVLANRequest) ApiIpamVlansCreateRequest {
	r.writableVLANRequest = &writableVLANRequest
	return r
}

func (r ApiIpamVlansCreateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansCreateExecute(r)
}

/*
IpamVlansCreate Method for IpamVlansCreate

Post a list of VLAN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlansCreateRequest
*/
func (a *IpamAPIService) IpamVlansCreate(ctx context.Context) ApiIpamVlansCreateRequest {
	return ApiIpamVlansCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VLAN
func (a *IpamAPIService) IpamVlansCreateExecute(r ApiIpamVlansCreateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVLANRequest == nil {
		return localVarReturnValue, nil, reportError("writableVLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamVlansDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlansDestroyExecute(r)
}

/*
IpamVlansDestroy Method for IpamVlansDestroy

Delete a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN.
	@return ApiIpamVlansDestroyRequest
*/
func (a *IpamAPIService) IpamVlansDestroy(ctx context.Context, id int32) ApiIpamVlansDestroyRequest {
	return ApiIpamVlansDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVlansDestroyExecute(r ApiIpamVlansDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlansListRequest struct {
	ctx                       context.Context
	ApiService                *IpamAPIService
	availableAtSite           *string
	availableOnDevice         *string
	availableOnVirtualmachine *string
	created                   *[]time.Time
	createdEmpty              *[]time.Time
	createdGt                 *[]time.Time
	createdGte                *[]time.Time
	createdLt                 *[]time.Time
	createdLte                *[]time.Time
	createdN                  *[]time.Time
	createdByRequest          *string
	description               *[]string
	descriptionEmpty          *bool
	descriptionIc             *[]string
	descriptionIe             *[]string
	descriptionIew            *[]string
	descriptionIsw            *[]string
	descriptionN              *[]string
	descriptionNic            *[]string
	descriptionNie            *[]string
	descriptionNiew           *[]string
	descriptionNisw           *[]string
	group                     *[]string
	groupN                    *[]string
	groupId                   *[]*int32
	groupIdN                  *[]*int32
	id                        *[]int32
	idEmpty                   *bool
	idGt                      *[]int32
	idGte                     *[]int32
	idLt                      *[]int32
	idLte                     *[]int32
	idN                       *[]int32
	l2vpn                     *[]*int64
	l2vpnN                    *[]*int64
	l2vpnId                   *[]int32
	l2vpnIdN                  *[]int32
	lastUpdated               *[]time.Time
	lastUpdatedEmpty          *[]time.Time
	lastUpdatedGt             *[]time.Time
	lastUpdatedGte            *[]time.Time
	lastUpdatedLt             *[]time.Time
	lastUpdatedLte            *[]time.Time
	lastUpdatedN              *[]time.Time
	limit                     *int32
	modifiedByRequest         *string
	name                      *[]string
	nameEmpty                 *bool
	nameIc                    *[]string
	nameIe                    *[]string
	nameIew                   *[]string
	nameIsw                   *[]string
	nameN                     *[]string
	nameNic                   *[]string
	nameNie                   *[]string
	nameNiew                  *[]string
	nameNisw                  *[]string
	offset                    *int32
	ordering                  *string
	q                         *string
	region                    *[]string
	regionN                   *[]string
	regionId                  *[]string
	regionIdN                 *[]string
	role                      *[]string
	roleN                     *[]string
	roleId                    *[]*int32
	roleIdN                   *[]*int32
	site                      *[]string
	siteN                     *[]string
	siteGroup                 *[]string
	siteGroupN                *[]string
	siteGroupId               *[]string
	siteGroupIdN              *[]string
	siteId                    *[]*int32
	siteIdN                   *[]*int32
	status                    *[]string
	statusN                   *[]string
	tag                       *[]string
	tagN                      *[]string
	tenant                    *[]string
	tenantN                   *[]string
	tenantGroup               *[]string
	tenantGroupN              *[]string
	tenantGroupId             *[]string
	tenantGroupIdN            *[]string
	tenantId                  *[]*int32
	tenantIdN                 *[]*int32
	updatedByRequest          *string
	vid                       *[]int32
	vidEmpty                  *bool
	vidGt                     *[]int32
	vidGte                    *[]int32
	vidLt                     *[]int32
	vidLte                    *[]int32
	vidN                      *[]int32
}

func (r ApiIpamVlansListRequest) AvailableAtSite(availableAtSite string) ApiIpamVlansListRequest {
	r.availableAtSite = &availableAtSite
	return r
}

func (r ApiIpamVlansListRequest) AvailableOnDevice(availableOnDevice string) ApiIpamVlansListRequest {
	r.availableOnDevice = &availableOnDevice
	return r
}

func (r ApiIpamVlansListRequest) AvailableOnVirtualmachine(availableOnVirtualmachine string) ApiIpamVlansListRequest {
	r.availableOnVirtualmachine = &availableOnVirtualmachine
	return r
}

func (r ApiIpamVlansListRequest) Created(created []time.Time) ApiIpamVlansListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlansListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamVlansListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamVlansListRequest) CreatedGt(createdGt []time.Time) ApiIpamVlansListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamVlansListRequest) CreatedGte(createdGte []time.Time) ApiIpamVlansListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlansListRequest) CreatedLt(createdLt []time.Time) ApiIpamVlansListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamVlansListRequest) CreatedLte(createdLte []time.Time) ApiIpamVlansListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVlansListRequest) CreatedN(createdN []time.Time) ApiIpamVlansListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamVlansListRequest) CreatedByRequest(createdByRequest string) ApiIpamVlansListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamVlansListRequest) Description(description []string) ApiIpamVlansListRequest {
	r.description = &description
	return r
}

func (r ApiIpamVlansListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamVlansListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamVlansListRequest) DescriptionIc(descriptionIc []string) ApiIpamVlansListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamVlansListRequest) DescriptionIe(descriptionIe []string) ApiIpamVlansListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamVlansListRequest) DescriptionIew(descriptionIew []string) ApiIpamVlansListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamVlansListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamVlansListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamVlansListRequest) DescriptionN(descriptionN []string) ApiIpamVlansListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamVlansListRequest) DescriptionNic(descriptionNic []string) ApiIpamVlansListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamVlansListRequest) DescriptionNie(descriptionNie []string) ApiIpamVlansListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamVlansListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamVlansListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamVlansListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamVlansListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

// Group
func (r ApiIpamVlansListRequest) Group(group []string) ApiIpamVlansListRequest {
	r.group = &group
	return r
}

// Group
func (r ApiIpamVlansListRequest) GroupN(groupN []string) ApiIpamVlansListRequest {
	r.groupN = &groupN
	return r
}

// Group (ID)
func (r ApiIpamVlansListRequest) GroupId(groupId []*int32) ApiIpamVlansListRequest {
	r.groupId = &groupId
	return r
}

// Group (ID)
func (r ApiIpamVlansListRequest) GroupIdN(groupIdN []*int32) ApiIpamVlansListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiIpamVlansListRequest) Id(id []int32) ApiIpamVlansListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlansListRequest) IdEmpty(idEmpty bool) ApiIpamVlansListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamVlansListRequest) IdGt(idGt []int32) ApiIpamVlansListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamVlansListRequest) IdGte(idGte []int32) ApiIpamVlansListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamVlansListRequest) IdLt(idLt []int32) ApiIpamVlansListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamVlansListRequest) IdLte(idLte []int32) ApiIpamVlansListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamVlansListRequest) IdN(idN []int32) ApiIpamVlansListRequest {
	r.idN = &idN
	return r
}

// L2VPN
func (r ApiIpamVlansListRequest) L2vpn(l2vpn []*int64) ApiIpamVlansListRequest {
	r.l2vpn = &l2vpn
	return r
}

// L2VPN
func (r ApiIpamVlansListRequest) L2vpnN(l2vpnN []*int64) ApiIpamVlansListRequest {
	r.l2vpnN = &l2vpnN
	return r
}

// L2VPN (ID)
func (r ApiIpamVlansListRequest) L2vpnId(l2vpnId []int32) ApiIpamVlansListRequest {
	r.l2vpnId = &l2vpnId
	return r
}

// L2VPN (ID)
func (r ApiIpamVlansListRequest) L2vpnIdN(l2vpnIdN []int32) ApiIpamVlansListRequest {
	r.l2vpnIdN = &l2vpnIdN
	return r
}

func (r ApiIpamVlansListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVlansListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamVlansListRequest) Limit(limit int32) ApiIpamVlansListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVlansListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamVlansListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamVlansListRequest) Name(name []string) ApiIpamVlansListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVlansListRequest) NameEmpty(nameEmpty bool) ApiIpamVlansListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamVlansListRequest) NameIc(nameIc []string) ApiIpamVlansListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVlansListRequest) NameIe(nameIe []string) ApiIpamVlansListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVlansListRequest) NameIew(nameIew []string) ApiIpamVlansListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVlansListRequest) NameIsw(nameIsw []string) ApiIpamVlansListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVlansListRequest) NameN(nameN []string) ApiIpamVlansListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVlansListRequest) NameNic(nameNic []string) ApiIpamVlansListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVlansListRequest) NameNie(nameNie []string) ApiIpamVlansListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVlansListRequest) NameNiew(nameNiew []string) ApiIpamVlansListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVlansListRequest) NameNisw(nameNisw []string) ApiIpamVlansListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlansListRequest) Offset(offset int32) ApiIpamVlansListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVlansListRequest) Ordering(ordering string) ApiIpamVlansListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamVlansListRequest) Q(q string) ApiIpamVlansListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVlansListRequest) Region(region []string) ApiIpamVlansListRequest {
	r.region = &region
	return r
}

func (r ApiIpamVlansListRequest) RegionN(regionN []string) ApiIpamVlansListRequest {
	r.regionN = &regionN
	return r
}

func (r ApiIpamVlansListRequest) RegionId(regionId []string) ApiIpamVlansListRequest {
	r.regionId = &regionId
	return r
}

func (r ApiIpamVlansListRequest) RegionIdN(regionIdN []string) ApiIpamVlansListRequest {
	r.regionIdN = &regionIdN
	return r
}

// Role (slug)
func (r ApiIpamVlansListRequest) Role(role []string) ApiIpamVlansListRequest {
	r.role = &role
	return r
}

// Role (slug)
func (r ApiIpamVlansListRequest) RoleN(roleN []string) ApiIpamVlansListRequest {
	r.roleN = &roleN
	return r
}

// Role (ID)
func (r ApiIpamVlansListRequest) RoleId(roleId []*int32) ApiIpamVlansListRequest {
	r.roleId = &roleId
	return r
}

// Role (ID)
func (r ApiIpamVlansListRequest) RoleIdN(roleIdN []*int32) ApiIpamVlansListRequest {
	r.roleIdN = &roleIdN
	return r
}

// Site (slug)
func (r ApiIpamVlansListRequest) Site(site []string) ApiIpamVlansListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiIpamVlansListRequest) SiteN(siteN []string) ApiIpamVlansListRequest {
	r.siteN = &siteN
	return r
}

func (r ApiIpamVlansListRequest) SiteGroup(siteGroup []string) ApiIpamVlansListRequest {
	r.siteGroup = &siteGroup
	return r
}

func (r ApiIpamVlansListRequest) SiteGroupN(siteGroupN []string) ApiIpamVlansListRequest {
	r.siteGroupN = &siteGroupN
	return r
}

func (r ApiIpamVlansListRequest) SiteGroupId(siteGroupId []string) ApiIpamVlansListRequest {
	r.siteGroupId = &siteGroupId
	return r
}

func (r ApiIpamVlansListRequest) SiteGroupIdN(siteGroupIdN []string) ApiIpamVlansListRequest {
	r.siteGroupIdN = &siteGroupIdN
	return r
}

// Site (ID)
func (r ApiIpamVlansListRequest) SiteId(siteId []*int32) ApiIpamVlansListRequest {
	r.siteId = &siteId
	return r
}

// Site (ID)
func (r ApiIpamVlansListRequest) SiteIdN(siteIdN []*int32) ApiIpamVlansListRequest {
	r.siteIdN = &siteIdN
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) Status(status []string) ApiIpamVlansListRequest {
	r.status = &status
	return r
}

// Operational status of this VLAN
func (r ApiIpamVlansListRequest) StatusN(statusN []string) ApiIpamVlansListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamVlansListRequest) Tag(tag []string) ApiIpamVlansListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVlansListRequest) TagN(tagN []string) ApiIpamVlansListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamVlansListRequest) Tenant(tenant []string) ApiIpamVlansListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamVlansListRequest) TenantN(tenantN []string) ApiIpamVlansListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamVlansListRequest) TenantGroup(tenantGroup []string) ApiIpamVlansListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamVlansListRequest) TenantGroupN(tenantGroupN []string) ApiIpamVlansListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamVlansListRequest) TenantGroupId(tenantGroupId []string) ApiIpamVlansListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamVlansListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamVlansListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamVlansListRequest) TenantId(tenantId []*int32) ApiIpamVlansListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamVlansListRequest) TenantIdN(tenantIdN []*int32) ApiIpamVlansListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamVlansListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamVlansListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamVlansListRequest) Vid(vid []int32) ApiIpamVlansListRequest {
	r.vid = &vid
	return r
}

func (r ApiIpamVlansListRequest) VidEmpty(vidEmpty bool) ApiIpamVlansListRequest {
	r.vidEmpty = &vidEmpty
	return r
}

func (r ApiIpamVlansListRequest) VidGt(vidGt []int32) ApiIpamVlansListRequest {
	r.vidGt = &vidGt
	return r
}

func (r ApiIpamVlansListRequest) VidGte(vidGte []int32) ApiIpamVlansListRequest {
	r.vidGte = &vidGte
	return r
}

func (r ApiIpamVlansListRequest) VidLt(vidLt []int32) ApiIpamVlansListRequest {
	r.vidLt = &vidLt
	return r
}

func (r ApiIpamVlansListRequest) VidLte(vidLte []int32) ApiIpamVlansListRequest {
	r.vidLte = &vidLte
	return r
}

func (r ApiIpamVlansListRequest) VidN(vidN []int32) ApiIpamVlansListRequest {
	r.vidN = &vidN
	return r
}

func (r ApiIpamVlansListRequest) Execute() (*PaginatedVLANList, *http.Response, error) {
	return r.ApiService.IpamVlansListExecute(r)
}

/*
IpamVlansList Method for IpamVlansList

Get a list of VLAN objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVlansListRequest
*/
func (a *IpamAPIService) IpamVlansList(ctx context.Context) ApiIpamVlansListRequest {
	return ApiIpamVlansListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedVLANList
func (a *IpamAPIService) IpamVlansListExecute(r ApiIpamVlansListRequest) (*PaginatedVLANList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedVLANList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.availableAtSite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available_at_site", r.availableAtSite, "")
	}
	if r.availableOnDevice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available_on_device", r.availableOnDevice, "")
	}
	if r.availableOnVirtualmachine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available_on_virtualmachine", r.availableOnVirtualmachine, "")
	}
	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group", t, "multi")
		}
	}
	if r.groupN != nil {
		t := *r.groupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group__n", t, "multi")
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", t, "multi")
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_id__n", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.l2vpn != nil {
		t := *r.l2vpn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn", t, "multi")
		}
	}
	if r.l2vpnN != nil {
		t := *r.l2vpnN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn__n", t, "multi")
		}
	}
	if r.l2vpnId != nil {
		t := *r.l2vpnId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id", t, "multi")
		}
	}
	if r.l2vpnIdN != nil {
		t := *r.l2vpnIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "l2vpn_id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.region != nil {
		t := *r.region
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region", t, "multi")
		}
	}
	if r.regionN != nil {
		t := *r.regionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region__n", t, "multi")
		}
	}
	if r.regionId != nil {
		t := *r.regionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region_id", t, "multi")
		}
	}
	if r.regionIdN != nil {
		t := *r.regionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "region_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "region_id__n", t, "multi")
		}
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role", t, "multi")
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role__n", t, "multi")
		}
	}
	if r.roleId != nil {
		t := *r.roleId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id", t, "multi")
		}
	}
	if r.roleIdN != nil {
		t := *r.roleIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "role_id__n", t, "multi")
		}
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site", t, "multi")
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site__n", t, "multi")
		}
	}
	if r.siteGroup != nil {
		t := *r.siteGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group", t, "multi")
		}
	}
	if r.siteGroupN != nil {
		t := *r.siteGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group__n", t, "multi")
		}
	}
	if r.siteGroupId != nil {
		t := *r.siteGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id", t, "multi")
		}
	}
	if r.siteGroupIdN != nil {
		t := *r.siteGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_group_id__n", t, "multi")
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", t, "multi")
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "site_id__n", t, "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status__n", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	if r.vid != nil {
		t := *r.vid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid", t, "multi")
		}
	}
	if r.vidEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vid__empty", r.vidEmpty, "")
	}
	if r.vidGt != nil {
		t := *r.vidGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gt", t, "multi")
		}
	}
	if r.vidGte != nil {
		t := *r.vidGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__gte", t, "multi")
		}
	}
	if r.vidLt != nil {
		t := *r.vidLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lt", t, "multi")
		}
	}
	if r.vidLte != nil {
		t := *r.vidLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__lte", t, "multi")
		}
	}
	if r.vidN != nil {
		t := *r.vidN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vid__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vid__n", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansPartialUpdateRequest struct {
	ctx                        context.Context
	ApiService                 *IpamAPIService
	id                         int32
	patchedWritableVLANRequest *PatchedWritableVLANRequest
}

func (r ApiIpamVlansPartialUpdateRequest) PatchedWritableVLANRequest(patchedWritableVLANRequest PatchedWritableVLANRequest) ApiIpamVlansPartialUpdateRequest {
	r.patchedWritableVLANRequest = &patchedWritableVLANRequest
	return r
}

func (r ApiIpamVlansPartialUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansPartialUpdateExecute(r)
}

/*
IpamVlansPartialUpdate Method for IpamVlansPartialUpdate

Patch a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN.
	@return ApiIpamVlansPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVlansPartialUpdate(ctx context.Context, id int32) ApiIpamVlansPartialUpdateRequest {
	return ApiIpamVlansPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return VLAN
func (a *IpamAPIService) IpamVlansPartialUpdateExecute(r ApiIpamVlansPartialUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableVLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamVlansRetrieveRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansRetrieveExecute(r)
}

/*
IpamVlansRetrieve Method for IpamVlansRetrieve

Get a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN.
	@return ApiIpamVlansRetrieveRequest
*/
func (a *IpamAPIService) IpamVlansRetrieve(ctx context.Context, id int32) ApiIpamVlansRetrieveRequest {
	return ApiIpamVlansRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return VLAN
func (a *IpamAPIService) IpamVlansRetrieveExecute(r ApiIpamVlansRetrieveRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansUpdateRequest struct {
	ctx                 context.Context
	ApiService          *IpamAPIService
	id                  int32
	writableVLANRequest *WritableVLANRequest
}

func (r ApiIpamVlansUpdateRequest) WritableVLANRequest(writableVLANRequest WritableVLANRequest) ApiIpamVlansUpdateRequest {
	r.writableVLANRequest = &writableVLANRequest
	return r
}

func (r ApiIpamVlansUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansUpdateExecute(r)
}

/*
IpamVlansUpdate Method for IpamVlansUpdate

Put a VLAN object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VLAN.
	@return ApiIpamVlansUpdateRequest
*/
func (a *IpamAPIService) IpamVlansUpdate(ctx context.Context, id int32) ApiIpamVlansUpdateRequest {
	return ApiIpamVlansUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return VLAN
func (a *IpamAPIService) IpamVlansUpdateExecute(r ApiIpamVlansUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVlansUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVLANRequest == nil {
		return localVarReturnValue, nil, reportError("writableVLANRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVLANRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	vRFRequest *[]VRFRequest
}

func (r ApiIpamVrfsBulkDestroyRequest) VRFRequest(vRFRequest []VRFRequest) ApiIpamVrfsBulkDestroyRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfsBulkDestroyExecute(r)
}

/*
IpamVrfsBulkDestroy Method for IpamVrfsBulkDestroy

Delete a list of VRF objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVrfsBulkDestroyRequest
*/
func (a *IpamAPIService) IpamVrfsBulkDestroy(ctx context.Context) ApiIpamVrfsBulkDestroyRequest {
	return ApiIpamVrfsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVrfsBulkDestroyExecute(r ApiIpamVrfsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return nil, reportError("vRFRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkPartialUpdateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	vRFRequest *[]VRFRequest
}

func (r ApiIpamVrfsBulkPartialUpdateRequest) VRFRequest(vRFRequest []VRFRequest) ApiIpamVrfsBulkPartialUpdateRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsBulkPartialUpdateRequest) Execute() ([]VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsBulkPartialUpdateExecute(r)
}

/*
IpamVrfsBulkPartialUpdate Method for IpamVrfsBulkPartialUpdate

Patch a list of VRF objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVrfsBulkPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsBulkPartialUpdate(ctx context.Context) ApiIpamVrfsBulkPartialUpdateRequest {
	return ApiIpamVrfsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []VRF
func (a *IpamAPIService) IpamVrfsBulkPartialUpdateExecute(r ApiIpamVrfsBulkPartialUpdateRequest) ([]VRF, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return localVarReturnValue, nil, reportError("vRFRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkUpdateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	vRFRequest *[]VRFRequest
}

func (r ApiIpamVrfsBulkUpdateRequest) VRFRequest(vRFRequest []VRFRequest) ApiIpamVrfsBulkUpdateRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsBulkUpdateRequest) Execute() ([]VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsBulkUpdateExecute(r)
}

/*
IpamVrfsBulkUpdate Method for IpamVrfsBulkUpdate

Put a list of VRF objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVrfsBulkUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsBulkUpdate(ctx context.Context) ApiIpamVrfsBulkUpdateRequest {
	return ApiIpamVrfsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []VRF
func (a *IpamAPIService) IpamVrfsBulkUpdateExecute(r ApiIpamVrfsBulkUpdateRequest) ([]VRF, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return localVarReturnValue, nil, reportError("vRFRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsCreateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	vRFRequest *VRFRequest
}

func (r ApiIpamVrfsCreateRequest) VRFRequest(vRFRequest VRFRequest) ApiIpamVrfsCreateRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsCreateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsCreateExecute(r)
}

/*
IpamVrfsCreate Method for IpamVrfsCreate

Post a list of VRF objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVrfsCreateRequest
*/
func (a *IpamAPIService) IpamVrfsCreate(ctx context.Context) ApiIpamVrfsCreateRequest {
	return ApiIpamVrfsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VRF
func (a *IpamAPIService) IpamVrfsCreateExecute(r ApiIpamVrfsCreateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return localVarReturnValue, nil, reportError("vRFRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsDestroyRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamVrfsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfsDestroyExecute(r)
}

/*
IpamVrfsDestroy Method for IpamVrfsDestroy

Delete a VRF object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VRF.
	@return ApiIpamVrfsDestroyRequest
*/
func (a *IpamAPIService) IpamVrfsDestroy(ctx context.Context, id int32) ApiIpamVrfsDestroyRequest {
	return ApiIpamVrfsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *IpamAPIService) IpamVrfsDestroyExecute(r ApiIpamVrfsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfsListRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	created           *[]time.Time
	createdEmpty      *[]time.Time
	createdGt         *[]time.Time
	createdGte        *[]time.Time
	createdLt         *[]time.Time
	createdLte        *[]time.Time
	createdN          *[]time.Time
	createdByRequest  *string
	description       *[]string
	descriptionEmpty  *bool
	descriptionIc     *[]string
	descriptionIe     *[]string
	descriptionIew    *[]string
	descriptionIsw    *[]string
	descriptionN      *[]string
	descriptionNic    *[]string
	descriptionNie    *[]string
	descriptionNiew   *[]string
	descriptionNisw   *[]string
	enforceUnique     *bool
	exportTarget      *[]string
	exportTargetN     *[]string
	exportTargetId    *[]int32
	exportTargetIdN   *[]int32
	id                *[]int32
	idEmpty           *bool
	idGt              *[]int32
	idGte             *[]int32
	idLt              *[]int32
	idLte             *[]int32
	idN               *[]int32
	importTarget      *[]string
	importTargetN     *[]string
	importTargetId    *[]int32
	importTargetIdN   *[]int32
	lastUpdated       *[]time.Time
	lastUpdatedEmpty  *[]time.Time
	lastUpdatedGt     *[]time.Time
	lastUpdatedGte    *[]time.Time
	lastUpdatedLt     *[]time.Time
	lastUpdatedLte    *[]time.Time
	lastUpdatedN      *[]time.Time
	limit             *int32
	modifiedByRequest *string
	name              *[]string
	nameEmpty         *bool
	nameIc            *[]string
	nameIe            *[]string
	nameIew           *[]string
	nameIsw           *[]string
	nameN             *[]string
	nameNic           *[]string
	nameNie           *[]string
	nameNiew          *[]string
	nameNisw          *[]string
	offset            *int32
	ordering          *string
	q                 *string
	rd                *[]string
	rdEmpty           *bool
	rdIc              *[]string
	rdIe              *[]string
	rdIew             *[]string
	rdIsw             *[]string
	rdN               *[]string
	rdNic             *[]string
	rdNie             *[]string
	rdNiew            *[]string
	rdNisw            *[]string
	tag               *[]string
	tagN              *[]string
	tenant            *[]string
	tenantN           *[]string
	tenantGroup       *[]string
	tenantGroupN      *[]string
	tenantGroupId     *[]string
	tenantGroupIdN    *[]string
	tenantId          *[]*int32
	tenantIdN         *[]*int32
	updatedByRequest  *string
}

func (r ApiIpamVrfsListRequest) Created(created []time.Time) ApiIpamVrfsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVrfsListRequest) CreatedEmpty(createdEmpty []time.Time) ApiIpamVrfsListRequest {
	r.createdEmpty = &createdEmpty
	return r
}

func (r ApiIpamVrfsListRequest) CreatedGt(createdGt []time.Time) ApiIpamVrfsListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiIpamVrfsListRequest) CreatedGte(createdGte []time.Time) ApiIpamVrfsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVrfsListRequest) CreatedLt(createdLt []time.Time) ApiIpamVrfsListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiIpamVrfsListRequest) CreatedLte(createdLte []time.Time) ApiIpamVrfsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVrfsListRequest) CreatedN(createdN []time.Time) ApiIpamVrfsListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiIpamVrfsListRequest) CreatedByRequest(createdByRequest string) ApiIpamVrfsListRequest {
	r.createdByRequest = &createdByRequest
	return r
}

func (r ApiIpamVrfsListRequest) Description(description []string) ApiIpamVrfsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionEmpty(descriptionEmpty bool) ApiIpamVrfsListRequest {
	r.descriptionEmpty = &descriptionEmpty
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionIc(descriptionIc []string) ApiIpamVrfsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionIe(descriptionIe []string) ApiIpamVrfsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionIew(descriptionIew []string) ApiIpamVrfsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamVrfsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionN(descriptionN []string) ApiIpamVrfsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionNic(descriptionNic []string) ApiIpamVrfsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionNie(descriptionNie []string) ApiIpamVrfsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamVrfsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamVrfsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamVrfsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamVrfsListRequest) EnforceUnique(enforceUnique bool) ApiIpamVrfsListRequest {
	r.enforceUnique = &enforceUnique
	return r
}

// Export target (name)
func (r ApiIpamVrfsListRequest) ExportTarget(exportTarget []string) ApiIpamVrfsListRequest {
	r.exportTarget = &exportTarget
	return r
}

// Export target (name)
func (r ApiIpamVrfsListRequest) ExportTargetN(exportTargetN []string) ApiIpamVrfsListRequest {
	r.exportTargetN = &exportTargetN
	return r
}

// Export target
func (r ApiIpamVrfsListRequest) ExportTargetId(exportTargetId []int32) ApiIpamVrfsListRequest {
	r.exportTargetId = &exportTargetId
	return r
}

// Export target
func (r ApiIpamVrfsListRequest) ExportTargetIdN(exportTargetIdN []int32) ApiIpamVrfsListRequest {
	r.exportTargetIdN = &exportTargetIdN
	return r
}

func (r ApiIpamVrfsListRequest) Id(id []int32) ApiIpamVrfsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVrfsListRequest) IdEmpty(idEmpty bool) ApiIpamVrfsListRequest {
	r.idEmpty = &idEmpty
	return r
}

func (r ApiIpamVrfsListRequest) IdGt(idGt []int32) ApiIpamVrfsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiIpamVrfsListRequest) IdGte(idGte []int32) ApiIpamVrfsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiIpamVrfsListRequest) IdLt(idLt []int32) ApiIpamVrfsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiIpamVrfsListRequest) IdLte(idLte []int32) ApiIpamVrfsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiIpamVrfsListRequest) IdN(idN []int32) ApiIpamVrfsListRequest {
	r.idN = &idN
	return r
}

// Import target (name)
func (r ApiIpamVrfsListRequest) ImportTarget(importTarget []string) ApiIpamVrfsListRequest {
	r.importTarget = &importTarget
	return r
}

// Import target (name)
func (r ApiIpamVrfsListRequest) ImportTargetN(importTargetN []string) ApiIpamVrfsListRequest {
	r.importTargetN = &importTargetN
	return r
}

// Import target
func (r ApiIpamVrfsListRequest) ImportTargetId(importTargetId []int32) ApiIpamVrfsListRequest {
	r.importTargetId = &importTargetId
	return r
}

// Import target
func (r ApiIpamVrfsListRequest) ImportTargetIdN(importTargetIdN []int32) ApiIpamVrfsListRequest {
	r.importTargetIdN = &importTargetIdN
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdated(lastUpdated []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedEmpty(lastUpdatedEmpty []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedEmpty = &lastUpdatedEmpty
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedGt(lastUpdatedGt []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedGt = &lastUpdatedGt
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedGte(lastUpdatedGte []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedLt(lastUpdatedLt []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedLt = &lastUpdatedLt
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedLte(lastUpdatedLte []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedN(lastUpdatedN []time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedN = &lastUpdatedN
	return r
}

// Number of results to return per page.
func (r ApiIpamVrfsListRequest) Limit(limit int32) ApiIpamVrfsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVrfsListRequest) ModifiedByRequest(modifiedByRequest string) ApiIpamVrfsListRequest {
	r.modifiedByRequest = &modifiedByRequest
	return r
}

func (r ApiIpamVrfsListRequest) Name(name []string) ApiIpamVrfsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVrfsListRequest) NameEmpty(nameEmpty bool) ApiIpamVrfsListRequest {
	r.nameEmpty = &nameEmpty
	return r
}

func (r ApiIpamVrfsListRequest) NameIc(nameIc []string) ApiIpamVrfsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVrfsListRequest) NameIe(nameIe []string) ApiIpamVrfsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVrfsListRequest) NameIew(nameIew []string) ApiIpamVrfsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVrfsListRequest) NameIsw(nameIsw []string) ApiIpamVrfsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVrfsListRequest) NameN(nameN []string) ApiIpamVrfsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVrfsListRequest) NameNic(nameNic []string) ApiIpamVrfsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVrfsListRequest) NameNie(nameNie []string) ApiIpamVrfsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVrfsListRequest) NameNiew(nameNiew []string) ApiIpamVrfsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVrfsListRequest) NameNisw(nameNisw []string) ApiIpamVrfsListRequest {
	r.nameNisw = &nameNisw
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVrfsListRequest) Offset(offset int32) ApiIpamVrfsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiIpamVrfsListRequest) Ordering(ordering string) ApiIpamVrfsListRequest {
	r.ordering = &ordering
	return r
}

// Search
func (r ApiIpamVrfsListRequest) Q(q string) ApiIpamVrfsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVrfsListRequest) Rd(rd []string) ApiIpamVrfsListRequest {
	r.rd = &rd
	return r
}

func (r ApiIpamVrfsListRequest) RdEmpty(rdEmpty bool) ApiIpamVrfsListRequest {
	r.rdEmpty = &rdEmpty
	return r
}

func (r ApiIpamVrfsListRequest) RdIc(rdIc []string) ApiIpamVrfsListRequest {
	r.rdIc = &rdIc
	return r
}

func (r ApiIpamVrfsListRequest) RdIe(rdIe []string) ApiIpamVrfsListRequest {
	r.rdIe = &rdIe
	return r
}

func (r ApiIpamVrfsListRequest) RdIew(rdIew []string) ApiIpamVrfsListRequest {
	r.rdIew = &rdIew
	return r
}

func (r ApiIpamVrfsListRequest) RdIsw(rdIsw []string) ApiIpamVrfsListRequest {
	r.rdIsw = &rdIsw
	return r
}

func (r ApiIpamVrfsListRequest) RdN(rdN []string) ApiIpamVrfsListRequest {
	r.rdN = &rdN
	return r
}

func (r ApiIpamVrfsListRequest) RdNic(rdNic []string) ApiIpamVrfsListRequest {
	r.rdNic = &rdNic
	return r
}

func (r ApiIpamVrfsListRequest) RdNie(rdNie []string) ApiIpamVrfsListRequest {
	r.rdNie = &rdNie
	return r
}

func (r ApiIpamVrfsListRequest) RdNiew(rdNiew []string) ApiIpamVrfsListRequest {
	r.rdNiew = &rdNiew
	return r
}

func (r ApiIpamVrfsListRequest) RdNisw(rdNisw []string) ApiIpamVrfsListRequest {
	r.rdNisw = &rdNisw
	return r
}

func (r ApiIpamVrfsListRequest) Tag(tag []string) ApiIpamVrfsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVrfsListRequest) TagN(tagN []string) ApiIpamVrfsListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamVrfsListRequest) Tenant(tenant []string) ApiIpamVrfsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamVrfsListRequest) TenantN(tenantN []string) ApiIpamVrfsListRequest {
	r.tenantN = &tenantN
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroup(tenantGroup []string) ApiIpamVrfsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroupN(tenantGroupN []string) ApiIpamVrfsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroupId(tenantGroupId []string) ApiIpamVrfsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

func (r ApiIpamVrfsListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamVrfsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamVrfsListRequest) TenantId(tenantId []*int32) ApiIpamVrfsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamVrfsListRequest) TenantIdN(tenantIdN []*int32) ApiIpamVrfsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamVrfsListRequest) UpdatedByRequest(updatedByRequest string) ApiIpamVrfsListRequest {
	r.updatedByRequest = &updatedByRequest
	return r
}

func (r ApiIpamVrfsListRequest) Execute() (*PaginatedVRFList, *http.Response, error) {
	return r.ApiService.IpamVrfsListExecute(r)
}

/*
IpamVrfsList Method for IpamVrfsList

Get a list of VRF objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIpamVrfsListRequest
*/
func (a *IpamAPIService) IpamVrfsList(ctx context.Context) ApiIpamVrfsListRequest {
	return ApiIpamVrfsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PaginatedVRFList
func (a *IpamAPIService) IpamVrfsListExecute(r ApiIpamVrfsListRequest) (*PaginatedVRFList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedVRFList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created", t, "multi")
		}
	}
	if r.createdEmpty != nil {
		t := *r.createdEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__empty", t, "multi")
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gt", t, "multi")
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__gte", t, "multi")
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lt", t, "multi")
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__lte", t, "multi")
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created__n", t, "multi")
		}
	}
	if r.createdByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_request", r.createdByRequest, "")
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description", t, "multi")
		}
	}
	if r.descriptionEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description__empty", r.descriptionEmpty, "")
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ic", t, "multi")
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__ie", t, "multi")
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__iew", t, "multi")
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__isw", t, "multi")
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__n", t, "multi")
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nic", t, "multi")
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nie", t, "multi")
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__niew", t, "multi")
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "description__nisw", t, "multi")
		}
	}
	if r.enforceUnique != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enforce_unique", r.enforceUnique, "")
	}
	if r.exportTarget != nil {
		t := *r.exportTarget
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target", t, "multi")
		}
	}
	if r.exportTargetN != nil {
		t := *r.exportTargetN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target__n", t, "multi")
		}
	}
	if r.exportTargetId != nil {
		t := *r.exportTargetId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id", t, "multi")
		}
	}
	if r.exportTargetIdN != nil {
		t := *r.exportTargetIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "export_target_id__n", t, "multi")
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.idEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__empty", r.idEmpty, "")
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gt", t, "multi")
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__gte", t, "multi")
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lt", t, "multi")
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__lte", t, "multi")
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id__n", t, "multi")
		}
	}
	if r.importTarget != nil {
		t := *r.importTarget
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target", t, "multi")
		}
	}
	if r.importTargetN != nil {
		t := *r.importTargetN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target__n", t, "multi")
		}
	}
	if r.importTargetId != nil {
		t := *r.importTargetId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id", t, "multi")
		}
	}
	if r.importTargetIdN != nil {
		t := *r.importTargetIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "import_target_id__n", t, "multi")
		}
	}
	if r.lastUpdated != nil {
		t := *r.lastUpdated
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated", t, "multi")
		}
	}
	if r.lastUpdatedEmpty != nil {
		t := *r.lastUpdatedEmpty
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__empty", t, "multi")
		}
	}
	if r.lastUpdatedGt != nil {
		t := *r.lastUpdatedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gt", t, "multi")
		}
	}
	if r.lastUpdatedGte != nil {
		t := *r.lastUpdatedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__gte", t, "multi")
		}
	}
	if r.lastUpdatedLt != nil {
		t := *r.lastUpdatedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lt", t, "multi")
		}
	}
	if r.lastUpdatedLte != nil {
		t := *r.lastUpdatedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__lte", t, "multi")
		}
	}
	if r.lastUpdatedN != nil {
		t := *r.lastUpdatedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "last_updated__n", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.modifiedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_by_request", r.modifiedByRequest, "")
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name", t, "multi")
		}
	}
	if r.nameEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__empty", r.nameEmpty, "")
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ic", t, "multi")
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__ie", t, "multi")
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__iew", t, "multi")
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__isw", t, "multi")
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__n", t, "multi")
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nic", t, "multi")
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nie", t, "multi")
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__niew", t, "multi")
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "name__nisw", t, "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.rd != nil {
		t := *r.rd
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd", t, "multi")
		}
	}
	if r.rdEmpty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rd__empty", r.rdEmpty, "")
	}
	if r.rdIc != nil {
		t := *r.rdIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ic", t, "multi")
		}
	}
	if r.rdIe != nil {
		t := *r.rdIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__ie", t, "multi")
		}
	}
	if r.rdIew != nil {
		t := *r.rdIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__iew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__iew", t, "multi")
		}
	}
	if r.rdIsw != nil {
		t := *r.rdIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__isw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__isw", t, "multi")
		}
	}
	if r.rdN != nil {
		t := *r.rdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__n", t, "multi")
		}
	}
	if r.rdNic != nil {
		t := *r.rdNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nic", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nic", t, "multi")
		}
	}
	if r.rdNie != nil {
		t := *r.rdNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nie", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nie", t, "multi")
		}
	}
	if r.rdNiew != nil {
		t := *r.rdNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__niew", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__niew", t, "multi")
		}
	}
	if r.rdNisw != nil {
		t := *r.rdNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nisw", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "rd__nisw", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag__n", t, "multi")
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", t, "multi")
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant__n", t, "multi")
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group", t, "multi")
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group__n", t, "multi")
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id", t, "multi")
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_group_id__n", t, "multi")
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", t, "multi")
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id__n", t, "multi")
		}
	}
	if r.updatedByRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_by_request", r.updatedByRequest, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsPartialUpdateRequest struct {
	ctx               context.Context
	ApiService        *IpamAPIService
	id                int32
	patchedVRFRequest *PatchedVRFRequest
}

func (r ApiIpamVrfsPartialUpdateRequest) PatchedVRFRequest(patchedVRFRequest PatchedVRFRequest) ApiIpamVrfsPartialUpdateRequest {
	r.patchedVRFRequest = &patchedVRFRequest
	return r
}

func (r ApiIpamVrfsPartialUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsPartialUpdateExecute(r)
}

/*
IpamVrfsPartialUpdate Method for IpamVrfsPartialUpdate

Patch a VRF object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VRF.
	@return ApiIpamVrfsPartialUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsPartialUpdate(ctx context.Context, id int32) ApiIpamVrfsPartialUpdateRequest {
	return ApiIpamVrfsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return VRF
func (a *IpamAPIService) IpamVrfsPartialUpdateExecute(r ApiIpamVrfsPartialUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedVRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsRetrieveRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
}

func (r ApiIpamVrfsRetrieveRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsRetrieveExecute(r)
}

/*
IpamVrfsRetrieve Method for IpamVrfsRetrieve

Get a VRF object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VRF.
	@return ApiIpamVrfsRetrieveRequest
*/
func (a *IpamAPIService) IpamVrfsRetrieve(ctx context.Context, id int32) ApiIpamVrfsRetrieveRequest {
	return ApiIpamVrfsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return VRF
func (a *IpamAPIService) IpamVrfsRetrieveExecute(r ApiIpamVrfsRetrieveRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsUpdateRequest struct {
	ctx        context.Context
	ApiService *IpamAPIService
	id         int32
	vRFRequest *VRFRequest
}

func (r ApiIpamVrfsUpdateRequest) VRFRequest(vRFRequest VRFRequest) ApiIpamVrfsUpdateRequest {
	r.vRFRequest = &vRFRequest
	return r
}

func (r ApiIpamVrfsUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsUpdateExecute(r)
}

/*
IpamVrfsUpdate Method for IpamVrfsUpdate

Put a VRF object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this VRF.
	@return ApiIpamVrfsUpdateRequest
*/
func (a *IpamAPIService) IpamVrfsUpdate(ctx context.Context, id int32) ApiIpamVrfsUpdateRequest {
	return ApiIpamVrfsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return VRF
func (a *IpamAPIService) IpamVrfsUpdateExecute(r ApiIpamVrfsUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamAPIService.IpamVrfsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vRFRequest == nil {
		return localVarReturnValue, nil, reportError("vRFRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vRFRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
